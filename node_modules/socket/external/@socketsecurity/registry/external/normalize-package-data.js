'use strict'

const require$$0 = require('url')
const require$$0$1 = require('module')
const require$$0$2 = require('util')

let debug_1
let hasRequiredDebug
function requireDebug() {
  if (hasRequiredDebug) {
    return debug_1
  }
  hasRequiredDebug = 1
  const debug =
    typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...args) => console.error('SEMVER', ...args)
      : () => {}
  debug_1 = debug
  return debug_1
}

let constants
let hasRequiredConstants
function requireConstants() {
  if (hasRequiredConstants) {
    return constants
  }
  hasRequiredConstants = 1

  // Note: this is the semver.org version of the spec that it implements
  // Not necessarily the package version of this code.
  const SEMVER_SPEC_VERSION = '2.0.0'
  const MAX_LENGTH = 256
  const MAX_SAFE_INTEGER =
    Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991

  // Max safe segment length for coercion.
  const MAX_SAFE_COMPONENT_LENGTH = 16

  // Max safe length for a build identifier. The max length minus 6 characters for
  // the shortest version with a build 0.0.0+BUILD.
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6
  const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
  ]
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
  }
  return constants
}

const re = { exports: {} }

let hasRequiredRe
function requireRe() {
  if (hasRequiredRe) {
    return re.exports
  }
  hasRequiredRe = 1
  ;(function (module, exports) {
    const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } =
      requireConstants()
    const debug = requireDebug()
    exports = module.exports = {}

    // The actual regexps go on exports.re
    const re = (exports.re = [])
    const safeRe = (exports.safeRe = [])
    const src = (exports.src = [])
    const safeSrc = (exports.safeSrc = [])
    const t = (exports.t = {})
    let R = 0
    const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

    // Replace some greedy regex tokens to prevent regex dos issues. These regex are
    // used internally via the safeRe object since all inputs in this library get
    // normalized first to trim and collapse all extra whitespace. The original
    // regexes are exported for userland consumption and lower level usage. A
    // future breaking change could export the safer regex only with a note that
    // all input should have extra whitespace removed.
    const safeRegexReplacements = [
      ['\\s', 1],
      ['\\d', MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ]
    const makeSafeRegex = value => {
      for (const [token, max] of safeRegexReplacements) {
        value = value
          .split(`${token}*`)
          .join(`${token}{0,${max}}`)
          .split(`${token}+`)
          .join(`${token}{1,${max}}`)
      }
      return value
    }
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value)
      const index = R++
      debug(name, index, value)
      t[name] = index
      src[index] = value
      safeSrc[index] = safe
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
      safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
    }

    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.

    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
    createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

    // ## Main Version
    // Three dot-separated numeric identifiers.

    createToken(
      'MAINVERSION',
      `(${src[t.NUMERICIDENTIFIER]})\\.` +
        `(${src[t.NUMERICIDENTIFIER]})\\.` +
        `(${src[t.NUMERICIDENTIFIER]})`
    )
    createToken(
      'MAINVERSIONLOOSE',
      `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
        `(${src[t.NUMERICIDENTIFIERLOOSE]})`
    )

    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.
    // Non-numberic identifiers include numberic identifiers but can be longer.
    // Therefore non-numberic identifiers must go first.

    createToken(
      'PRERELEASEIDENTIFIER',
      `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`
    )
    createToken(
      'PRERELEASEIDENTIFIERLOOSE',
      `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`
    )

    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    createToken(
      'PRERELEASE',
      `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`
    )
    createToken(
      'PRERELEASELOOSE',
      `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`
    )

    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    createToken(
      'BUILD',
      `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`
    )

    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.

    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    createToken(
      'FULLPLAIN',
      `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`
    )
    createToken('FULL', `^${src[t.FULLPLAIN]}$`)

    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    createToken(
      'LOOSEPLAIN',
      `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`
    )
    createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)
    createToken('GTLT', '((?:<|>)?=?)')

    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    createToken(
      'XRANGEIDENTIFIERLOOSE',
      `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`
    )
    createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)
    createToken(
      'XRANGEPLAIN',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
        `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` +
        `)?)?`
    )
    createToken(
      'XRANGEPLAINLOOSE',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
        `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` +
        `)?)?`
    )
    createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
    createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

    // Coercion.
    // Extract anything that could conceivably be a part of a valid semver
    createToken(
      'COERCEPLAIN',
      `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
        `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
        `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`
    )
    createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
    createToken(
      'COERCEFULL',
      src[t.COERCEPLAIN] +
        `(?:${src[t.PRERELEASE]})?` +
        `(?:${src[t.BUILD]})?` +
        `(?:$|[^\\d])`
    )
    createToken('COERCERTL', src[t.COERCE], true)
    createToken('COERCERTLFULL', src[t.COERCEFULL], true)

    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    createToken('LONETILDE', '(?:~>?)')
    createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
    exports.tildeTrimReplace = '$1~'
    createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
    createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    createToken('LONECARET', '(?:\\^)')
    createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
    exports.caretTrimReplace = '$1^'
    createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
    createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    createToken(
      'COMPARATORLOOSE',
      `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`
    )
    createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    createToken(
      'COMPARATORTRIM',
      `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,
      true
    )
    exports.comparatorTrimReplace = '$1$2$3'

    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    createToken(
      'HYPHENRANGE',
      `^\\s*(${src[t.XRANGEPLAIN]})` +
        `\\s+-\\s+` +
        `(${src[t.XRANGEPLAIN]})` +
        `\\s*$`
    )
    createToken(
      'HYPHENRANGELOOSE',
      `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
        `\\s+-\\s+` +
        `(${src[t.XRANGEPLAINLOOSE]})` +
        `\\s*$`
    )

    // Star ranges basically just allow anything at all.
    createToken('STAR', '(<|>)?=?\\s*\\*')
    // >=0.0.0 is like a star
    createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
    createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')
  })(re, re.exports)
  return re.exports
}

let parseOptions_1
let hasRequiredParseOptions
function requireParseOptions() {
  if (hasRequiredParseOptions) {
    return parseOptions_1
  }
  hasRequiredParseOptions = 1

  // parse out just the options we care about
  const looseOption = Object.freeze({
    loose: true
  })
  const emptyOpts = Object.freeze({})
  const parseOptions = options => {
    if (!options) {
      return emptyOpts
    }
    if (typeof options !== 'object') {
      return looseOption
    }
    return options
  }
  parseOptions_1 = parseOptions
  return parseOptions_1
}

let identifiers
let hasRequiredIdentifiers
function requireIdentifiers() {
  if (hasRequiredIdentifiers) {
    return identifiers
  }
  hasRequiredIdentifiers = 1
  const numeric = /^[0-9]+$/
  const compareIdentifiers = (a, b) => {
    const anum = numeric.test(a)
    const bnum = numeric.test(b)
    if (anum && bnum) {
      a = +a
      b = +b
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1
  }
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  }
  return identifiers
}

let semver
let hasRequiredSemver
function requireSemver() {
  if (hasRequiredSemver) {
    return semver
  }
  hasRequiredSemver = 1
  const debug = requireDebug()
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants()
  const { safeRe: re, t } = requireRe()
  const parseOptions = requireParseOptions()
  const { compareIdentifiers } = requireIdentifiers()
  class SemVer {
    constructor(version, options) {
      options = parseOptions(options)
      if (version instanceof SemVer) {
        if (
          version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease
        ) {
          return version
        } else {
          version = version.version
        }
      } else if (typeof version !== 'string') {
        throw new TypeError(
          `Invalid version. Must be a string. Got type "${typeof version}".`
        )
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`)
      }
      debug('SemVer', version, options)
      this.options = options
      this.loose = !!options.loose
      // this isn't actually relevant for versions, but keep it so that we
      // don't run into trouble passing this.options around.
      this.includePrerelease = !!options.includePrerelease
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`)
      }
      this.raw = version

      // these are actually numbers
      this.major = +m[1]
      this.minor = +m[2]
      this.patch = +m[3]
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version')
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version')
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version')
      }

      // numberify any prerelease numeric ids
      if (!m[4]) {
        this.prerelease = []
      } else {
        this.prerelease = m[4].split('.').map(id => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num
            }
          }
          return id
        })
      }
      this.build = m[5] ? m[5].split('.') : []
      this.format()
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join('.')}`
      }
      return this.version
    }
    toString() {
      return this.version
    }
    compare(other) {
      debug('SemVer.compare', this.version, this.options, other)
      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0
        }
        other = new SemVer(other, this.options)
      }
      if (other.version === this.version) {
        return 0
      }
      return this.compareMain(other) || this.comparePre(other)
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options)
      }
      return (
        compareIdentifiers(this.major, other.major) ||
        compareIdentifiers(this.minor, other.minor) ||
        compareIdentifiers(this.patch, other.patch)
      )
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options)
      }

      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length) {
        return -1
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0
      }
      let i = 0
      do {
        const a = this.prerelease[i]
        const b = other.prerelease[i]
        debug('prerelease compare', i, a, b)
        if (a === undefined && b === undefined) {
          return 0
        } else if (b === undefined) {
          return 1
        } else if (a === undefined) {
          return -1
        } else if (a === b) {
          continue
        } else {
          return compareIdentifiers(a, b)
        }
      } while (++i)
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options)
      }
      let i = 0
      do {
        const a = this.build[i]
        const b = other.build[i]
        debug('build compare', i, a, b)
        if (a === undefined && b === undefined) {
          return 0
        } else if (b === undefined) {
          return 1
        } else if (a === undefined) {
          return -1
        } else if (a === b) {
          continue
        } else {
          return compareIdentifiers(a, b)
        }
      } while (++i)
    }

    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith('pre')) {
        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }
        // Avoid an invalid semver results
        if (identifier) {
          const match = `-${identifier}`.match(
            this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]
          )
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`)
          }
        }
      }
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0
          this.patch = 0
          this.minor = 0
          this.major++
          this.inc('pre', identifier, identifierBase)
          break
        case 'preminor':
          this.prerelease.length = 0
          this.patch = 0
          this.minor++
          this.inc('pre', identifier, identifierBase)
          break
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0
          this.inc('patch', identifier, identifierBase)
          this.inc('pre', identifier, identifierBase)
          break
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier, identifierBase)
          }
          this.inc('pre', identifier, identifierBase)
          break
        case 'release':
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`)
          }
          this.prerelease.length = 0
          break
        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (
            this.minor !== 0 ||
            this.patch !== 0 ||
            this.prerelease.length === 0
          ) {
            this.major++
          }
          this.minor = 0
          this.patch = 0
          this.prerelease = []
          break
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++
          }
          this.patch = 0
          this.prerelease = []
          break
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0) {
            this.patch++
          }
          this.prerelease = []
          break
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case 'pre': {
          const base = Number(identifierBase) ? 1 : 0
          if (this.prerelease.length === 0) {
            this.prerelease = [base]
          } else {
            let i = this.prerelease.length
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++
                i = -2
              }
            }
            if (i === -1) {
              // didn't increment anything
              if (
                identifier === this.prerelease.join('.') &&
                identifierBase === false
              ) {
                throw new Error(
                  'invalid increment argument: identifier already exists'
                )
              }
              this.prerelease.push(base)
            }
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            let prerelease = [identifier, base]
            if (identifierBase === false) {
              prerelease = [identifier]
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease
              }
            } else {
              this.prerelease = prerelease
            }
          }
          break
        }
        default:
          throw new Error(`invalid increment argument: ${release}`)
      }
      this.raw = this.format()
      if (this.build.length) {
        this.raw += `+${this.build.join('.')}`
      }
      return this
    }
  }
  semver = SemVer
  return semver
}

let parse_1
let hasRequiredParse$2
function requireParse$2() {
  if (hasRequiredParse$2) {
    return parse_1
  }
  hasRequiredParse$2 = 1
  const SemVer = requireSemver()
  const parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version
    }
    try {
      return new SemVer(version, options)
    } catch (er) {
      if (!throwErrors) {
        return null
      }
      throw er
    }
  }
  parse_1 = parse
  return parse_1
}

let valid_1
let hasRequiredValid
function requireValid() {
  if (hasRequiredValid) {
    return valid_1
  }
  hasRequiredValid = 1
  const parse = requireParse$2()
  const valid = (version, options) => {
    const v = parse(version, options)
    return v ? v.version : null
  }
  valid_1 = valid
  return valid_1
}

let clean_1
let hasRequiredClean
function requireClean() {
  if (hasRequiredClean) {
    return clean_1
  }
  hasRequiredClean = 1
  const parse = requireParse$2()
  const clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ''), options)
    return s ? s.version : null
  }
  clean_1 = clean
  return clean_1
}

const require$$1$2 = [
  '0BSD',
  '3D-Slicer-1.0',
  'AAL',
  'ADSL',
  'AFL-1.1',
  'AFL-1.2',
  'AFL-2.0',
  'AFL-2.1',
  'AFL-3.0',
  'AGPL-1.0-only',
  'AGPL-1.0-or-later',
  'AGPL-3.0-only',
  'AGPL-3.0-or-later',
  'AMD-newlib',
  'AMDPLPA',
  'AML',
  'AML-glslang',
  'AMPAS',
  'ANTLR-PD',
  'ANTLR-PD-fallback',
  'APAFML',
  'APL-1.0',
  'APSL-1.0',
  'APSL-1.1',
  'APSL-1.2',
  'APSL-2.0',
  'ASWF-Digital-Assets-1.0',
  'ASWF-Digital-Assets-1.1',
  'Abstyles',
  'AdaCore-doc',
  'Adobe-2006',
  'Adobe-Display-PostScript',
  'Adobe-Glyph',
  'Adobe-Utopia',
  'Afmparse',
  'Aladdin',
  'Apache-1.0',
  'Apache-1.1',
  'Apache-2.0',
  'App-s2p',
  'Arphic-1999',
  'Artistic-1.0',
  'Artistic-1.0-Perl',
  'Artistic-1.0-cl8',
  'Artistic-2.0',
  'BSD-1-Clause',
  'BSD-2-Clause',
  'BSD-2-Clause-Darwin',
  'BSD-2-Clause-Patent',
  'BSD-2-Clause-Views',
  'BSD-2-Clause-first-lines',
  'BSD-3-Clause',
  'BSD-3-Clause-Attribution',
  'BSD-3-Clause-Clear',
  'BSD-3-Clause-HP',
  'BSD-3-Clause-LBNL',
  'BSD-3-Clause-Modification',
  'BSD-3-Clause-No-Military-License',
  'BSD-3-Clause-No-Nuclear-License',
  'BSD-3-Clause-No-Nuclear-License-2014',
  'BSD-3-Clause-No-Nuclear-Warranty',
  'BSD-3-Clause-Open-MPI',
  'BSD-3-Clause-Sun',
  'BSD-3-Clause-acpica',
  'BSD-3-Clause-flex',
  'BSD-4-Clause',
  'BSD-4-Clause-Shortened',
  'BSD-4-Clause-UC',
  'BSD-4.3RENO',
  'BSD-4.3TAHOE',
  'BSD-Advertising-Acknowledgement',
  'BSD-Attribution-HPND-disclaimer',
  'BSD-Inferno-Nettverk',
  'BSD-Protection',
  'BSD-Source-Code',
  'BSD-Source-beginning-file',
  'BSD-Systemics',
  'BSD-Systemics-W3Works',
  'BSL-1.0',
  'BUSL-1.1',
  'Baekmuk',
  'Bahyph',
  'Barr',
  'Beerware',
  'BitTorrent-1.0',
  'BitTorrent-1.1',
  'Bitstream-Charter',
  'Bitstream-Vera',
  'BlueOak-1.0.0',
  'Boehm-GC',
  'Boehm-GC-without-fee',
  'Borceux',
  'Brian-Gladman-2-Clause',
  'Brian-Gladman-3-Clause',
  'C-UDA-1.0',
  'CAL-1.0',
  'CAL-1.0-Combined-Work-Exception',
  'CATOSL-1.1',
  'CC-BY-1.0',
  'CC-BY-2.0',
  'CC-BY-2.5',
  'CC-BY-2.5-AU',
  'CC-BY-3.0',
  'CC-BY-3.0-AT',
  'CC-BY-3.0-AU',
  'CC-BY-3.0-DE',
  'CC-BY-3.0-IGO',
  'CC-BY-3.0-NL',
  'CC-BY-3.0-US',
  'CC-BY-4.0',
  'CC-BY-NC-1.0',
  'CC-BY-NC-2.0',
  'CC-BY-NC-2.5',
  'CC-BY-NC-3.0',
  'CC-BY-NC-3.0-DE',
  'CC-BY-NC-4.0',
  'CC-BY-NC-ND-1.0',
  'CC-BY-NC-ND-2.0',
  'CC-BY-NC-ND-2.5',
  'CC-BY-NC-ND-3.0',
  'CC-BY-NC-ND-3.0-DE',
  'CC-BY-NC-ND-3.0-IGO',
  'CC-BY-NC-ND-4.0',
  'CC-BY-NC-SA-1.0',
  'CC-BY-NC-SA-2.0',
  'CC-BY-NC-SA-2.0-DE',
  'CC-BY-NC-SA-2.0-FR',
  'CC-BY-NC-SA-2.0-UK',
  'CC-BY-NC-SA-2.5',
  'CC-BY-NC-SA-3.0',
  'CC-BY-NC-SA-3.0-DE',
  'CC-BY-NC-SA-3.0-IGO',
  'CC-BY-NC-SA-4.0',
  'CC-BY-ND-1.0',
  'CC-BY-ND-2.0',
  'CC-BY-ND-2.5',
  'CC-BY-ND-3.0',
  'CC-BY-ND-3.0-DE',
  'CC-BY-ND-4.0',
  'CC-BY-SA-1.0',
  'CC-BY-SA-2.0',
  'CC-BY-SA-2.0-UK',
  'CC-BY-SA-2.1-JP',
  'CC-BY-SA-2.5',
  'CC-BY-SA-3.0',
  'CC-BY-SA-3.0-AT',
  'CC-BY-SA-3.0-DE',
  'CC-BY-SA-3.0-IGO',
  'CC-BY-SA-4.0',
  'CC-PDDC',
  'CC-PDM-1.0',
  'CC-SA-1.0',
  'CC0-1.0',
  'CDDL-1.0',
  'CDDL-1.1',
  'CDL-1.0',
  'CDLA-Permissive-1.0',
  'CDLA-Permissive-2.0',
  'CDLA-Sharing-1.0',
  'CECILL-1.0',
  'CECILL-1.1',
  'CECILL-2.0',
  'CECILL-2.1',
  'CECILL-B',
  'CECILL-C',
  'CERN-OHL-1.1',
  'CERN-OHL-1.2',
  'CERN-OHL-P-2.0',
  'CERN-OHL-S-2.0',
  'CERN-OHL-W-2.0',
  'CFITSIO',
  'CMU-Mach',
  'CMU-Mach-nodoc',
  'CNRI-Jython',
  'CNRI-Python',
  'CNRI-Python-GPL-Compatible',
  'COIL-1.0',
  'CPAL-1.0',
  'CPL-1.0',
  'CPOL-1.02',
  'CUA-OPL-1.0',
  'Caldera',
  'Caldera-no-preamble',
  'Catharon',
  'ClArtistic',
  'Clips',
  'Community-Spec-1.0',
  'Condor-1.1',
  'Cornell-Lossless-JPEG',
  'Cronyx',
  'Crossword',
  'CrystalStacker',
  'Cube',
  'D-FSL-1.0',
  'DEC-3-Clause',
  'DL-DE-BY-2.0',
  'DL-DE-ZERO-2.0',
  'DOC',
  'DRL-1.0',
  'DRL-1.1',
  'DSDP',
  'DocBook-Schema',
  'DocBook-Stylesheet',
  'DocBook-XML',
  'Dotseqn',
  'ECL-1.0',
  'ECL-2.0',
  'EFL-1.0',
  'EFL-2.0',
  'EPICS',
  'EPL-1.0',
  'EPL-2.0',
  'EUDatagrid',
  'EUPL-1.0',
  'EUPL-1.1',
  'EUPL-1.2',
  'Elastic-2.0',
  'Entessa',
  'ErlPL-1.1',
  'Eurosym',
  'FBM',
  'FDK-AAC',
  'FSFAP',
  'FSFAP-no-warranty-disclaimer',
  'FSFUL',
  'FSFULLR',
  'FSFULLRWD',
  'FTL',
  'Fair',
  'Ferguson-Twofish',
  'Frameworx-1.0',
  'FreeBSD-DOC',
  'FreeImage',
  'Furuseth',
  'GCR-docs',
  'GD',
  'GFDL-1.1-invariants-only',
  'GFDL-1.1-invariants-or-later',
  'GFDL-1.1-no-invariants-only',
  'GFDL-1.1-no-invariants-or-later',
  'GFDL-1.1-only',
  'GFDL-1.1-or-later',
  'GFDL-1.2-invariants-only',
  'GFDL-1.2-invariants-or-later',
  'GFDL-1.2-no-invariants-only',
  'GFDL-1.2-no-invariants-or-later',
  'GFDL-1.2-only',
  'GFDL-1.2-or-later',
  'GFDL-1.3-invariants-only',
  'GFDL-1.3-invariants-or-later',
  'GFDL-1.3-no-invariants-only',
  'GFDL-1.3-no-invariants-or-later',
  'GFDL-1.3-only',
  'GFDL-1.3-or-later',
  'GL2PS',
  'GLWTPL',
  'GPL-1.0-only',
  'GPL-1.0-or-later',
  'GPL-2.0-only',
  'GPL-2.0-or-later',
  'GPL-3.0-only',
  'GPL-3.0-or-later',
  'Giftware',
  'Glide',
  'Glulxe',
  'Graphics-Gems',
  'Gutmann',
  'HIDAPI',
  'HP-1986',
  'HP-1989',
  'HPND',
  'HPND-DEC',
  'HPND-Fenneberg-Livingston',
  'HPND-INRIA-IMAG',
  'HPND-Intel',
  'HPND-Kevlin-Henney',
  'HPND-MIT-disclaimer',
  'HPND-Markus-Kuhn',
  'HPND-Netrek',
  'HPND-Pbmplus',
  'HPND-UC',
  'HPND-UC-export-US',
  'HPND-doc',
  'HPND-doc-sell',
  'HPND-export-US',
  'HPND-export-US-acknowledgement',
  'HPND-export-US-modify',
  'HPND-export2-US',
  'HPND-merchantability-variant',
  'HPND-sell-MIT-disclaimer-xserver',
  'HPND-sell-regexpr',
  'HPND-sell-variant',
  'HPND-sell-variant-MIT-disclaimer',
  'HPND-sell-variant-MIT-disclaimer-rev',
  'HTMLTIDY',
  'HaskellReport',
  'Hippocratic-2.1',
  'IBM-pibs',
  'ICU',
  'IEC-Code-Components-EULA',
  'IJG',
  'IJG-short',
  'IPA',
  'IPL-1.0',
  'ISC',
  'ISC-Veillard',
  'ImageMagick',
  'Imlib2',
  'Info-ZIP',
  'Inner-Net-2.0',
  'InnoSetup',
  'Intel',
  'Intel-ACPI',
  'Interbase-1.0',
  'JPL-image',
  'JPNIC',
  'JSON',
  'Jam',
  'JasPer-2.0',
  'Kastrup',
  'Kazlib',
  'Knuth-CTAN',
  'LAL-1.2',
  'LAL-1.3',
  'LGPL-2.0-only',
  'LGPL-2.0-or-later',
  'LGPL-2.1-only',
  'LGPL-2.1-or-later',
  'LGPL-3.0-only',
  'LGPL-3.0-or-later',
  'LGPLLR',
  'LOOP',
  'LPD-document',
  'LPL-1.0',
  'LPL-1.02',
  'LPPL-1.0',
  'LPPL-1.1',
  'LPPL-1.2',
  'LPPL-1.3a',
  'LPPL-1.3c',
  'LZMA-SDK-9.11-to-9.20',
  'LZMA-SDK-9.22',
  'Latex2e',
  'Latex2e-translated-notice',
  'Leptonica',
  'LiLiQ-P-1.1',
  'LiLiQ-R-1.1',
  'LiLiQ-Rplus-1.1',
  'Libpng',
  'Linux-OpenIB',
  'Linux-man-pages-1-para',
  'Linux-man-pages-copyleft',
  'Linux-man-pages-copyleft-2-para',
  'Linux-man-pages-copyleft-var',
  'Lucida-Bitmap-Fonts',
  'MIPS',
  'MIT',
  'MIT-0',
  'MIT-CMU',
  'MIT-Click',
  'MIT-Festival',
  'MIT-Khronos-old',
  'MIT-Modern-Variant',
  'MIT-Wu',
  'MIT-advertising',
  'MIT-enna',
  'MIT-feh',
  'MIT-open-group',
  'MIT-testregex',
  'MITNFA',
  'MMIXware',
  'MPEG-SSG',
  'MPL-1.0',
  'MPL-1.1',
  'MPL-2.0',
  'MPL-2.0-no-copyleft-exception',
  'MS-LPL',
  'MS-PL',
  'MS-RL',
  'MTLL',
  'Mackerras-3-Clause',
  'Mackerras-3-Clause-acknowledgment',
  'MakeIndex',
  'Martin-Birgmeier',
  'McPhee-slideshow',
  'Minpack',
  'MirOS',
  'Motosoto',
  'MulanPSL-1.0',
  'MulanPSL-2.0',
  'Multics',
  'Mup',
  'NAIST-2003',
  'NASA-1.3',
  'NBPL-1.0',
  'NCBI-PD',
  'NCGL-UK-2.0',
  'NCL',
  'NCSA',
  'NGPL',
  'NICTA-1.0',
  'NIST-PD',
  'NIST-PD-fallback',
  'NIST-Software',
  'NLOD-1.0',
  'NLOD-2.0',
  'NLPL',
  'NOSL',
  'NPL-1.0',
  'NPL-1.1',
  'NPOSL-3.0',
  'NRL',
  'NTP',
  'NTP-0',
  'Naumen',
  'NetCDF',
  'Newsletr',
  'Nokia',
  'Noweb',
  'O-UDA-1.0',
  'OAR',
  'OCCT-PL',
  'OCLC-2.0',
  'ODC-By-1.0',
  'ODbL-1.0',
  'OFFIS',
  'OFL-1.0',
  'OFL-1.0-RFN',
  'OFL-1.0-no-RFN',
  'OFL-1.1',
  'OFL-1.1-RFN',
  'OFL-1.1-no-RFN',
  'OGC-1.0',
  'OGDL-Taiwan-1.0',
  'OGL-Canada-2.0',
  'OGL-UK-1.0',
  'OGL-UK-2.0',
  'OGL-UK-3.0',
  'OGTSL',
  'OLDAP-1.1',
  'OLDAP-1.2',
  'OLDAP-1.3',
  'OLDAP-1.4',
  'OLDAP-2.0',
  'OLDAP-2.0.1',
  'OLDAP-2.1',
  'OLDAP-2.2',
  'OLDAP-2.2.1',
  'OLDAP-2.2.2',
  'OLDAP-2.3',
  'OLDAP-2.4',
  'OLDAP-2.5',
  'OLDAP-2.6',
  'OLDAP-2.7',
  'OLDAP-2.8',
  'OLFL-1.3',
  'OML',
  'OPL-1.0',
  'OPL-UK-3.0',
  'OPUBL-1.0',
  'OSET-PL-2.1',
  'OSL-1.0',
  'OSL-1.1',
  'OSL-2.0',
  'OSL-2.1',
  'OSL-3.0',
  'OpenPBS-2.3',
  'OpenSSL',
  'OpenSSL-standalone',
  'OpenVision',
  'PADL',
  'PDDL-1.0',
  'PHP-3.0',
  'PHP-3.01',
  'PPL',
  'PSF-2.0',
  'Parity-6.0.0',
  'Parity-7.0.0',
  'Pixar',
  'Plexus',
  'PolyForm-Noncommercial-1.0.0',
  'PolyForm-Small-Business-1.0.0',
  'PostgreSQL',
  'Python-2.0',
  'Python-2.0.1',
  'QPL-1.0',
  'QPL-1.0-INRIA-2004',
  'Qhull',
  'RHeCos-1.1',
  'RPL-1.1',
  'RPL-1.5',
  'RPSL-1.0',
  'RSA-MD',
  'RSCPL',
  'Rdisc',
  'Ruby',
  'Ruby-pty',
  'SAX-PD',
  'SAX-PD-2.0',
  'SCEA',
  'SGI-B-1.0',
  'SGI-B-1.1',
  'SGI-B-2.0',
  'SGI-OpenGL',
  'SGP4',
  'SHL-0.5',
  'SHL-0.51',
  'SISSL',
  'SISSL-1.2',
  'SL',
  'SMAIL-GPL',
  'SMLNJ',
  'SMPPL',
  'SNIA',
  'SPL-1.0',
  'SSH-OpenSSH',
  'SSH-short',
  'SSLeay-standalone',
  'SSPL-1.0',
  'SWL',
  'Saxpath',
  'SchemeReport',
  'Sendmail',
  'Sendmail-8.23',
  'Sendmail-Open-Source-1.1',
  'SimPL-2.0',
  'Sleepycat',
  'Soundex',
  'Spencer-86',
  'Spencer-94',
  'Spencer-99',
  'SugarCRM-1.1.3',
  'Sun-PPP',
  'Sun-PPP-2000',
  'SunPro',
  'Symlinks',
  'TAPR-OHL-1.0',
  'TCL',
  'TCP-wrappers',
  'TGPPL-1.0',
  'TMate',
  'TORQUE-1.1',
  'TOSL',
  'TPDL',
  'TPL-1.0',
  'TTWL',
  'TTYP0',
  'TU-Berlin-1.0',
  'TU-Berlin-2.0',
  'TermReadKey',
  'ThirdEye',
  'TrustedQSL',
  'UCAR',
  'UCL-1.0',
  'UMich-Merit',
  'UPL-1.0',
  'URT-RLE',
  'Ubuntu-font-1.0',
  'Unicode-3.0',
  'Unicode-DFS-2015',
  'Unicode-DFS-2016',
  'Unicode-TOU',
  'UnixCrypt',
  'Unlicense',
  'VOSTROM',
  'VSL-1.0',
  'Vim',
  'W3C',
  'W3C-19980720',
  'W3C-20150513',
  'WTFPL',
  'Watcom-1.0',
  'Widget-Workshop',
  'Wsuipa',
  'X11',
  'X11-distribute-modifications-variant',
  'X11-swapped',
  'XFree86-1.1',
  'XSkat',
  'Xdebug-1.03',
  'Xerox',
  'Xfig',
  'Xnet',
  'YPL-1.0',
  'YPL-1.1',
  'ZPL-1.1',
  'ZPL-2.0',
  'ZPL-2.1',
  'Zed',
  'Zeeff',
  'Zend-2.0',
  'Zimbra-1.3',
  'Zimbra-1.4',
  'Zlib',
  'any-OSI',
  'any-OSI-perl-modules',
  'bcrypt-Solar-Designer',
  'blessing',
  'bzip2-1.0.6',
  'check-cvs',
  'checkmk',
  'copyleft-next-0.3.0',
  'copyleft-next-0.3.1',
  'curl',
  'cve-tou',
  'diffmark',
  'dtoa',
  'dvipdfm',
  'eGenix',
  'etalab-2.0',
  'fwlw',
  'gSOAP-1.3b',
  'generic-xts',
  'gnuplot',
  'gtkbook',
  'hdparm',
  'iMatix',
  'libpng-2.0',
  'libselinux-1.0',
  'libtiff',
  'libutil-David-Nugent',
  'lsof',
  'magaz',
  'mailprio',
  'metamail',
  'mpi-permissive',
  'mpich2',
  'mplus',
  'pkgconf',
  'pnmstitch',
  'psfrag',
  'psutils',
  'python-ldap',
  'radvd',
  'snprintf',
  'softSurfer',
  'ssh-keyscan',
  'swrule',
  'threeparttable',
  'ulem',
  'w3m',
  'wwl',
  'xinetd',
  'xkeyboard-config-Zinoviev',
  'xlock',
  'xpp',
  'xzoom',
  'zlib-acknowledgement'
]

const require$$1$1 = [
  'AGPL-1.0',
  'AGPL-3.0',
  'BSD-2-Clause-FreeBSD',
  'BSD-2-Clause-NetBSD',
  'GFDL-1.1',
  'GFDL-1.2',
  'GFDL-1.3',
  'GPL-1.0',
  'GPL-2.0',
  'GPL-2.0-with-GCC-exception',
  'GPL-2.0-with-autoconf-exception',
  'GPL-2.0-with-bison-exception',
  'GPL-2.0-with-classpath-exception',
  'GPL-2.0-with-font-exception',
  'GPL-3.0',
  'GPL-3.0-with-GCC-exception',
  'GPL-3.0-with-autoconf-exception',
  'LGPL-2.0',
  'LGPL-2.1',
  'LGPL-3.0',
  'Net-SNMP',
  'Nunit',
  'StandardML-NJ',
  'bzip2-1.0.5',
  'eCos-2.0',
  'wxWindows'
]

const require$$2 = [
  '389-exception',
  'Asterisk-exception',
  'Autoconf-exception-2.0',
  'Autoconf-exception-3.0',
  'Autoconf-exception-generic',
  'Autoconf-exception-generic-3.0',
  'Autoconf-exception-macro',
  'Bison-exception-1.24',
  'Bison-exception-2.2',
  'Bootloader-exception',
  'Classpath-exception-2.0',
  'CLISP-exception-2.0',
  'cryptsetup-OpenSSL-exception',
  'DigiRule-FOSS-exception',
  'eCos-exception-2.0',
  'Fawkes-Runtime-exception',
  'FLTK-exception',
  'fmt-exception',
  'Font-exception-2.0',
  'freertos-exception-2.0',
  'GCC-exception-2.0',
  'GCC-exception-2.0-note',
  'GCC-exception-3.1',
  'Gmsh-exception',
  'GNAT-exception',
  'GNOME-examples-exception',
  'GNU-compiler-exception',
  'gnu-javamail-exception',
  'GPL-3.0-interface-exception',
  'GPL-3.0-linking-exception',
  'GPL-3.0-linking-source-exception',
  'GPL-CC-1.0',
  'GStreamer-exception-2005',
  'GStreamer-exception-2008',
  'i2p-gpl-java-exception',
  'KiCad-libraries-exception',
  'LGPL-3.0-linking-exception',
  'libpri-OpenH323-exception',
  'Libtool-exception',
  'Linux-syscall-note',
  'LLGPL',
  'LLVM-exception',
  'LZMA-exception',
  'mif-exception',
  'OCaml-LGPL-linking-exception',
  'OCCT-exception-1.0',
  'OpenJDK-assembly-exception-1.0',
  'openvpn-openssl-exception',
  'PS-or-PDF-font-exception-20170817',
  'QPL-1.0-INRIA-2004-exception',
  'Qt-GPL-exception-1.0',
  'Qt-LGPL-exception-1.1',
  'Qwt-exception-1.0',
  'SANE-exception',
  'SHL-2.0',
  'SHL-2.1',
  'stunnel-exception',
  'SWI-exception',
  'Swift-exception',
  'Texinfo-exception',
  'u-boot-exception-2.0',
  'UBDL-exception',
  'Universal-FOSS-exception-1.0',
  'vsftpd-openssl-exception',
  'WxWindows-exception-3.1',
  'x11vnc-openssl-exception'
]

let scan$1
let hasRequiredScan$1
function requireScan$1() {
  if (hasRequiredScan$1) {
    return scan$1
  }
  hasRequiredScan$1 = 1
  const licenses = [].concat(require$$1$2).concat(require$$1$1)
  const exceptions = require$$2
  scan$1 = function (source) {
    let index = 0
    function hasMore() {
      return index < source.length
    }

    // `value` can be a regexp or a string.
    // If it is recognized, the matching source string is returned and
    // the index is incremented. Otherwise `undefined` is returned.
    function read(value) {
      if (value instanceof RegExp) {
        const chars = source.slice(index)
        const match = chars.match(value)
        if (match) {
          index += match[0].length
          return match[0]
        }
      } else {
        if (source.indexOf(value, index) === index) {
          index += value.length
          return value
        }
      }
    }
    function skipWhitespace() {
      read(/[ ]*/)
    }
    function operator() {
      let string
      const possibilities = ['WITH', 'AND', 'OR', '(', ')', ':', '+']
      for (let i = 0; i < possibilities.length; i++) {
        string = read(possibilities[i])
        if (string) {
          break
        }
      }
      if (string === '+' && index > 1 && source[index - 2] === ' ') {
        throw new Error('Space before `+`')
      }
      return (
        string && {
          type: 'OPERATOR',
          string: string
        }
      )
    }
    function idstring() {
      return read(/[A-Za-z0-9-.]+/)
    }
    function expectIdstring() {
      const string = idstring()
      if (!string) {
        throw new Error('Expected idstring at offset ' + index)
      }
      return string
    }
    function documentRef() {
      if (read('DocumentRef-')) {
        const string = expectIdstring()
        return {
          type: 'DOCUMENTREF',
          string: string
        }
      }
    }
    function licenseRef() {
      if (read('LicenseRef-')) {
        const string = expectIdstring()
        return {
          type: 'LICENSEREF',
          string: string
        }
      }
    }
    function identifier() {
      const begin = index
      const string = idstring()
      if (licenses.indexOf(string) !== -1) {
        return {
          type: 'LICENSE',
          string: string
        }
      } else if (exceptions.indexOf(string) !== -1) {
        return {
          type: 'EXCEPTION',
          string: string
        }
      }
      index = begin
    }

    // Tries to read the next token. Returns `undefined` if no token is
    // recognized.
    function parseToken() {
      // Ordering matters
      return operator() || documentRef() || licenseRef() || identifier()
    }
    const tokens = []
    while (hasMore()) {
      skipWhitespace()
      if (!hasMore()) {
        break
      }
      const token = parseToken()
      if (!token) {
        throw new Error('Unexpected `' + source[index] + '` at offset ' + index)
      }
      tokens.push(token)
    }
    return tokens
  }
  return scan$1
}

let parse$1
let hasRequiredParse$1
function requireParse$1() {
  if (hasRequiredParse$1) {
    return parse$1
  }
  hasRequiredParse$1 = 1

  // The ABNF grammar in the spec is totally ambiguous.
  //
  // This parser follows the operator precedence defined in the
  // `Order of Precedence and Parentheses` section.

  parse$1 = function (tokens) {
    let index = 0
    function hasMore() {
      return index < tokens.length
    }
    function token() {
      return hasMore() ? tokens[index] : null
    }
    function next() {
      if (!hasMore()) {
        throw new Error()
      }
      index++
    }
    function parseOperator(operator) {
      const t = token()
      if (t && t.type === 'OPERATOR' && operator === t.string) {
        next()
        return t.string
      }
    }
    function parseWith() {
      if (parseOperator('WITH')) {
        const t = token()
        if (t && t.type === 'EXCEPTION') {
          next()
          return t.string
        }
        throw new Error('Expected exception after `WITH`')
      }
    }
    function parseLicenseRef() {
      // TODO: Actually, everything is concatenated into one string
      // for backward-compatibility but it could be better to return
      // a nice structure.
      const begin = index
      let string = ''
      let t = token()
      if (t.type === 'DOCUMENTREF') {
        next()
        string += 'DocumentRef-' + t.string + ':'
        if (!parseOperator(':')) {
          throw new Error('Expected `:` after `DocumentRef-...`')
        }
      }
      t = token()
      if (t.type === 'LICENSEREF') {
        next()
        string += 'LicenseRef-' + t.string
        return {
          license: string
        }
      }
      index = begin
    }
    function parseLicense() {
      const t = token()
      if (t && t.type === 'LICENSE') {
        next()
        const node = {
          license: t.string
        }
        if (parseOperator('+')) {
          node.plus = true
        }
        const exception = parseWith()
        if (exception) {
          node.exception = exception
        }
        return node
      }
    }
    function parseParenthesizedExpression() {
      const left = parseOperator('(')
      if (!left) {
        return
      }
      const expr = parseExpression()
      if (!parseOperator(')')) {
        throw new Error('Expected `)`')
      }
      return expr
    }
    function parseAtom() {
      return (
        parseParenthesizedExpression() || parseLicenseRef() || parseLicense()
      )
    }
    function makeBinaryOpParser(operator, nextParser) {
      return function parseBinaryOp() {
        const left = nextParser()
        if (!left) {
          return
        }
        if (!parseOperator(operator)) {
          return left
        }
        const right = parseBinaryOp()
        if (!right) {
          throw new Error('Expected expression')
        }
        return {
          left: left,
          conjunction: operator.toLowerCase(),
          right: right
        }
      }
    }
    const parseAnd = makeBinaryOpParser('AND', parseAtom)
    const parseExpression = makeBinaryOpParser('OR', parseAnd)
    const node = parseExpression()
    if (!node || hasMore()) {
      throw new Error('Syntax error')
    }
    return node
  }
  return parse$1
}

let spdxExpressionParse$1
let hasRequiredSpdxExpressionParse$1
function requireSpdxExpressionParse$1() {
  if (hasRequiredSpdxExpressionParse$1) {
    return spdxExpressionParse$1
  }
  hasRequiredSpdxExpressionParse$1 = 1
  const scan = requireScan$1()
  const parse = requireParse$1()
  spdxExpressionParse$1 = function (source) {
    return parse(scan(source))
  }
  return spdxExpressionParse$1
}

let scan
let hasRequiredScan
function requireScan() {
  if (hasRequiredScan) {
    return scan
  }
  hasRequiredScan = 1
  const licenses = [].concat(require$$1$2).concat(require$$1$1)
  const exceptions = require$$2
  scan = function (source) {
    let index = 0
    function hasMore() {
      return index < source.length
    }

    // `value` can be a regexp or a string.
    // If it is recognized, the matching source string is returned and
    // the index is incremented. Otherwise `undefined` is returned.
    function read(value) {
      if (value instanceof RegExp) {
        const chars = source.slice(index)
        const match = chars.match(value)
        if (match) {
          index += match[0].length
          return match[0]
        }
      } else {
        if (source.indexOf(value, index) === index) {
          index += value.length
          return value
        }
      }
    }
    function skipWhitespace() {
      read(/[ ]*/)
    }
    function operator() {
      let string
      const possibilities = ['WITH', 'AND', 'OR', '(', ')', ':', '+']
      for (let i = 0; i < possibilities.length; i++) {
        string = read(possibilities[i])
        if (string) {
          break
        }
      }
      if (string === '+' && index > 1 && source[index - 2] === ' ') {
        throw new Error('Space before `+`')
      }
      return (
        string && {
          type: 'OPERATOR',
          string: string
        }
      )
    }
    function idstring() {
      return read(/[A-Za-z0-9-.]+/)
    }
    function expectIdstring() {
      const string = idstring()
      if (!string) {
        throw new Error('Expected idstring at offset ' + index)
      }
      return string
    }
    function documentRef() {
      if (read('DocumentRef-')) {
        const string = expectIdstring()
        return {
          type: 'DOCUMENTREF',
          string: string
        }
      }
    }
    function licenseRef() {
      if (read('LicenseRef-')) {
        const string = expectIdstring()
        return {
          type: 'LICENSEREF',
          string: string
        }
      }
    }
    function identifier() {
      const begin = index
      const string = idstring()
      if (licenses.indexOf(string) !== -1) {
        return {
          type: 'LICENSE',
          string: string
        }
      } else if (exceptions.indexOf(string) !== -1) {
        return {
          type: 'EXCEPTION',
          string: string
        }
      }
      index = begin
    }

    // Tries to read the next token. Returns `undefined` if no token is
    // recognized.
    function parseToken() {
      // Ordering matters
      return operator() || documentRef() || licenseRef() || identifier()
    }
    const tokens = []
    while (hasMore()) {
      skipWhitespace()
      if (!hasMore()) {
        break
      }
      const token = parseToken()
      if (!token) {
        throw new Error('Unexpected `' + source[index] + '` at offset ' + index)
      }
      tokens.push(token)
    }
    return tokens
  }
  return scan
}

let parse
let hasRequiredParse
function requireParse() {
  if (hasRequiredParse) {
    return parse
  }
  hasRequiredParse = 1

  // The ABNF grammar in the spec is totally ambiguous.
  //
  // This parser follows the operator precedence defined in the
  // `Order of Precedence and Parentheses` section.

  parse = function (tokens) {
    let index = 0
    function hasMore() {
      return index < tokens.length
    }
    function token() {
      return hasMore() ? tokens[index] : null
    }
    function next() {
      if (!hasMore()) {
        throw new Error()
      }
      index++
    }
    function parseOperator(operator) {
      const t = token()
      if (t && t.type === 'OPERATOR' && operator === t.string) {
        next()
        return t.string
      }
    }
    function parseWith() {
      if (parseOperator('WITH')) {
        const t = token()
        if (t && t.type === 'EXCEPTION') {
          next()
          return t.string
        }
        throw new Error('Expected exception after `WITH`')
      }
    }
    function parseLicenseRef() {
      // TODO: Actually, everything is concatenated into one string
      // for backward-compatibility but it could be better to return
      // a nice structure.
      const begin = index
      let string = ''
      let t = token()
      if (t.type === 'DOCUMENTREF') {
        next()
        string += 'DocumentRef-' + t.string + ':'
        if (!parseOperator(':')) {
          throw new Error('Expected `:` after `DocumentRef-...`')
        }
      }
      t = token()
      if (t.type === 'LICENSEREF') {
        next()
        string += 'LicenseRef-' + t.string
        return {
          license: string
        }
      }
      index = begin
    }
    function parseLicense() {
      const t = token()
      if (t && t.type === 'LICENSE') {
        next()
        const node = {
          license: t.string
        }
        if (parseOperator('+')) {
          node.plus = true
        }
        const exception = parseWith()
        if (exception) {
          node.exception = exception
        }
        return node
      }
    }
    function parseParenthesizedExpression() {
      const left = parseOperator('(')
      if (!left) {
        return
      }
      const expr = parseExpression()
      if (!parseOperator(')')) {
        throw new Error('Expected `)`')
      }
      return expr
    }
    function parseAtom() {
      return (
        parseParenthesizedExpression() || parseLicenseRef() || parseLicense()
      )
    }
    function makeBinaryOpParser(operator, nextParser) {
      return function parseBinaryOp() {
        const left = nextParser()
        if (!left) {
          return
        }
        if (!parseOperator(operator)) {
          return left
        }
        const right = parseBinaryOp()
        if (!right) {
          throw new Error('Expected expression')
        }
        return {
          left: left,
          conjunction: operator.toLowerCase(),
          right: right
        }
      }
    }
    const parseAnd = makeBinaryOpParser('AND', parseAtom)
    const parseExpression = makeBinaryOpParser('OR', parseAnd)
    const node = parseExpression()
    if (!node || hasMore()) {
      throw new Error('Syntax error')
    }
    return node
  }
  return parse
}

let spdxExpressionParse
let hasRequiredSpdxExpressionParse
function requireSpdxExpressionParse() {
  if (hasRequiredSpdxExpressionParse) {
    return spdxExpressionParse
  }
  hasRequiredSpdxExpressionParse = 1
  const scan = requireScan()
  const parse = requireParse()
  spdxExpressionParse = function (source) {
    return parse(scan(source))
  }
  return spdxExpressionParse
}

/*
Copyright spdx-correct.js contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
let spdxCorrect
let hasRequiredSpdxCorrect
function requireSpdxCorrect() {
  if (hasRequiredSpdxCorrect) {
    return spdxCorrect
  }
  hasRequiredSpdxCorrect = 1
  const parse = requireSpdxExpressionParse()
  const spdxLicenseIds = require$$1$2
  function valid(string) {
    try {
      parse(string)
      return true
    } catch (error) {
      return false
    }
  }

  // Sorting function that orders the given array of transpositions such
  // that a transposition with the longer pattern comes before a transposition
  // with a shorter pattern. This is to prevent e.g. the transposition
  // ["General Public License", "GPL"] from matching to "Lesser General Public License"
  // before a longer and more accurate transposition ["Lesser General Public License", "LGPL"]
  // has a chance to be recognized.
  function sortTranspositions(a, b) {
    const length = b[0].length - a[0].length
    if (length !== 0) {
      return length
    }
    return a[0].toUpperCase().localeCompare(b[0].toUpperCase())
  }

  // Common transpositions of license identifier acronyms
  const transpositions = [
    ['APGL', 'AGPL'],
    ['Gpl', 'GPL'],
    ['GLP', 'GPL'],
    ['APL', 'Apache'],
    ['ISD', 'ISC'],
    ['GLP', 'GPL'],
    ['IST', 'ISC'],
    ['Claude', 'Clause'],
    [' or later', '+'],
    [' International', ''],
    ['GNU', 'GPL'],
    ['GUN', 'GPL'],
    ['+', ''],
    ['GNU GPL', 'GPL'],
    ['GNU LGPL', 'LGPL'],
    ['GNU/GPL', 'GPL'],
    ['GNU GLP', 'GPL'],
    ['GNU LESSER GENERAL PUBLIC LICENSE', 'LGPL'],
    ['GNU Lesser General Public License', 'LGPL'],
    ['GNU LESSER GENERAL PUBLIC LICENSE', 'LGPL-2.1'],
    ['GNU Lesser General Public License', 'LGPL-2.1'],
    ['LESSER GENERAL PUBLIC LICENSE', 'LGPL'],
    ['Lesser General Public License', 'LGPL'],
    ['LESSER GENERAL PUBLIC LICENSE', 'LGPL-2.1'],
    ['Lesser General Public License', 'LGPL-2.1'],
    ['GNU General Public License', 'GPL'],
    ['Gnu public license', 'GPL'],
    ['GNU Public License', 'GPL'],
    ['GNU GENERAL PUBLIC LICENSE', 'GPL'],
    ['MTI', 'MIT'],
    ['Mozilla Public License', 'MPL'],
    ['Universal Permissive License', 'UPL'],
    ['WTH', 'WTF'],
    ['WTFGPL', 'WTFPL'],
    ['-License', '']
  ].sort(sortTranspositions)
  const TRANSPOSED = 0
  const CORRECT = 1

  // Simple corrections to nearly valid identifiers.
  const transforms = [
    // e.g. 'mit'
    function (argument) {
      return argument.toUpperCase()
    },
    // e.g. 'MIT '
    function (argument) {
      return argument.trim()
    },
    // e.g. 'M.I.T.'
    function (argument) {
      return argument.replace(/\./g, '')
    },
    // e.g. 'Apache- 2.0'
    function (argument) {
      return argument.replace(/\s+/g, '')
    },
    // e.g. 'CC BY 4.0''
    function (argument) {
      return argument.replace(/\s+/g, '-')
    },
    // e.g. 'LGPLv2.1'
    function (argument) {
      return argument.replace('v', '-')
    },
    // e.g. 'Apache 2.0'
    function (argument) {
      return argument.replace(/,?\s*(\d)/, '-$1')
    },
    // e.g. 'GPL 2'
    function (argument) {
      return argument.replace(/,?\s*(\d)/, '-$1.0')
    },
    // e.g. 'Apache Version 2.0'
    function (argument) {
      return argument.replace(
        /,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/,
        '-$2'
      )
    },
    // e.g. 'Apache Version 2'
    function (argument) {
      return argument.replace(
        /,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/,
        '-$2.0'
      )
    },
    // e.g. 'ZLIB'
    function (argument) {
      return argument[0].toUpperCase() + argument.slice(1)
    },
    // e.g. 'MPL/2.0'
    function (argument) {
      return argument.replace('/', '-')
    },
    // e.g. 'Apache 2'
    function (argument) {
      return argument.replace(/\s*V\s*(\d)/, '-$1').replace(/(\d)$/, '$1.0')
    },
    // e.g. 'GPL-2.0', 'GPL-3.0'
    function (argument) {
      if (argument.indexOf('3.0') !== -1) {
        return argument + '-or-later'
      } else {
        return argument + '-only'
      }
    },
    // e.g. 'GPL-2.0-'
    function (argument) {
      return argument + 'only'
    },
    // e.g. 'GPL2'
    function (argument) {
      return argument.replace(/(\d)$/, '-$1.0')
    },
    // e.g. 'BSD 3'
    function (argument) {
      return argument.replace(/(-| )?(\d)$/, '-$2-Clause')
    },
    // e.g. 'BSD clause 3'
    function (argument) {
      return argument.replace(/(-| )clause(-| )(\d)/, '-$3-Clause')
    },
    // e.g. 'New BSD license'
    function (argument) {
      return argument.replace(
        /\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i,
        'BSD-3-Clause'
      )
    },
    // e.g. 'Simplified BSD license'
    function (argument) {
      return argument.replace(
        /\bSimplified(-| )?BSD((-| )License)?/i,
        'BSD-2-Clause'
      )
    },
    // e.g. 'Free BSD license'
    function (argument) {
      return argument.replace(
        /\b(Free|Net)(-| )?BSD((-| )License)?/i,
        'BSD-2-Clause-$1BSD'
      )
    },
    // e.g. 'Clear BSD license'
    function (argument) {
      return argument.replace(
        /\bClear(-| )?BSD((-| )License)?/i,
        'BSD-3-Clause-Clear'
      )
    },
    // e.g. 'Old BSD License'
    function (argument) {
      return argument.replace(
        /\b(Old|Original)(-| )?BSD((-| )License)?/i,
        'BSD-4-Clause'
      )
    },
    // e.g. 'BY-NC-4.0'
    function (argument) {
      return 'CC-' + argument
    },
    // e.g. 'BY-NC'
    function (argument) {
      return 'CC-' + argument + '-4.0'
    },
    // e.g. 'Attribution-NonCommercial'
    function (argument) {
      return argument
        .replace('Attribution', 'BY')
        .replace('NonCommercial', 'NC')
        .replace('NoDerivatives', 'ND')
        .replace(/ (\d)/, '-$1')
        .replace(/ ?International/, '')
    },
    // e.g. 'Attribution-NonCommercial'
    function (argument) {
      return (
        'CC-' +
        argument
          .replace('Attribution', 'BY')
          .replace('NonCommercial', 'NC')
          .replace('NoDerivatives', 'ND')
          .replace(/ (\d)/, '-$1')
          .replace(/ ?International/, '') +
        '-4.0'
      )
    }
  ]
  let licensesWithVersions = spdxLicenseIds
    .map(function (id) {
      const match = /^(.*)-\d+\.\d+$/.exec(id)
      return match ? [match[0], match[1]] : [id, null]
    })
    .reduce(function (objectMap, item) {
      const key = item[1]
      objectMap[key] = objectMap[key] || []
      objectMap[key].push(item[0])
      return objectMap
    }, {})
  const licensesWithOneVersion = Object.keys(licensesWithVersions)
    .map(function makeEntries(key) {
      return [key, licensesWithVersions[key]]
    })
    .filter(function identifySoleVersions(item) {
      return (
        // Licenses has just one valid version suffix.
        item[1].length === 1 &&
        item[0] !== null &&
        // APL will be considered Apache, rather than APL-1.0
        item[0] !== 'APL'
      )
    })
    .map(function createLastResorts(item) {
      return [item[0], item[1][0]]
    })
  licensesWithVersions = undefined

  // If all else fails, guess that strings containing certain substrings
  // meant to identify certain licenses.
  const lastResorts = [
    ['UNLI', 'Unlicense'],
    ['WTF', 'WTFPL'],
    ['2 CLAUSE', 'BSD-2-Clause'],
    ['2-CLAUSE', 'BSD-2-Clause'],
    ['3 CLAUSE', 'BSD-3-Clause'],
    ['3-CLAUSE', 'BSD-3-Clause'],
    ['AFFERO', 'AGPL-3.0-or-later'],
    ['AGPL', 'AGPL-3.0-or-later'],
    ['APACHE', 'Apache-2.0'],
    ['ARTISTIC', 'Artistic-2.0'],
    ['Affero', 'AGPL-3.0-or-later'],
    ['BEER', 'Beerware'],
    ['BOOST', 'BSL-1.0'],
    ['BSD', 'BSD-2-Clause'],
    ['CDDL', 'CDDL-1.1'],
    ['ECLIPSE', 'EPL-1.0'],
    ['FUCK', 'WTFPL'],
    ['GNU', 'GPL-3.0-or-later'],
    ['LGPL', 'LGPL-3.0-or-later'],
    ['GPLV1', 'GPL-1.0-only'],
    ['GPL-1', 'GPL-1.0-only'],
    ['GPLV2', 'GPL-2.0-only'],
    ['GPL-2', 'GPL-2.0-only'],
    ['GPL', 'GPL-3.0-or-later'],
    ['MIT +NO-FALSE-ATTRIBS', 'MITNFA'],
    ['MIT', 'MIT'],
    ['MPL', 'MPL-2.0'],
    ['X11', 'X11'],
    ['ZLIB', 'Zlib']
  ]
    .concat(licensesWithOneVersion)
    .sort(sortTranspositions)
  const SUBSTRING = 0
  const IDENTIFIER = 1
  const validTransformation = function (identifier) {
    for (let i = 0; i < transforms.length; i++) {
      const transformed = transforms[i](identifier).trim()
      if (transformed !== identifier && valid(transformed)) {
        return transformed
      }
    }
    return null
  }
  const validLastResort = function (identifier) {
    const upperCased = identifier.toUpperCase()
    for (let i = 0; i < lastResorts.length; i++) {
      const lastResort = lastResorts[i]
      if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
        return lastResort[IDENTIFIER]
      }
    }
    return null
  }
  const anyCorrection = function (identifier, check) {
    for (let i = 0; i < transpositions.length; i++) {
      const transposition = transpositions[i]
      const transposed = transposition[TRANSPOSED]
      if (identifier.indexOf(transposed) > -1) {
        const corrected = identifier.replace(transposed, transposition[CORRECT])
        const checked = check(corrected)
        if (checked !== null) {
          return checked
        }
      }
    }
    return null
  }
  spdxCorrect = function (identifier, options) {
    options = options || {}
    const upgrade = options.upgrade === undefined ? true : !!options.upgrade
    function postprocess(value) {
      return upgrade ? upgradeGPLs(value) : value
    }
    const validArugment =
      typeof identifier === 'string' && identifier.trim().length !== 0
    if (!validArugment) {
      throw Error('Invalid argument. Expected non-empty string.')
    }
    identifier = identifier.trim()
    if (valid(identifier)) {
      return postprocess(identifier)
    }
    const noPlus = identifier.replace(/\+$/, '').trim()
    if (valid(noPlus)) {
      return postprocess(noPlus)
    }
    let transformed = validTransformation(identifier)
    if (transformed !== null) {
      return postprocess(transformed)
    }
    transformed = anyCorrection(identifier, function (argument) {
      if (valid(argument)) {
        return argument
      }
      return validTransformation(argument)
    })
    if (transformed !== null) {
      return postprocess(transformed)
    }
    transformed = validLastResort(identifier)
    if (transformed !== null) {
      return postprocess(transformed)
    }
    transformed = anyCorrection(identifier, validLastResort)
    if (transformed !== null) {
      return postprocess(transformed)
    }
    return null
  }
  function upgradeGPLs(value) {
    if (
      [
        'GPL-1.0',
        'LGPL-1.0',
        'AGPL-1.0',
        'GPL-2.0',
        'LGPL-2.0',
        'AGPL-2.0',
        'LGPL-2.1'
      ].indexOf(value) !== -1
    ) {
      return value + '-only'
    } else if (
      [
        'GPL-1.0+',
        'GPL-2.0+',
        'GPL-3.0+',
        'LGPL-2.0+',
        'LGPL-2.1+',
        'LGPL-3.0+',
        'AGPL-1.0+',
        'AGPL-3.0+'
      ].indexOf(value) !== -1
    ) {
      return value.replace(/\+$/, '-or-later')
    } else if (['GPL-3.0', 'LGPL-3.0', 'AGPL-3.0'].indexOf(value) !== -1) {
      return value + '-or-later'
    } else {
      return value
    }
  }
  return spdxCorrect
}

let validateNpmPackageLicense
let hasRequiredValidateNpmPackageLicense
function requireValidateNpmPackageLicense() {
  if (hasRequiredValidateNpmPackageLicense) {
    return validateNpmPackageLicense
  }
  hasRequiredValidateNpmPackageLicense = 1
  const parse = requireSpdxExpressionParse$1()
  const correct = requireSpdxCorrect()
  const genericWarning =
    'license should be ' +
    'a valid SPDX license expression (without "LicenseRef"), ' +
    '"UNLICENSED", or ' +
    '"SEE LICENSE IN <filename>"'
  const fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/
  function startsWith(prefix, string) {
    return string.slice(0, prefix.length) === prefix
  }
  function usesLicenseRef(ast) {
    if (ast.hasOwnProperty('license')) {
      const license = ast.license
      return (
        startsWith('LicenseRef', license) || startsWith('DocumentRef', license)
      )
    } else {
      return usesLicenseRef(ast.left) || usesLicenseRef(ast.right)
    }
  }
  validateNpmPackageLicense = function (argument) {
    let ast
    try {
      ast = parse(argument)
    } catch (e) {
      let match
      if (argument === 'UNLICENSED' || argument === 'UNLICENCED') {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          unlicensed: true
        }
      } else if ((match = fileReferenceRE.exec(argument))) {
        return {
          validForOldPackages: true,
          validForNewPackages: true,
          inFile: match[1]
        }
      } else {
        const result = {
          validForOldPackages: false,
          validForNewPackages: false,
          warnings: [genericWarning]
        }
        if (argument.trim().length !== 0) {
          const corrected = correct(argument)
          if (corrected) {
            result.warnings.push(
              'license is similar to the valid expression "' + corrected + '"'
            )
          }
        }
        return result
      }
    }
    if (usesLicenseRef(ast)) {
      return {
        validForNewPackages: false,
        validForOldPackages: false,
        spdx: true,
        warnings: [genericWarning]
      }
    } else {
      return {
        validForNewPackages: true,
        validForOldPackages: true,
        spdx: true
      }
    }
  }
  return validateNpmPackageLicense
}

const commonjs = {}

let hasRequiredCommonjs
function requireCommonjs() {
  if (hasRequiredCommonjs) {
    return commonjs
  }
  hasRequiredCommonjs = 1
  /**
   * @module LRUCache
   */
  Object.defineProperty(commonjs, '__esModule', {
    value: true
  })
  commonjs.LRUCache = void 0
  const perf =
    typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
      ? performance
      : Date
  const warned = new Set()
  /* c8 ignore start */
  const PROCESS = typeof process === 'object' && !!process ? process : {}
  /* c8 ignore start */
  const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
      ? PROCESS.emitWarning(msg, type, code, fn)
      : console.error(`[${code}] ${type}: ${msg}`)
  }
  let AC = globalThis.AbortController
  let AS = globalThis.AbortSignal
  /* c8 ignore start */
  if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
      onabort
      _onabort = []
      reason
      aborted = false
      addEventListener(_, fn) {
        this._onabort.push(fn)
      }
    }
    //@ts-ignore
    AC = class AbortController {
      constructor() {
        warnACPolyfill()
      }
      signal = new AS()
      abort(reason) {
        if (this.signal.aborted) {
          return
        }
        //@ts-ignore
        this.signal.reason = reason
        //@ts-ignore
        this.signal.aborted = true
        //@ts-ignore
        for (const fn of this.signal._onabort) {
          fn(reason)
        }
        this.signal.onabort?.(reason)
      }
    }
    let printACPolyfillWarning =
      PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning) {
        return
      }
      printACPolyfillWarning = false
      emitWarning(
        'AbortController is not defined. If using lru-cache in ' +
          'node 14, load an AbortController polyfill from the ' +
          '`node-abort-controller` package. A minimal polyfill is ' +
          'provided for use by LRUCache.fetch(), but it should not be ' +
          'relied upon in other contexts (eg, passing it to other APIs that ' +
          'use AbortController/AbortSignal might have undesirable effects). ' +
          'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',
        'NO_ABORT_CONTROLLER',
        'ENOTSUP',
        warnACPolyfill
      )
    }
  }
  /* c8 ignore stop */
  const shouldWarn = code => !warned.has(code)
  const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)
  /* c8 ignore start */
  // This is a little bit ridiculous, tbh.
  // The maximum array length is 2^32-1 or thereabouts on most JS impls.
  // And well before that point, you're caching the entire world, I mean,
  // that's ~32GB of just integers for the next/prev links, plus whatever
  // else to hold that many keys and values.  Just filling the memory with
  // zeroes at init time is brutal when you get that big.
  // But why not be complete?
  // Maybe in the future, these limits will have expanded.
  const getUintArray = max =>
    !isPosInt(max)
      ? null
      : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
          ? Uint16Array
          : max <= Math.pow(2, 32)
            ? Uint32Array
            : max <= Number.MAX_SAFE_INTEGER
              ? ZeroArray
              : null
  /* c8 ignore stop */
  class ZeroArray extends Array {
    constructor(size) {
      super(size)
      this.fill(0)
    }
  }
  class Stack {
    heap
    length
    // private constructor
    static #constructing = false
    static create(max) {
      const HeapCls = getUintArray(max)
      if (!HeapCls) {
        return []
      }
      Stack.#constructing = true
      const s = new Stack(max, HeapCls)
      Stack.#constructing = false
      return s
    }
    constructor(max, HeapCls) {
      /* c8 ignore start */
      if (!Stack.#constructing) {
        throw new TypeError('instantiate Stack using Stack.create(n)')
      }
      /* c8 ignore stop */
      this.heap = new HeapCls(max)
      this.length = 0
    }
    push(n) {
      this.heap[this.length++] = n
    }
    pop() {
      return this.heap[--this.length]
    }
  }
  /**
   * Default export, the thing you're using this module to get.
   *
   * The `K` and `V` types define the key and value types, respectively. The
   * optional `FC` type defines the type of the `context` object passed to
   * `cache.fetch()` and `cache.memo()`.
   *
   * Keys and values **must not** be `null` or `undefined`.
   *
   * All properties from the options object (with the exception of `max`,
   * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
   * added as normal public members. (The listed options are read-only getters.)
   *
   * Changing any of these will alter the defaults for subsequent method calls.
   */
  class LRUCache {
    // options that cannot be changed without disaster
    #max
    #maxSize
    #dispose
    #disposeAfter
    #fetchMethod
    #memoMethod
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort
    // computed properties
    #size
    #calculatedSize
    #keyMap
    #keyList
    #valList
    #next
    #prev
    #head
    #tail
    #free
    #disposed
    #sizes
    #starts
    #ttls
    #hasDispose
    #hasFetchMethod
    #hasDisposeAfter
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head
        },
        get tail() {
          return c.#tail
        },
        free: c.#free,
        // methods
        isBackgroundFetch: p => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context) =>
          c.#backgroundFetch(k, index, options, context),
        moveToTail: index => c.#moveToTail(index),
        indexes: options => c.#indexes(options),
        rindexes: options => c.#rindexes(options),
        isStale: index => c.#isStale(index)
      }
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return this.#max
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return this.#maxSize
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return this.#calculatedSize
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return this.#size
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return this.#fetchMethod
    }
    get memoMethod() {
      return this.#memoMethod
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return this.#dispose
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return this.#disposeAfter
    }
    constructor(options) {
      const {
        max = 0,
        ttl,
        ttlResolution = 1,
        ttlAutopurge,
        updateAgeOnGet,
        updateAgeOnHas,
        allowStale,
        dispose,
        disposeAfter,
        noDisposeOnSet,
        noUpdateTTL,
        maxSize = 0,
        maxEntrySize = 0,
        sizeCalculation,
        fetchMethod,
        memoMethod,
        noDeleteOnFetchRejection,
        noDeleteOnStaleGet,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort
      } = options
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError('max option must be a nonnegative integer')
      }
      const UintArray = max ? getUintArray(max) : Array
      if (!UintArray) {
        throw new Error('invalid max value: ' + max)
      }
      this.#max = max
      this.#maxSize = maxSize
      this.maxEntrySize = maxEntrySize || this.#maxSize
      this.sizeCalculation = sizeCalculation
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError(
            'cannot set sizeCalculation without setting maxSize or maxEntrySize'
          )
        }
        if (typeof this.sizeCalculation !== 'function') {
          throw new TypeError('sizeCalculation set to non-function')
        }
      }
      if (memoMethod !== undefined && typeof memoMethod !== 'function') {
        throw new TypeError('memoMethod must be a function if defined')
      }
      this.#memoMethod = memoMethod
      if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
        throw new TypeError('fetchMethod must be a function if specified')
      }
      this.#fetchMethod = fetchMethod
      this.#hasFetchMethod = !!fetchMethod
      this.#keyMap = new Map()
      this.#keyList = new Array(max).fill(undefined)
      this.#valList = new Array(max).fill(undefined)
      this.#next = new UintArray(max)
      this.#prev = new UintArray(max)
      this.#head = 0
      this.#tail = 0
      this.#free = Stack.create(max)
      this.#size = 0
      this.#calculatedSize = 0
      if (typeof dispose === 'function') {
        this.#dispose = dispose
      }
      if (typeof disposeAfter === 'function') {
        this.#disposeAfter = disposeAfter
        this.#disposed = []
      } else {
        this.#disposeAfter = undefined
        this.#disposed = undefined
      }
      this.#hasDispose = !!this.#dispose
      this.#hasDisposeAfter = !!this.#disposeAfter
      this.noDisposeOnSet = !!noDisposeOnSet
      this.noUpdateTTL = !!noUpdateTTL
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort
      this.ignoreFetchAbort = !!ignoreFetchAbort
      // NB: maxEntrySize is set to maxSize if it's set
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError(
              'maxSize must be a positive integer if specified'
            )
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError(
            'maxEntrySize must be a positive integer if specified'
          )
        }
        this.#initializeSizeTracking()
      }
      this.allowStale = !!allowStale
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet
      this.updateAgeOnGet = !!updateAgeOnGet
      this.updateAgeOnHas = !!updateAgeOnHas
      this.ttlResolution =
        isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1
      this.ttlAutopurge = !!ttlAutopurge
      this.ttl = ttl || 0
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError('ttl must be a positive integer if specified')
        }
        this.#initializeTTLTracking()
      }
      // do not allow completely unbounded caches
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError('At least one of max, maxSize, or ttl is required')
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = 'LRU_CACHE_UNBOUNDED'
        if (shouldWarn(code)) {
          warned.add(code)
          const msg =
            'TTL caching without ttlAutopurge, max, or maxSize can ' +
            'result in unbounded memory consumption.'
          emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
        }
      }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max)
      const starts = new ZeroArray(this.#max)
      this.#ttls = ttls
      this.#starts = starts
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0
        ttls[index] = ttl
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], 'expire')
            }
          }, ttl + 1)
          // unref() not supported on all platforms
          /* c8 ignore start */
          if (t.unref) {
            t.unref()
          }
          /* c8 ignore stop */
        }
      }
      this.#updateItemAge = index => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0
      }
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index]
          const start = starts[index]
          /* c8 ignore next */
          if (!ttl || !start) {
            return
          }
          status.ttl = ttl
          status.start = start
          status.now = cachedNow || getNow()
          const age = status.now - start
          status.remainingTTL = ttl - age
        }
      }
      // debounce calls to perf.now() to 1s so we're not hitting
      // that costly call repeatedly.
      let cachedNow = 0
      const getNow = () => {
        const n = perf.now()
        if (this.ttlResolution > 0) {
          cachedNow = n
          const t = setTimeout(() => (cachedNow = 0), this.ttlResolution)
          // not available on all platforms
          /* c8 ignore start */
          if (t.unref) {
            t.unref()
          }
          /* c8 ignore stop */
        }
        return n
      }
      this.getRemainingTTL = key => {
        const index = this.#keyMap.get(key)
        if (index === undefined) {
          return 0
        }
        const ttl = ttls[index]
        const start = starts[index]
        if (!ttl || !start) {
          return Infinity
        }
        const age = (cachedNow || getNow()) - start
        return ttl - age
      }
      this.#isStale = index => {
        const s = starts[index]
        const t = ttls[index]
        return !!t && !!s && (cachedNow || getNow()) - s > t
      }
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => {}
    #statusTTL = () => {}
    #setItemTTL = () => {}
    /* c8 ignore stop */
    #isStale = () => false
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max)
      this.#calculatedSize = 0
      this.#sizes = sizes
      this.#removeItemSize = index => {
        this.#calculatedSize -= sizes[index]
        sizes[index] = 0
      }
      this.#requireSize = (k, v, size, sizeCalculation) => {
        // provisionally accept background fetches.
        // actual value size will be checked when they return.
        if (this.#isBackgroundFetch(v)) {
          return 0
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== 'function') {
              throw new TypeError('sizeCalculation must be a function')
            }
            size = sizeCalculation(v, k)
            if (!isPosInt(size)) {
              throw new TypeError(
                'sizeCalculation return invalid (expect positive integer)'
              )
            }
          } else {
            throw new TypeError(
              'invalid size value (must be positive integer). ' +
                'When maxSize or maxEntrySize is used, sizeCalculation ' +
                'or size must be set.'
            )
          }
        }
        return size
      }
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index]
          while (this.#calculatedSize > maxSize) {
            this.#evict(true)
          }
        }
        this.#calculatedSize += sizes[index]
        if (status) {
          status.entrySize = size
          status.totalCalculatedSize = this.#calculatedSize
        }
      }
    }
    #removeItemSize = _i => {}
    #addItemSize = (_i, _s, _st) => {}
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError(
          'cannot set size without setting maxSize or maxEntrySize on cache'
        )
      }
      return 0
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail; true; ) {
          if (!this.#isValidIndex(i)) {
            break
          }
          if (allowStale || !this.#isStale(i)) {
            yield i
          }
          if (i === this.#head) {
            break
          } else {
            i = this.#prev[i]
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head; true; ) {
          if (!this.#isValidIndex(i)) {
            break
          }
          if (allowStale || !this.#isStale(i)) {
            yield i
          }
          if (i === this.#tail) {
            break
          } else {
            i = this.#next[i]
          }
        }
      }
    }
    #isValidIndex(index) {
      return (
        index !== undefined && this.#keyMap.get(this.#keyList[index]) === index
      )
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of this.#indexes()) {
        if (
          this.#valList[i] !== undefined &&
          this.#keyList[i] !== undefined &&
          !this.#isBackgroundFetch(this.#valList[i])
        ) {
          yield [this.#keyList[i], this.#valList[i]]
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of this.#rindexes()) {
        if (
          this.#valList[i] !== undefined &&
          this.#keyList[i] !== undefined &&
          !this.#isBackgroundFetch(this.#valList[i])
        ) {
          yield [this.#keyList[i], this.#valList[i]]
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i]
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i]
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i]
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i]
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i]
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i]
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
      return this.entries()
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache'
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined) {
          continue
        }
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions)
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined) {
          continue
        }
        fn.call(thisp, value, this.#keyList[i], this)
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined) {
          continue
        }
        fn.call(thisp, value, this.#keyList[i], this)
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false
      for (const i of this.#rindexes({
        allowStale: true
      })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], 'expire')
          deleted = true
        }
      }
      return deleted
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
      const i = this.#keyMap.get(key)
      if (i === undefined) {
        return undefined
      }
      const v = this.#valList[i]
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
      if (value === undefined) {
        return undefined
      }
      const entry = {
        value
      }
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i]
        const start = this.#starts[i]
        if (ttl && start) {
          const remain = ttl - (perf.now() - start)
          entry.ttl = remain
          entry.start = Date.now()
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i]
      }
      return entry
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRLUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
      const arr = []
      for (const i of this.#indexes({
        allowStale: true
      })) {
        const key = this.#keyList[i]
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined || key === undefined) {
          continue
        }
        const entry = {
          value
        }
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i]
          // always dump the start relative to a portable timestamp
          // it's ok for this to be a bit slow, it's a rare operation.
          const age = perf.now() - this.#starts[i]
          entry.start = Math.floor(Date.now() - age)
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i]
        }
        arr.unshift([key, entry])
      }
      return arr
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
      this.clear()
      for (const [key, entry] of arr) {
        if (entry.start) {
          // entry.start is a portable timestamp, but we may be using
          // node's performance.now(), so calculate the offset, so that
          // we get the intended remaining TTL, no matter how long it's
          // been on ice.
          //
          // it's ok for this to be a bit slow, it's a rare operation.
          const age = Date.now() - entry.start
          entry.start = perf.now() - age
        }
        this.set(key, entry.value, entry)
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
      if (v === undefined) {
        this.delete(k)
        return this
      }
      const {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        sizeCalculation = this.sizeCalculation,
        status
      } = setOptions
      let { noUpdateTTL = this.noUpdateTTL } = setOptions
      const size = this.#requireSize(
        k,
        v,
        setOptions.size || 0,
        sizeCalculation
      )
      // if the item doesn't fit, don't do anything
      // NB: maxEntrySize set to maxSize by default
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = 'miss'
          status.maxEntrySizeExceeded = true
        }
        // have to delete, in case something is there already.
        this.#delete(k, 'set')
        return this
      }
      let index = this.#size === 0 ? undefined : this.#keyMap.get(k)
      if (index === undefined) {
        // addition
        index =
          this.#size === 0
            ? this.#tail
            : this.#free.length !== 0
              ? this.#free.pop()
              : this.#size === this.#max
                ? this.#evict(false)
                : this.#size
        this.#keyList[index] = k
        this.#valList[index] = v
        this.#keyMap.set(k, index)
        this.#next[this.#tail] = index
        this.#prev[index] = this.#tail
        this.#tail = index
        this.#size++
        this.#addItemSize(index, size, status)
        if (status) {
          status.set = 'add'
        }
        noUpdateTTL = false
      } else {
        // update
        this.#moveToTail(index)
        const oldVal = this.#valList[index]
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error('replaced'))
            const { __staleWhileFetching: s } = oldVal
            if (s !== undefined && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s, k, 'set')
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s, k, 'set'])
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, 'set')
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, 'set'])
            }
          }
          this.#removeItemSize(index)
          this.#addItemSize(index, size, status)
          this.#valList[index] = v
          if (status) {
            status.set = 'replace'
            const oldValue =
              oldVal && this.#isBackgroundFetch(oldVal)
                ? oldVal.__staleWhileFetching
                : oldVal
            if (oldValue !== undefined) {
              status.oldValue = oldValue
            }
          }
        } else if (status) {
          status.set = 'update'
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking()
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start)
        }
        if (status) {
          this.#statusTTL(status, index)
        }
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed
        let task
        while ((task = dt?.shift())) {
          this.#disposeAfter?.(...task)
        }
      }
      return this
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head]
          this.#evict(true)
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching
            }
          } else if (val !== undefined) {
            return val
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed
          let task
          while ((task = dt?.shift())) {
            this.#disposeAfter?.(...task)
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head
      const k = this.#keyList[head]
      const v = this.#valList[head]
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('evicted'))
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, 'evict')
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, 'evict'])
        }
      }
      this.#removeItemSize(head)
      // if we aren't about to use the index, then null these out
      if (free) {
        this.#keyList[head] = undefined
        this.#valList[head] = undefined
        this.#free.push(head)
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0
        this.#free.length = 0
      } else {
        this.#head = this.#next[head]
      }
      this.#keyMap.delete(k)
      this.#size--
      return head
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions
      const index = this.#keyMap.get(k)
      if (index !== undefined) {
        const v = this.#valList[index]
        if (
          this.#isBackgroundFetch(v) &&
          v.__staleWhileFetching === undefined
        ) {
          return false
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index)
          }
          if (status) {
            status.has = 'hit'
            this.#statusTTL(status, index)
          }
          return true
        } else if (status) {
          status.has = 'stale'
          this.#statusTTL(status, index)
        }
      } else if (status) {
        status.has = 'miss'
      }
      return false
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions
      const index = this.#keyMap.get(k)
      if (index === undefined || (!allowStale && this.#isStale(index))) {
        return
      }
      const v = this.#valList[index]
      // either stale and allowed, or forcing a refresh of non-stale value
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
    }
    #backgroundFetch(k, index, options, context) {
      const v = index === undefined ? undefined : this.#valList[index]
      if (this.#isBackgroundFetch(v)) {
        return v
      }
      const ac = new AC()
      const { signal } = options
      // when/if our AC signals, then stop listening to theirs.
      signal?.addEventListener('abort', () => ac.abort(signal.reason), {
        signal: ac.signal
      })
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      }
      const cb = (v, updateCache = false) => {
        const { aborted } = ac.signal
        const ignoreAbort = options.ignoreFetchAbort && v !== undefined
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true
            options.status.fetchError = ac.signal.reason
            if (ignoreAbort) {
              options.status.fetchAbortIgnored = true
            }
          } else {
            options.status.fetchResolved = true
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason)
        }
        // either we didn't abort, and are still here, or we did, and ignored
        const bf = p
        if (this.#valList[index] === p) {
          if (v === undefined) {
            if (bf.__staleWhileFetching) {
              this.#valList[index] = bf.__staleWhileFetching
            } else {
              this.#delete(k, 'fetch')
            }
          } else {
            if (options.status) {
              options.status.fetchUpdated = true
            }
            this.set(k, v, fetchOpts.options)
          }
        }
        return v
      }
      const eb = er => {
        if (options.status) {
          options.status.fetchRejected = true
          options.status.fetchError = er
        }
        return fetchFail(er)
      }
      const fetchFail = er => {
        const { aborted } = ac.signal
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort
        const allowStale =
          allowStaleAborted || options.allowStaleOnFetchRejection
        const noDelete = allowStale || options.noDeleteOnFetchRejection
        const bf = p
        if (this.#valList[index] === p) {
          // if we allow stale on fetch rejections, then we need to ensure that
          // the stale value is not removed from the cache when the fetch fails.
          const del = !noDelete || bf.__staleWhileFetching === undefined
          if (del) {
            this.#delete(k, 'fetch')
          } else if (!allowStaleAborted) {
            // still replace the *promise* with the stale value,
            // since we are done with the promise at this point.
            // leave it untouched if we're still waiting for an
            // aborted background fetch that hasn't yet returned.
            this.#valList[index] = bf.__staleWhileFetching
          }
        }
        if (allowStale) {
          if (options.status && bf.__staleWhileFetching !== undefined) {
            options.status.returnedStale = true
          }
          return bf.__staleWhileFetching
        } else if (bf.__returned === bf) {
          throw er
        }
      }
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts)
        if (fmp && fmp instanceof Promise) {
          fmp.then(v => res(v === undefined ? undefined : v), rej)
        }
        // ignored, we go until we finish, regardless.
        // defer check until we are actually aborting,
        // so fetchMethod can override.
        ac.signal.addEventListener('abort', () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(undefined)
            // when it eventually resolves, update the cache.
            if (options.allowStaleOnFetchAbort) {
              res = v => cb(v, true)
            }
          }
        })
      }
      if (options.status) {
        options.status.fetchDispatched = true
      }
      const p = new Promise(pcall).then(cb, eb)
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: undefined
      })
      if (index === undefined) {
        // internal, don't expose status.
        this.set(k, bf, {
          ...fetchOpts.options,
          status: undefined
        })
        index = this.#keyMap.get(k)
      } else {
        this.#valList[index] = bf
      }
      return bf
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod) {
        return false
      }
      const b = p
      return (
        !!b &&
        b instanceof Promise &&
        b.hasOwnProperty('__staleWhileFetching') &&
        b.__abortController instanceof AC
      )
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions
      if (!this.#hasFetchMethod) {
        if (status) {
          status.fetch = 'get'
        }
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        })
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      }
      let index = this.#keyMap.get(k)
      if (index === undefined) {
        if (status) {
          status.fetch = 'miss'
        }
        const p = this.#backgroundFetch(k, index, options, context)
        return (p.__returned = p)
      } else {
        // in cache, maybe already fetching
        const v = this.#valList[index]
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined
          if (status) {
            status.fetch = 'inflight'
            if (stale) {
              status.returnedStale = true
            }
          }
          return stale ? v.__staleWhileFetching : (v.__returned = v)
        }
        // if we force a refresh, that means do NOT serve the cached value,
        // unless we are already in the process of refreshing the cache.
        const isStale = this.#isStale(index)
        if (!forceRefresh && !isStale) {
          if (status) {
            status.fetch = 'hit'
          }
          this.#moveToTail(index)
          if (updateAgeOnGet) {
            this.#updateItemAge(index)
          }
          if (status) {
            this.#statusTTL(status, index)
          }
          return v
        }
        // ok, it is stale or a forced refresh, and not already fetching.
        // refresh the cache.
        const p = this.#backgroundFetch(k, index, options, context)
        const hasStale = p.__staleWhileFetching !== undefined
        const staleVal = hasStale && allowStale
        if (status) {
          status.fetch = isStale ? 'stale' : 'refresh'
          if (staleVal && isStale) {
            status.returnedStale = true
          }
        }
        return staleVal ? p.__staleWhileFetching : (p.__returned = p)
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions)
      if (v === undefined) {
        throw new Error('fetch() returned undefined')
      }
      return v
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod
      if (!memoMethod) {
        throw new Error('no memoMethod provided to constructor')
      }
      const { context, forceRefresh, ...options } = memoOptions
      const v = this.get(k, options)
      if (!forceRefresh && v !== undefined) {
        return v
      }
      const vv = memoMethod(k, v, {
        options,
        context
      })
      this.set(k, vv, options)
      return vv
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        status
      } = getOptions
      const index = this.#keyMap.get(k)
      if (index !== undefined) {
        const value = this.#valList[index]
        const fetching = this.#isBackgroundFetch(value)
        if (status) {
          this.#statusTTL(status, index)
        }
        if (this.#isStale(index)) {
          if (status) {
            status.get = 'stale'
          }
          // delete only if not an in-flight background fetch
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, 'expire')
            }
            if (status && allowStale) {
              status.returnedStale = true
            }
            return allowStale ? value : undefined
          } else {
            if (
              status &&
              allowStale &&
              value.__staleWhileFetching !== undefined
            ) {
              status.returnedStale = true
            }
            return allowStale ? value.__staleWhileFetching : undefined
          }
        } else {
          if (status) {
            status.get = 'hit'
          }
          // if we're currently fetching it, we don't actually have it yet
          // it's not stale, which means this isn't a staleWhileRefetching.
          // If it's not stale, and fetching, AND has a __staleWhileFetching
          // value, then that means the user fetched with {forceRefresh:true},
          // so it's safe to return that value.
          if (fetching) {
            return value.__staleWhileFetching
          }
          this.#moveToTail(index)
          if (updateAgeOnGet) {
            this.#updateItemAge(index)
          }
          return value
        }
      } else if (status) {
        status.get = 'miss'
      }
    }
    #connect(p, n) {
      this.#prev[n] = p
      this.#next[p] = n
    }
    #moveToTail(index) {
      // if tail already, nothing to do
      // if head, move head to next[index]
      // else
      //   move next[prev[index]] to next[index] (head has no prev)
      //   move prev[next[index]] to prev[index]
      // prev[index] = tail
      // next[tail] = index
      // tail = index
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index]
        } else {
          this.#connect(this.#prev[index], this.#next[index])
        }
        this.#connect(this.#tail, index)
        this.#tail = index
      }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      return this.#delete(k, 'delete')
    }
    #delete(k, reason) {
      let deleted = false
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k)
        if (index !== undefined) {
          deleted = true
          if (this.#size === 1) {
            this.#clear(reason)
          } else {
            this.#removeItemSize(index)
            const v = this.#valList[index]
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error('deleted'))
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason)
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason])
              }
            }
            this.#keyMap.delete(k)
            this.#keyList[index] = undefined
            this.#valList[index] = undefined
            if (index === this.#tail) {
              this.#tail = this.#prev[index]
            } else if (index === this.#head) {
              this.#head = this.#next[index]
            } else {
              const pi = this.#prev[index]
              this.#next[pi] = this.#next[index]
              const ni = this.#next[index]
              this.#prev[ni] = this.#prev[index]
            }
            this.#size--
            this.#free.push(index)
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed
        let task
        while ((task = dt?.shift())) {
          this.#disposeAfter?.(...task)
        }
      }
      return deleted
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      return this.#clear('delete')
    }
    #clear(reason) {
      for (const index of this.#rindexes({
        allowStale: true
      })) {
        const v = this.#valList[index]
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error('deleted'))
        } else {
          const k = this.#keyList[index]
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason)
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason])
          }
        }
      }
      this.#keyMap.clear()
      this.#valList.fill(undefined)
      this.#keyList.fill(undefined)
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0)
        this.#starts.fill(0)
      }
      if (this.#sizes) {
        this.#sizes.fill(0)
      }
      this.#head = 0
      this.#tail = 0
      this.#free.length = 0
      this.#calculatedSize = 0
      this.#size = 0
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed
        let task
        while ((task = dt?.shift())) {
          this.#disposeAfter?.(...task)
        }
      }
    }
  }
  commonjs.LRUCache = LRUCache
  return commonjs
}

/* eslint-disable max-len */
let hosts_1
let hasRequiredHosts
function requireHosts() {
  if (hasRequiredHosts) {
    return hosts_1
  }
  hasRequiredHosts = 1
  const maybeJoin = (...args) => (args.every(arg => arg) ? args.join('') : '')
  const maybeEncode = arg => (arg ? encodeURIComponent(arg) : '')
  const formatHashFragment = f =>
    f
      .toLowerCase()
      .replace(/^\W+|\/|\W+$/g, '')
      .replace(/\W+/g, '-')
  const defaults = {
    sshtemplate: ({ domain, user, project, committish }) =>
      `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,
    sshurltemplate: ({ domain, user, project, committish }) =>
      `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    edittemplate: ({ domain, user, project, committish, editpath, path }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,
    browsetemplate: ({ domain, user, project, committish, treepath }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,
    browsetreetemplate: ({
      domain,
      user,
      project,
      committish,
      treepath,
      path,
      fragment,
      hashformat
    }) =>
      `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
    browseblobtemplate: ({
      domain,
      user,
      project,
      committish,
      blobpath,
      path,
      fragment,
      hashformat
    }) =>
      `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
    docstemplate: ({ domain, user, project, treepath, committish }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,
    httpstemplate: ({ auth, domain, user, project, committish }) =>
      `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    filetemplate: ({ domain, user, project, committish, path }) =>
      `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,
    shortcuttemplate: ({ type, user, project, committish }) =>
      `${type}:${user}/${project}${maybeJoin('#', committish)}`,
    pathtemplate: ({ user, project, committish }) =>
      `${user}/${project}${maybeJoin('#', committish)}`,
    bugstemplate: ({ domain, user, project }) =>
      `https://${domain}/${user}/${project}/issues`,
    hashformat: formatHashFragment
  }
  const hosts = {}
  hosts.github = {
    // First two are insecure and generally shouldn't be used any more, but
    // they are still supported.
    protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'github.com',
    treepath: 'tree',
    blobpath: 'blob',
    editpath: 'edit',
    filetemplate: ({ auth, user, project, committish, path }) =>
      `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,
    gittemplate: ({ auth, domain, user, project, committish }) =>
      `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
    extract: url => {
      let [, user, project, type, committish] = url.pathname.split('/', 5)
      if (type && type !== 'tree') {
        return
      }
      if (!type) {
        committish = url.hash.slice(1)
      }
      if (project && project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish
      }
    }
  }
  hosts.bitbucket = {
    protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'bitbucket.org',
    treepath: 'src',
    blobpath: 'src',
    editpath: '?mode=edit',
    edittemplate: ({
      domain,
      user,
      project,
      committish,
      treepath,
      path,
      editpath
    }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,
    extract: url => {
      let [, user, project, aux] = url.pathname.split('/', 4)
      if (['get'].includes(aux)) {
        return
      }
      if (project && project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    }
  }
  hosts.gitlab = {
    protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'gitlab.com',
    treepath: 'tree',
    blobpath: 'tree',
    editpath: '-/edit',
    httpstemplate: ({ auth, domain, user, project, committish }) =>
      `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,
    extract: url => {
      const path = url.pathname.slice(1)
      if (path.includes('/-/') || path.includes('/archive.tar.gz')) {
        return
      }
      const segments = path.split('/')
      let project = segments.pop()
      if (project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      const user = segments.join('/')
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    }
  }
  hosts.gist = {
    protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'gist.github.com',
    editpath: 'edit',
    sshtemplate: ({ domain, project, committish }) =>
      `git@${domain}:${project}.git${maybeJoin('#', committish)}`,
    sshurltemplate: ({ domain, project, committish }) =>
      `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,
    edittemplate: ({ domain, user, project, committish, editpath }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,
    browsetemplate: ({ domain, project, committish }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
    browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
    browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
    docstemplate: ({ domain, project, committish }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
    httpstemplate: ({ domain, project, committish }) =>
      `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,
    filetemplate: ({ user, project, committish, path }) =>
      `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,
    shortcuttemplate: ({ type, project, committish }) =>
      `${type}:${project}${maybeJoin('#', committish)}`,
    pathtemplate: ({ project, committish }) =>
      `${project}${maybeJoin('#', committish)}`,
    bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
    gittemplate: ({ domain, project, committish }) =>
      `git://${domain}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ project, committish }) =>
      `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
    extract: url => {
      let [, user, project, aux] = url.pathname.split('/', 4)
      if (aux === 'raw') {
        return
      }
      if (!project) {
        if (!user) {
          return
        }
        project = user
        user = null
      }
      if (project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    },
    hashformat: function (fragment) {
      return fragment && 'file-' + formatHashFragment(fragment)
    }
  }
  hosts.sourcehut = {
    protocols: ['git+ssh:', 'https:'],
    domain: 'git.sr.ht',
    treepath: 'tree',
    blobpath: 'tree',
    filetemplate: ({ domain, user, project, committish, path }) =>
      `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,
    httpstemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,
    bugstemplate: () => null,
    extract: url => {
      let [, user, project, aux] = url.pathname.split('/', 4)

      // tarball url
      if (['archive'].includes(aux)) {
        return
      }
      if (project && project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    }
  }
  for (const [name, host] of Object.entries(hosts)) {
    hosts[name] = Object.assign({}, defaults, host)
  }
  hosts_1 = hosts
  return hosts_1
}

let parseUrl
let hasRequiredParseUrl
function requireParseUrl() {
  if (hasRequiredParseUrl) {
    return parseUrl
  }
  hasRequiredParseUrl = 1
  const url = require$$0
  const lastIndexOfBefore = (str, char, beforeChar) => {
    const startPosition = str.indexOf(beforeChar)
    return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)
  }
  const safeUrl = u => {
    try {
      return new url.URL(u)
    } catch {
      // this fn should never throw
    }
  }

  // accepts input like git:github.com:user/repo and inserts the // after the first :
  const correctProtocol = (arg, protocols) => {
    const firstColon = arg.indexOf(':')
    const proto = arg.slice(0, firstColon + 1)
    if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
      return arg
    }
    const firstAt = arg.indexOf('@')
    if (firstAt > -1) {
      if (firstAt > firstColon) {
        return `git+ssh://${arg}`
      } else {
        return arg
      }
    }
    const doubleSlash = arg.indexOf('//')
    if (doubleSlash === firstColon + 1) {
      return arg
    }
    return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`
  }

  // attempt to correct an scp style url so that it will parse with `new URL()`
  const correctUrl = giturl => {
    // ignore @ that come after the first hash since the denotes the start
    // of a committish which can contain @ characters
    const firstAt = lastIndexOfBefore(giturl, '@', '#')
    // ignore colons that come after the hash since that could include colons such as:
    // git@github.com:user/package-2#semver:^1.0.0
    const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')
    if (lastColonBeforeHash > firstAt) {
      // the last : comes after the first @ (or there is no @)
      // like it would in:
      // proto://hostname.com:user/repo
      // username@hostname.com:user/repo
      // :password@hostname.com:user/repo
      // username:password@hostname.com:user/repo
      // proto://username@hostname.com:user/repo
      // proto://:password@hostname.com:user/repo
      // proto://username:password@hostname.com:user/repo
      // then we replace the last : with a / to create a valid path
      giturl =
        giturl.slice(0, lastColonBeforeHash) +
        '/' +
        giturl.slice(lastColonBeforeHash + 1)
    }
    if (
      lastIndexOfBefore(giturl, ':', '#') === -1 &&
      giturl.indexOf('//') === -1
    ) {
      // we have no : at all
      // as it would be in:
      // username@hostname.com/user/repo
      // then we prepend a protocol
      giturl = `git+ssh://${giturl}`
    }
    return giturl
  }
  parseUrl = (giturl, protocols) => {
    const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl
    return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))
  }
  return parseUrl
}

let fromUrl
let hasRequiredFromUrl
function requireFromUrl() {
  if (hasRequiredFromUrl) {
    return fromUrl
  }
  hasRequiredFromUrl = 1
  const parseUrl = requireParseUrl()

  // look for github shorthand inputs, such as npm/cli
  const isGitHubShorthand = arg => {
    // it cannot contain whitespace before the first #
    // it cannot start with a / because that's probably an absolute file path
    // but it must include a slash since repos are username/repository
    // it cannot start with a . because that's probably a relative file path
    // it cannot start with an @ because that's a scoped package if it passes the other tests
    // it cannot contain a : before a # because that tells us that there's a protocol
    // a second / may not exist before a #
    const firstHash = arg.indexOf('#')
    const firstSlash = arg.indexOf('/')
    const secondSlash = arg.indexOf('/', firstSlash + 1)
    const firstColon = arg.indexOf(':')
    const firstSpace = /\s/.exec(arg)
    const firstAt = arg.indexOf('@')
    const spaceOnlyAfterHash =
      !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)
    const atOnlyAfterHash =
      firstAt === -1 || (firstHash > -1 && firstAt > firstHash)
    const colonOnlyAfterHash =
      firstColon === -1 || (firstHash > -1 && firstColon > firstHash)
    const secondSlashOnlyAfterHash =
      secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)
    const hasSlash = firstSlash > 0
    // if a # is found, what we really want to know is that the character
    // immediately before # is not a /
    const doesNotEndWithSlash =
      firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')
    const doesNotStartWithDot = !arg.startsWith('.')
    return (
      spaceOnlyAfterHash &&
      hasSlash &&
      doesNotEndWithSlash &&
      doesNotStartWithDot &&
      atOnlyAfterHash &&
      colonOnlyAfterHash &&
      secondSlashOnlyAfterHash
    )
  }
  fromUrl = (giturl, opts, { gitHosts, protocols }) => {
    if (!giturl) {
      return
    }
    const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl
    const parsed = parseUrl(correctedUrl, protocols)
    if (!parsed) {
      return
    }
    const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]
    const gitHostDomain =
      gitHosts.byDomain[
        parsed.hostname.startsWith('www.')
          ? parsed.hostname.slice(4)
          : parsed.hostname
      ]
    const gitHostName = gitHostShortcut || gitHostDomain
    if (!gitHostName) {
      return
    }
    const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]
    let auth = null
    if (
      protocols[parsed.protocol]?.auth &&
      (parsed.username || parsed.password)
    ) {
      auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`
    }
    let committish = null
    let user = null
    let project = null
    let defaultRepresentation = null
    try {
      if (gitHostShortcut) {
        let pathname = parsed.pathname.startsWith('/')
          ? parsed.pathname.slice(1)
          : parsed.pathname
        const firstAt = pathname.indexOf('@')
        // we ignore auth for shortcuts, so just trim it out
        if (firstAt > -1) {
          pathname = pathname.slice(firstAt + 1)
        }
        const lastSlash = pathname.lastIndexOf('/')
        if (lastSlash > -1) {
          user = decodeURIComponent(pathname.slice(0, lastSlash))
          // we want nulls only, never empty strings
          if (!user) {
            user = null
          }
          project = decodeURIComponent(pathname.slice(lastSlash + 1))
        } else {
          project = decodeURIComponent(pathname)
        }
        if (project.endsWith('.git')) {
          project = project.slice(0, -4)
        }
        if (parsed.hash) {
          committish = decodeURIComponent(parsed.hash.slice(1))
        }
        defaultRepresentation = 'shortcut'
      } else {
        if (!gitHostInfo.protocols.includes(parsed.protocol)) {
          return
        }
        const segments = gitHostInfo.extract(parsed)
        if (!segments) {
          return
        }
        user = segments.user && decodeURIComponent(segments.user)
        project = decodeURIComponent(segments.project)
        committish = decodeURIComponent(segments.committish)
        defaultRepresentation =
          protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1)
      }
    } catch (err) {
      /* istanbul ignore else */
      if (err instanceof URIError) {
        return
      } else {
        throw err
      }
    }
    return [
      gitHostName,
      user,
      auth,
      project,
      committish,
      defaultRepresentation,
      opts
    ]
  }
  return fromUrl
}

let lib
let hasRequiredLib
function requireLib() {
  if (hasRequiredLib) {
    return lib
  }
  hasRequiredLib = 1
  const { LRUCache } = /*@__PURE__*/ requireCommonjs()
  const hosts = requireHosts()
  const fromUrl = requireFromUrl()
  const parseUrl = requireParseUrl()
  const cache = new LRUCache({
    max: 1000
  })
  class GitHost {
    constructor(
      type,
      user,
      auth,
      project,
      committish,
      defaultRepresentation,
      opts = {}
    ) {
      Object.assign(this, GitHost.#gitHosts[type], {
        type,
        user,
        auth,
        project,
        committish,
        default: defaultRepresentation,
        opts
      })
    }
    static #gitHosts = {
      byShortcut: {},
      byDomain: {}
    }
    static #protocols = {
      'git+ssh:': {
        name: 'sshurl'
      },
      'ssh:': {
        name: 'sshurl'
      },
      'git+https:': {
        name: 'https',
        auth: true
      },
      'git:': {
        auth: true
      },
      'http:': {
        auth: true
      },
      'https:': {
        auth: true
      },
      'git+http:': {
        auth: true
      }
    }
    static addHost(name, host) {
      GitHost.#gitHosts[name] = host
      GitHost.#gitHosts.byDomain[host.domain] = name
      GitHost.#gitHosts.byShortcut[`${name}:`] = name
      GitHost.#protocols[`${name}:`] = {
        name
      }
    }
    static fromUrl(giturl, opts) {
      if (typeof giturl !== 'string') {
        return
      }
      const key = giturl + JSON.stringify(opts || {})
      if (!cache.has(key)) {
        const hostArgs = fromUrl(giturl, opts, {
          gitHosts: GitHost.#gitHosts,
          protocols: GitHost.#protocols
        })
        cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined)
      }
      return cache.get(key)
    }
    static parseUrl(url) {
      return parseUrl(url)
    }
    #fill(template, opts) {
      if (typeof template !== 'function') {
        return null
      }
      const options = {
        ...this,
        ...this.opts,
        ...opts
      }

      // the path should always be set so we don't end up with 'undefined' in urls
      if (!options.path) {
        options.path = ''
      }

      // template functions will insert the leading slash themselves
      if (options.path.startsWith('/')) {
        options.path = options.path.slice(1)
      }
      if (options.noCommittish) {
        options.committish = null
      }
      const result = template(options)
      return options.noGitPlus && result.startsWith('git+')
        ? result.slice(4)
        : result
    }
    hash() {
      return this.committish ? `#${this.committish}` : ''
    }
    ssh(opts) {
      return this.#fill(this.sshtemplate, opts)
    }
    sshurl(opts) {
      return this.#fill(this.sshurltemplate, opts)
    }
    browse(path, ...args) {
      // not a string, treat path as opts
      if (typeof path !== 'string') {
        return this.#fill(this.browsetemplate, path)
      }
      if (typeof args[0] !== 'string') {
        return this.#fill(this.browsetreetemplate, {
          ...args[0],
          path
        })
      }
      return this.#fill(this.browsetreetemplate, {
        ...args[1],
        fragment: args[0],
        path
      })
    }

    // If the path is known to be a file, then browseFile should be used. For some hosts
    // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
    // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
    // path will redirect to a specific commit. Using the `/blob/` path avoids this and
    // does not redirect to a different commit.
    browseFile(path, ...args) {
      if (typeof args[0] !== 'string') {
        return this.#fill(this.browseblobtemplate, {
          ...args[0],
          path
        })
      }
      return this.#fill(this.browseblobtemplate, {
        ...args[1],
        fragment: args[0],
        path
      })
    }
    docs(opts) {
      return this.#fill(this.docstemplate, opts)
    }
    bugs(opts) {
      return this.#fill(this.bugstemplate, opts)
    }
    https(opts) {
      return this.#fill(this.httpstemplate, opts)
    }
    git(opts) {
      return this.#fill(this.gittemplate, opts)
    }
    shortcut(opts) {
      return this.#fill(this.shortcuttemplate, opts)
    }
    path(opts) {
      return this.#fill(this.pathtemplate, opts)
    }
    tarball(opts) {
      return this.#fill(this.tarballtemplate, {
        ...opts,
        noCommittish: false
      })
    }
    file(path, opts) {
      return this.#fill(this.filetemplate, {
        ...opts,
        path
      })
    }
    edit(path, opts) {
      return this.#fill(this.edittemplate, {
        ...opts,
        path
      })
    }
    getDefaultRepresentation() {
      return this.default
    }
    toString(opts) {
      if (this.default && typeof this[this.default] === 'function') {
        return this[this.default](opts)
      }
      return this.sshurl(opts)
    }
  }
  for (const [name, host] of Object.entries(hosts)) {
    GitHost.addHost(name, host)
  }
  lib = GitHost
  return lib
}

let isCoreModule
let hasRequiredIsCoreModule
function requireIsCoreModule() {
  if (hasRequiredIsCoreModule) {
    return isCoreModule
  }
  hasRequiredIsCoreModule = 1
  const { isBuiltin } = require$$0$1
  isCoreModule = function isCore(moduleName, nodeVersion) {
    if (typeof nodeVersion === 'string') {
      throw new TypeError(
        'nodeVersion parameter not supported.\nPlease report this error to https://github.com/SocketDev/socket-registry/issues.'
      )
    }
    return isBuiltin(moduleName)
  }
  return isCoreModule
}

let extract_description
let hasRequiredExtract_description
function requireExtract_description() {
  if (hasRequiredExtract_description) {
    return extract_description
  }
  hasRequiredExtract_description = 1
  extract_description = extractDescription

  // Extracts description from contents of a readme file in markdown format
  function extractDescription(d) {
    if (!d) {
      return
    }
    if (d === 'ERROR: No README data found!') {
      return
    }
    // the first block of text before the first heading
    // that isn't the first line heading
    d = d.trim().split('\n')
    let s = 0
    while (d[s] && d[s].trim().match(/^(#|$)/)) {
      s++
    }
    const l = d.length
    let e = s + 1
    while (e < l && d[e].trim()) {
      e++
    }
    return d.slice(s, e).join(' ').trim()
  }
  return extract_description
}

const topLevel = {
  dependancies: 'dependencies',
  dependecies: 'dependencies',
  depdenencies: 'dependencies',
  devEependencies: 'devDependencies',
  depends: 'dependencies',
  'dev-dependencies': 'devDependencies',
  devDependences: 'devDependencies',
  devDepenencies: 'devDependencies',
  devdependencies: 'devDependencies',
  repostitory: 'repository',
  repo: 'repository',
  prefereGlobal: 'preferGlobal',
  hompage: 'homepage',
  hampage: 'homepage',
  autohr: 'author',
  autor: 'author',
  contributers: 'contributors',
  publicationConfig: 'publishConfig',
  script: 'scripts'
}
const bugs = {
  web: 'url',
  name: 'url'
}
const script = {
  server: 'start',
  tests: 'test'
}
const require$$7 = {
  topLevel: topLevel,
  bugs: bugs,
  script: script
}

let fixer
let hasRequiredFixer
function requireFixer() {
  if (hasRequiredFixer) {
    return fixer
  }
  hasRequiredFixer = 1
  const isValidSemver = requireValid()
  const cleanSemver = requireClean()
  const validateLicense = requireValidateNpmPackageLicense()
  const hostedGitInfo = requireLib()
  const isBuiltinModule = /*@__PURE__*/ requireIsCoreModule()
  const depTypes = ['dependencies', 'devDependencies', 'optionalDependencies']
  const extractDescription = requireExtract_description()
  const typos = require$$7
  const isEmail = str =>
    str.includes('@') && str.indexOf('@') < str.lastIndexOf('.')
  fixer = {
    // default warning function
    warn: function () {},
    fixRepositoryField: function (data) {
      if (data.repositories) {
        this.warn('repositories')
        data.repository = data.repositories[0]
      }
      if (!data.repository) {
        return this.warn('missingRepository')
      }
      if (typeof data.repository === 'string') {
        data.repository = {
          type: 'git',
          url: data.repository
        }
      }
      let r = data.repository.url || ''
      if (r) {
        const hosted = hostedGitInfo.fromUrl(r)
        if (hosted) {
          r = data.repository.url =
            hosted.getDefaultRepresentation() === 'shortcut'
              ? hosted.https()
              : hosted.toString()
        }
      }
      if (r.match(/github.com\/[^/]+\/[^/]+\.git\.git$/)) {
        this.warn('brokenGitUrl', r)
      }
    },
    fixTypos: function (data) {
      Object.keys(typos.topLevel).forEach(function (d) {
        if (Object.prototype.hasOwnProperty.call(data, d)) {
          this.warn('typo', d, typos.topLevel[d])
        }
      }, this)
    },
    fixScriptsField: function (data) {
      if (!data.scripts) {
        return
      }
      if (typeof data.scripts !== 'object') {
        this.warn('nonObjectScripts')
        delete data.scripts
        return
      }
      Object.keys(data.scripts).forEach(function (k) {
        if (typeof data.scripts[k] !== 'string') {
          this.warn('nonStringScript')
          delete data.scripts[k]
        } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
          this.warn('typo', k, typos.script[k], 'scripts')
        }
      }, this)
    },
    fixFilesField: function (data) {
      const files = data.files
      if (files && !Array.isArray(files)) {
        this.warn('nonArrayFiles')
        delete data.files
      } else if (data.files) {
        data.files = data.files.filter(function (file) {
          if (!file || typeof file !== 'string') {
            this.warn('invalidFilename', file)
            return false
          } else {
            return true
          }
        }, this)
      }
    },
    fixBinField: function (data) {
      if (!data.bin) {
        return
      }
      if (typeof data.bin === 'string') {
        const b = {}
        let match
        if ((match = data.name.match(/^@[^/]+[/](.*)$/))) {
          b[match[1]] = data.bin
        } else {
          b[data.name] = data.bin
        }
        data.bin = b
      }
    },
    fixManField: function (data) {
      if (!data.man) {
        return
      }
      if (typeof data.man === 'string') {
        data.man = [data.man]
      }
    },
    fixBundleDependenciesField: function (data) {
      const bdd = 'bundledDependencies'
      const bd = 'bundleDependencies'
      if (data[bdd] && !data[bd]) {
        data[bd] = data[bdd]
        delete data[bdd]
      }
      if (data[bd] && !Array.isArray(data[bd])) {
        this.warn('nonArrayBundleDependencies')
        delete data[bd]
      } else if (data[bd]) {
        data[bd] = data[bd].filter(function (filtered) {
          if (!filtered || typeof filtered !== 'string') {
            this.warn('nonStringBundleDependency', filtered)
            return false
          } else {
            if (!data.dependencies) {
              data.dependencies = {}
            }
            if (
              !Object.prototype.hasOwnProperty.call(data.dependencies, filtered)
            ) {
              this.warn('nonDependencyBundleDependency', filtered)
              data.dependencies[filtered] = '*'
            }
            return true
          }
        }, this)
      }
    },
    fixDependencies: function (data) {
      objectifyDeps(data, this.warn)
      addOptionalDepsToDeps(data, this.warn)
      this.fixBundleDependenciesField(data)
      ;['dependencies', 'devDependencies'].forEach(function (deps) {
        if (!(deps in data)) {
          return
        }
        if (!data[deps] || typeof data[deps] !== 'object') {
          this.warn('nonObjectDependencies', deps)
          delete data[deps]
          return
        }
        Object.keys(data[deps]).forEach(function (d) {
          const r = data[deps][d]
          if (typeof r !== 'string') {
            this.warn('nonStringDependency', d, JSON.stringify(r))
            delete data[deps][d]
          }
          const hosted = hostedGitInfo.fromUrl(data[deps][d])
          if (hosted) {
            data[deps][d] = hosted.toString()
          }
        }, this)
      }, this)
    },
    fixModulesField: function (data) {
      if (data.modules) {
        this.warn('deprecatedModules')
        delete data.modules
      }
    },
    fixKeywordsField: function (data) {
      if (typeof data.keywords === 'string') {
        data.keywords = data.keywords.split(/,\s+/)
      }
      if (data.keywords && !Array.isArray(data.keywords)) {
        delete data.keywords
        this.warn('nonArrayKeywords')
      } else if (data.keywords) {
        data.keywords = data.keywords.filter(function (kw) {
          if (typeof kw !== 'string' || !kw) {
            this.warn('nonStringKeyword')
            return false
          } else {
            return true
          }
        }, this)
      }
    },
    fixVersionField: function (data, strict) {
      // allow "loose" semver 1.0 versions in non-strict mode
      // enforce strict semver 2.0 compliance in strict mode
      const loose = !strict
      if (!data.version) {
        data.version = ''
        return true
      }
      if (!isValidSemver(data.version, loose)) {
        throw new Error('Invalid version: "' + data.version + '"')
      }
      data.version = cleanSemver(data.version, loose)
      return true
    },
    fixPeople: function (data) {
      modifyPeople(data, unParsePerson)
      modifyPeople(data, parsePerson)
    },
    fixNameField: function (data, options) {
      if (typeof options === 'boolean') {
        options = {
          strict: options
        }
      } else if (typeof options === 'undefined') {
        options = {}
      }
      const strict = options.strict
      if (!data.name && !strict) {
        data.name = ''
        return
      }
      if (typeof data.name !== 'string') {
        throw new Error('name field must be a string.')
      }
      if (!strict) {
        data.name = data.name.trim()
      }
      ensureValidName(data.name, strict, options.allowLegacyCase)
      if (isBuiltinModule(data.name)) {
        this.warn('conflictingName', data.name)
      }
    },
    fixDescriptionField: function (data) {
      if (data.description && typeof data.description !== 'string') {
        this.warn('nonStringDescription')
        delete data.description
      }
      if (data.readme && !data.description) {
        data.description = extractDescription(data.readme)
      }
      if (data.description === undefined) {
        delete data.description
      }
      if (!data.description) {
        this.warn('missingDescription')
      }
    },
    fixReadmeField: function (data) {
      if (!data.readme) {
        this.warn('missingReadme')
        data.readme = 'ERROR: No README data found!'
      }
    },
    fixBugsField: function (data) {
      if (!data.bugs && data.repository && data.repository.url) {
        const hosted = hostedGitInfo.fromUrl(data.repository.url)
        if (hosted && hosted.bugs()) {
          data.bugs = {
            url: hosted.bugs()
          }
        }
      } else if (data.bugs) {
        if (typeof data.bugs === 'string') {
          if (isEmail(data.bugs)) {
            data.bugs = {
              email: data.bugs
            }
            /* eslint-disable-next-line node/no-deprecated-api */
          } else if (new URL(data.bugs).protocol) {
            data.bugs = {
              url: data.bugs
            }
          } else {
            this.warn('nonEmailUrlBugsString')
          }
        } else {
          bugsTypos(data.bugs, this.warn)
          const oldBugs = data.bugs
          data.bugs = {}
          if (oldBugs.url) {
            /* eslint-disable-next-line node/no-deprecated-api */
            if (
              typeof oldBugs.url === 'string' &&
              new URL(oldBugs.url).protocol
            ) {
              data.bugs.url = oldBugs.url
            } else {
              this.warn('nonUrlBugsUrlField')
            }
          }
          if (oldBugs.email) {
            if (typeof oldBugs.email === 'string' && isEmail(oldBugs.email)) {
              data.bugs.email = oldBugs.email
            } else {
              this.warn('nonEmailBugsEmailField')
            }
          }
        }
        if (!data.bugs.email && !data.bugs.url) {
          delete data.bugs
          this.warn('emptyNormalizedBugs')
        }
      }
    },
    fixHomepageField: function (data) {
      if (!data.homepage && data.repository && data.repository.url) {
        const hosted = hostedGitInfo.fromUrl(data.repository.url)
        if (hosted && hosted.docs()) {
          data.homepage = hosted.docs()
        }
      }
      if (!data.homepage) {
        return
      }
      if (typeof data.homepage !== 'string') {
        this.warn('nonUrlHomepage')
        return delete data.homepage
      }
      /* eslint-disable-next-line node/no-deprecated-api */
      if (!new URL(data.homepage).protocol) {
        data.homepage = 'http://' + data.homepage
      }
    },
    fixLicenseField: function (data) {
      const license = data.license || data.licence
      if (!license) {
        return this.warn('missingLicense')
      }
      if (
        typeof license !== 'string' ||
        license.length < 1 ||
        license.trim() === ''
      ) {
        return this.warn('invalidLicense')
      }
      if (!validateLicense(license).validForNewPackages) {
        return this.warn('invalidLicense')
      }
    }
  }
  function isValidScopedPackageName(spec) {
    if (spec.charAt(0) !== '@') {
      return false
    }
    const rest = spec.slice(1).split('/')
    if (rest.length !== 2) {
      return false
    }
    return (
      rest[0] &&
      rest[1] &&
      rest[0] === encodeURIComponent(rest[0]) &&
      rest[1] === encodeURIComponent(rest[1])
    )
  }
  function isCorrectlyEncodedName(spec) {
    return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec)
  }
  function ensureValidName(name, strict, allowLegacyCase) {
    if (
      name.charAt(0) === '.' ||
      !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) ||
      (strict && !allowLegacyCase && name !== name.toLowerCase()) ||
      name.toLowerCase() === 'node_modules' ||
      name.toLowerCase() === 'favicon.ico'
    ) {
      throw new Error('Invalid name: ' + JSON.stringify(name))
    }
  }
  function modifyPeople(data, fn) {
    if (data.author) {
      data.author = fn(data.author)
    }
    ;['maintainers', 'contributors'].forEach(function (set) {
      if (!Array.isArray(data[set])) {
        return
      }
      data[set] = data[set].map(fn)
    })
    return data
  }
  function unParsePerson(person) {
    if (typeof person === 'string') {
      return person
    }
    const name = person.name || ''
    const u = person.url || person.web
    const wrappedUrl = u ? ' (' + u + ')' : ''
    const e = person.email || person.mail
    const wrappedEmail = e ? ' <' + e + '>' : ''
    return name + wrappedEmail + wrappedUrl
  }
  function parsePerson(person) {
    if (typeof person !== 'string') {
      return person
    }
    const matchedName = person.match(/^([^(<]+)/)
    const matchedUrl = person.match(/\(([^()]+)\)/)
    const matchedEmail = person.match(/<([^<>]+)>/)
    const obj = {}
    if (matchedName && matchedName[0].trim()) {
      obj.name = matchedName[0].trim()
    }
    if (matchedEmail) {
      obj.email = matchedEmail[1]
    }
    if (matchedUrl) {
      obj.url = matchedUrl[1]
    }
    return obj
  }
  function addOptionalDepsToDeps(data) {
    const o = data.optionalDependencies
    if (!o) {
      return
    }
    const d = data.dependencies || {}
    Object.keys(o).forEach(function (k) {
      d[k] = o[k]
    })
    data.dependencies = d
  }
  function depObjectify(deps, type, warn) {
    if (!deps) {
      return {}
    }
    if (typeof deps === 'string') {
      deps = deps.trim().split(/[\n\r\s\t ,]+/)
    }
    if (!Array.isArray(deps)) {
      return deps
    }
    warn('deprecatedArrayDependencies', type)
    const o = {}
    deps
      .filter(function (d) {
        return typeof d === 'string'
      })
      .forEach(function (d) {
        d = d.trim().split(/(:?[@\s><=])/)
        const dn = d.shift()
        let dv = d.join('')
        dv = dv.trim()
        dv = dv.replace(/^@/, '')
        o[dn] = dv
      })
    return o
  }
  function objectifyDeps(data, warn) {
    depTypes.forEach(function (type) {
      if (!data[type]) {
        return
      }
      data[type] = depObjectify(data[type], type, warn)
    })
  }
  function bugsTypos(bugs, warn) {
    if (!bugs) {
      return
    }
    Object.keys(bugs).forEach(function (k) {
      if (typos.bugs[k]) {
        warn('typo', k, typos.bugs[k], 'bugs')
        bugs[typos.bugs[k]] = bugs[k]
        delete bugs[k]
      }
    })
  }
  return fixer
}

const repositories =
  "'repositories' (plural) Not supported. Please pick one as the 'repository' field"
const missingRepository = 'No repository field.'
const brokenGitUrl = 'Probably broken git url: %s'
const nonObjectScripts = 'scripts must be an object'
const nonStringScript = 'script values must be string commands'
const nonArrayFiles = "Invalid 'files' member"
const invalidFilename = "Invalid filename in 'files' list: %s"
const nonArrayBundleDependencies =
  "Invalid 'bundleDependencies' list. Must be array of package names"
const nonStringBundleDependency = 'Invalid bundleDependencies member: %s'
const nonDependencyBundleDependency = 'Non-dependency in bundleDependencies: %s'
const nonObjectDependencies = '%s field must be an object'
const nonStringDependency = 'Invalid dependency: %s %s'
const deprecatedArrayDependencies = 'specifying %s as array is deprecated'
const deprecatedModules = 'modules field is deprecated'
const nonArrayKeywords = 'keywords should be an array of strings'
const nonStringKeyword = 'keywords should be an array of strings'
const conflictingName = '%s is also the name of a node core module.'
const nonStringDescription = "'description' field should be a string"
const missingDescription = 'No description'
const missingReadme = 'No README data'
const missingLicense = 'No license field.'
const nonEmailUrlBugsString =
  'Bug string field must be url, email, or {email,url}'
const nonUrlBugsUrlField = 'bugs.url field must be a string url. Deleted.'
const nonEmailBugsEmailField =
  'bugs.email field must be a string email. Deleted.'
const emptyNormalizedBugs =
  'Normalized value of bugs field is an empty object. Deleted.'
const nonUrlHomepage = 'homepage field must be a string url. Deleted.'
const invalidLicense = 'license should be a valid SPDX license expression'
const typo = '%s should probably be %s.'
const require$$1 = {
  repositories: repositories,
  missingRepository: missingRepository,
  brokenGitUrl: brokenGitUrl,
  nonObjectScripts: nonObjectScripts,
  nonStringScript: nonStringScript,
  nonArrayFiles: nonArrayFiles,
  invalidFilename: invalidFilename,
  nonArrayBundleDependencies: nonArrayBundleDependencies,
  nonStringBundleDependency: nonStringBundleDependency,
  nonDependencyBundleDependency: nonDependencyBundleDependency,
  nonObjectDependencies: nonObjectDependencies,
  nonStringDependency: nonStringDependency,
  deprecatedArrayDependencies: deprecatedArrayDependencies,
  deprecatedModules: deprecatedModules,
  nonArrayKeywords: nonArrayKeywords,
  nonStringKeyword: nonStringKeyword,
  conflictingName: conflictingName,
  nonStringDescription: nonStringDescription,
  missingDescription: missingDescription,
  missingReadme: missingReadme,
  missingLicense: missingLicense,
  nonEmailUrlBugsString: nonEmailUrlBugsString,
  nonUrlBugsUrlField: nonUrlBugsUrlField,
  nonEmailBugsEmailField: nonEmailBugsEmailField,
  emptyNormalizedBugs: emptyNormalizedBugs,
  nonUrlHomepage: nonUrlHomepage,
  invalidLicense: invalidLicense,
  typo: typo
}

let make_warning
let hasRequiredMake_warning
function requireMake_warning() {
  if (hasRequiredMake_warning) {
    return make_warning
  }
  hasRequiredMake_warning = 1
  const util = require$$0$2
  const messages = require$$1
  make_warning = function () {
    const args = Array.prototype.slice.call(arguments, 0)
    const warningName = args.shift()
    if (warningName === 'typo') {
      return makeTypoWarning.apply(null, args)
    } else {
      const msgTemplate = messages[warningName]
        ? messages[warningName]
        : warningName + ": '%s'"
      args.unshift(msgTemplate)
      return util.format.apply(null, args)
    }
  }
  function makeTypoWarning(providedName, probableName, field) {
    if (field) {
      providedName = field + "['" + providedName + "']"
      probableName = field + "['" + probableName + "']"
    }
    return util.format(messages.typo, providedName, probableName)
  }
  return make_warning
}

let normalize_1
let hasRequiredNormalize
function requireNormalize() {
  if (hasRequiredNormalize) {
    return normalize_1
  }
  hasRequiredNormalize = 1
  normalize_1 = normalize
  const fixer = requireFixer()
  normalize.fixer = fixer
  const makeWarning = requireMake_warning()
  const fieldsToFix = [
    'name',
    'version',
    'description',
    'repository',
    'modules',
    'scripts',
    'files',
    'bin',
    'man',
    'bugs',
    'keywords',
    'readme',
    'homepage',
    'license'
  ]
  const otherThingsToFix = ['dependencies', 'people', 'typos']
  let thingsToFix = fieldsToFix.map(function (fieldName) {
    return ucFirst(fieldName) + 'Field'
  })
  // two ways to do this in CoffeeScript on only one line, sub-70 chars:
  // thingsToFix = fieldsToFix.map (name) -> ucFirst(name) + "Field"
  // thingsToFix = (ucFirst(name) + "Field" for name in fieldsToFix)
  thingsToFix = thingsToFix.concat(otherThingsToFix)
  function normalize(data, warn, strict) {
    if (warn === true) {
      warn = null
      strict = true
    }
    if (!strict) {
      strict = false
    }
    if (!warn || data.private) {
      warn = function () {
        /* noop */
      }
    }
    if (
      data.scripts &&
      data.scripts.install === 'node-gyp rebuild' &&
      !data.scripts.preinstall
    ) {
      data.gypfile = true
    }
    fixer.warn = function () {
      warn(makeWarning.apply(null, arguments))
    }
    thingsToFix.forEach(function (thingName) {
      fixer['fix' + ucFirst(thingName)](data, strict)
    })
    data._id = data.name + '@' + data.version
  }
  function ucFirst(string) {
    return string.charAt(0).toUpperCase() + string.slice(1)
  }
  return normalize_1
}

const normalizeExports = requireNormalize()

module.exports = normalizeExports
