'use strict'

const require$$0$2 = require('url')
const require$$1 = require('path/win32')
const require$$2 = require('path')
const require$$3 = require('os')
const require$$0 = require('url')
const require$$0$1 = require('module')

const npa = { exports: {} }

const commonjs = {}

let hasRequiredCommonjs
function requireCommonjs() {
  if (hasRequiredCommonjs) {
    return commonjs
  }
  hasRequiredCommonjs = 1
  /**
   * @module LRUCache
   */
  Object.defineProperty(commonjs, '__esModule', {
    value: true
  })
  commonjs.LRUCache = void 0
  const perf =
    typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
      ? performance
      : Date
  const warned = new Set()
  /* c8 ignore start */
  const PROCESS = typeof process === 'object' && !!process ? process : {}
  /* c8 ignore start */
  const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
      ? PROCESS.emitWarning(msg, type, code, fn)
      : console.error(`[${code}] ${type}: ${msg}`)
  }
  let AC = globalThis.AbortController
  let AS = globalThis.AbortSignal
  /* c8 ignore start */
  if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
      onabort
      _onabort = []
      reason
      aborted = false
      addEventListener(_, fn) {
        this._onabort.push(fn)
      }
    }
    //@ts-ignore
    AC = class AbortController {
      constructor() {
        warnACPolyfill()
      }
      signal = new AS()
      abort(reason) {
        if (this.signal.aborted) {
          return
        }
        //@ts-ignore
        this.signal.reason = reason
        //@ts-ignore
        this.signal.aborted = true
        //@ts-ignore
        for (const fn of this.signal._onabort) {
          fn(reason)
        }
        this.signal.onabort?.(reason)
      }
    }
    let printACPolyfillWarning =
      PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning) {
        return
      }
      printACPolyfillWarning = false
      emitWarning(
        'AbortController is not defined. If using lru-cache in ' +
          'node 14, load an AbortController polyfill from the ' +
          '`node-abort-controller` package. A minimal polyfill is ' +
          'provided for use by LRUCache.fetch(), but it should not be ' +
          'relied upon in other contexts (eg, passing it to other APIs that ' +
          'use AbortController/AbortSignal might have undesirable effects). ' +
          'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',
        'NO_ABORT_CONTROLLER',
        'ENOTSUP',
        warnACPolyfill
      )
    }
  }
  /* c8 ignore stop */
  const shouldWarn = code => !warned.has(code)
  const isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n)
  /* c8 ignore start */
  // This is a little bit ridiculous, tbh.
  // The maximum array length is 2^32-1 or thereabouts on most JS impls.
  // And well before that point, you're caching the entire world, I mean,
  // that's ~32GB of just integers for the next/prev links, plus whatever
  // else to hold that many keys and values.  Just filling the memory with
  // zeroes at init time is brutal when you get that big.
  // But why not be complete?
  // Maybe in the future, these limits will have expanded.
  const getUintArray = max =>
    !isPosInt(max)
      ? null
      : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
          ? Uint16Array
          : max <= Math.pow(2, 32)
            ? Uint32Array
            : max <= Number.MAX_SAFE_INTEGER
              ? ZeroArray
              : null
  /* c8 ignore stop */
  class ZeroArray extends Array {
    constructor(size) {
      super(size)
      this.fill(0)
    }
  }
  class Stack {
    heap
    length
    // private constructor
    static #constructing = false
    static create(max) {
      const HeapCls = getUintArray(max)
      if (!HeapCls) {
        return []
      }
      Stack.#constructing = true
      const s = new Stack(max, HeapCls)
      Stack.#constructing = false
      return s
    }
    constructor(max, HeapCls) {
      /* c8 ignore start */
      if (!Stack.#constructing) {
        throw new TypeError('instantiate Stack using Stack.create(n)')
      }
      /* c8 ignore stop */
      this.heap = new HeapCls(max)
      this.length = 0
    }
    push(n) {
      this.heap[this.length++] = n
    }
    pop() {
      return this.heap[--this.length]
    }
  }
  /**
   * Default export, the thing you're using this module to get.
   *
   * The `K` and `V` types define the key and value types, respectively. The
   * optional `FC` type defines the type of the `context` object passed to
   * `cache.fetch()` and `cache.memo()`.
   *
   * Keys and values **must not** be `null` or `undefined`.
   *
   * All properties from the options object (with the exception of `max`,
   * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
   * added as normal public members. (The listed options are read-only getters.)
   *
   * Changing any of these will alter the defaults for subsequent method calls.
   */
  class LRUCache {
    // options that cannot be changed without disaster
    #max
    #maxSize
    #dispose
    #onInsert
    #disposeAfter
    #fetchMethod
    #memoMethod
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort
    // computed properties
    #size
    #calculatedSize
    #keyMap
    #keyList
    #valList
    #next
    #prev
    #head
    #tail
    #free
    #disposed
    #sizes
    #starts
    #ttls
    #hasDispose
    #hasFetchMethod
    #hasDisposeAfter
    #hasOnInsert
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head
        },
        get tail() {
          return c.#tail
        },
        free: c.#free,
        // methods
        isBackgroundFetch: p => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context) =>
          c.#backgroundFetch(k, index, options, context),
        moveToTail: index => c.#moveToTail(index),
        indexes: options => c.#indexes(options),
        rindexes: options => c.#rindexes(options),
        isStale: index => c.#isStale(index)
      }
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return this.#max
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return this.#maxSize
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return this.#calculatedSize
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return this.#size
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return this.#fetchMethod
    }
    get memoMethod() {
      return this.#memoMethod
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return this.#dispose
    }
    /**
     * {@link LRUCache.OptionsBase.onInsert} (read-only)
     */
    get onInsert() {
      return this.#onInsert
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return this.#disposeAfter
    }
    constructor(options) {
      const {
        max = 0,
        ttl,
        ttlResolution = 1,
        ttlAutopurge,
        updateAgeOnGet,
        updateAgeOnHas,
        allowStale,
        dispose,
        onInsert,
        disposeAfter,
        noDisposeOnSet,
        noUpdateTTL,
        maxSize = 0,
        maxEntrySize = 0,
        sizeCalculation,
        fetchMethod,
        memoMethod,
        noDeleteOnFetchRejection,
        noDeleteOnStaleGet,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort
      } = options
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError('max option must be a nonnegative integer')
      }
      const UintArray = max ? getUintArray(max) : Array
      if (!UintArray) {
        throw new Error('invalid max value: ' + max)
      }
      this.#max = max
      this.#maxSize = maxSize
      this.maxEntrySize = maxEntrySize || this.#maxSize
      this.sizeCalculation = sizeCalculation
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError(
            'cannot set sizeCalculation without setting maxSize or maxEntrySize'
          )
        }
        if (typeof this.sizeCalculation !== 'function') {
          throw new TypeError('sizeCalculation set to non-function')
        }
      }
      if (memoMethod !== undefined && typeof memoMethod !== 'function') {
        throw new TypeError('memoMethod must be a function if defined')
      }
      this.#memoMethod = memoMethod
      if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {
        throw new TypeError('fetchMethod must be a function if specified')
      }
      this.#fetchMethod = fetchMethod
      this.#hasFetchMethod = !!fetchMethod
      this.#keyMap = new Map()
      this.#keyList = new Array(max).fill(undefined)
      this.#valList = new Array(max).fill(undefined)
      this.#next = new UintArray(max)
      this.#prev = new UintArray(max)
      this.#head = 0
      this.#tail = 0
      this.#free = Stack.create(max)
      this.#size = 0
      this.#calculatedSize = 0
      if (typeof dispose === 'function') {
        this.#dispose = dispose
      }
      if (typeof onInsert === 'function') {
        this.#onInsert = onInsert
      }
      if (typeof disposeAfter === 'function') {
        this.#disposeAfter = disposeAfter
        this.#disposed = []
      } else {
        this.#disposeAfter = undefined
        this.#disposed = undefined
      }
      this.#hasDispose = !!this.#dispose
      this.#hasOnInsert = !!this.#onInsert
      this.#hasDisposeAfter = !!this.#disposeAfter
      this.noDisposeOnSet = !!noDisposeOnSet
      this.noUpdateTTL = !!noUpdateTTL
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort
      this.ignoreFetchAbort = !!ignoreFetchAbort
      // NB: maxEntrySize is set to maxSize if it's set
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError(
              'maxSize must be a positive integer if specified'
            )
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError(
            'maxEntrySize must be a positive integer if specified'
          )
        }
        this.#initializeSizeTracking()
      }
      this.allowStale = !!allowStale
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet
      this.updateAgeOnGet = !!updateAgeOnGet
      this.updateAgeOnHas = !!updateAgeOnHas
      this.ttlResolution =
        isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1
      this.ttlAutopurge = !!ttlAutopurge
      this.ttl = ttl || 0
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError('ttl must be a positive integer if specified')
        }
        this.#initializeTTLTracking()
      }
      // do not allow completely unbounded caches
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError('At least one of max, maxSize, or ttl is required')
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = 'LRU_CACHE_UNBOUNDED'
        if (shouldWarn(code)) {
          warned.add(code)
          const msg =
            'TTL caching without ttlAutopurge, max, or maxSize can ' +
            'result in unbounded memory consumption.'
          emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)
        }
      }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max)
      const starts = new ZeroArray(this.#max)
      this.#ttls = ttls
      this.#starts = starts
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0
        ttls[index] = ttl
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], 'expire')
            }
          }, ttl + 1)
          // unref() not supported on all platforms
          /* c8 ignore start */
          if (t.unref) {
            t.unref()
          }
          /* c8 ignore stop */
        }
      }
      this.#updateItemAge = index => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0
      }
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index]
          const start = starts[index]
          /* c8 ignore next */
          if (!ttl || !start) {
            return
          }
          status.ttl = ttl
          status.start = start
          status.now = cachedNow || getNow()
          const age = status.now - start
          status.remainingTTL = ttl - age
        }
      }
      // debounce calls to perf.now() to 1s so we're not hitting
      // that costly call repeatedly.
      let cachedNow = 0
      const getNow = () => {
        const n = perf.now()
        if (this.ttlResolution > 0) {
          cachedNow = n
          const t = setTimeout(() => (cachedNow = 0), this.ttlResolution)
          // not available on all platforms
          /* c8 ignore start */
          if (t.unref) {
            t.unref()
          }
          /* c8 ignore stop */
        }
        return n
      }
      this.getRemainingTTL = key => {
        const index = this.#keyMap.get(key)
        if (index === undefined) {
          return 0
        }
        const ttl = ttls[index]
        const start = starts[index]
        if (!ttl || !start) {
          return Infinity
        }
        const age = (cachedNow || getNow()) - start
        return ttl - age
      }
      this.#isStale = index => {
        const s = starts[index]
        const t = ttls[index]
        return !!t && !!s && (cachedNow || getNow()) - s > t
      }
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => {}
    #statusTTL = () => {}
    #setItemTTL = () => {}
    /* c8 ignore stop */
    #isStale = () => false
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max)
      this.#calculatedSize = 0
      this.#sizes = sizes
      this.#removeItemSize = index => {
        this.#calculatedSize -= sizes[index]
        sizes[index] = 0
      }
      this.#requireSize = (k, v, size, sizeCalculation) => {
        // provisionally accept background fetches.
        // actual value size will be checked when they return.
        if (this.#isBackgroundFetch(v)) {
          return 0
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== 'function') {
              throw new TypeError('sizeCalculation must be a function')
            }
            size = sizeCalculation(v, k)
            if (!isPosInt(size)) {
              throw new TypeError(
                'sizeCalculation return invalid (expect positive integer)'
              )
            }
          } else {
            throw new TypeError(
              'invalid size value (must be positive integer). ' +
                'When maxSize or maxEntrySize is used, sizeCalculation ' +
                'or size must be set.'
            )
          }
        }
        return size
      }
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index]
          while (this.#calculatedSize > maxSize) {
            this.#evict(true)
          }
        }
        this.#calculatedSize += sizes[index]
        if (status) {
          status.entrySize = size
          status.totalCalculatedSize = this.#calculatedSize
        }
      }
    }
    #removeItemSize = _i => {}
    #addItemSize = (_i, _s, _st) => {}
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError(
          'cannot set size without setting maxSize or maxEntrySize on cache'
        )
      }
      return 0
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail; true; ) {
          if (!this.#isValidIndex(i)) {
            break
          }
          if (allowStale || !this.#isStale(i)) {
            yield i
          }
          if (i === this.#head) {
            break
          } else {
            i = this.#prev[i]
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head; true; ) {
          if (!this.#isValidIndex(i)) {
            break
          }
          if (allowStale || !this.#isStale(i)) {
            yield i
          }
          if (i === this.#tail) {
            break
          } else {
            i = this.#next[i]
          }
        }
      }
    }
    #isValidIndex(index) {
      return (
        index !== undefined && this.#keyMap.get(this.#keyList[index]) === index
      )
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of this.#indexes()) {
        if (
          this.#valList[i] !== undefined &&
          this.#keyList[i] !== undefined &&
          !this.#isBackgroundFetch(this.#valList[i])
        ) {
          yield [this.#keyList[i], this.#valList[i]]
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of this.#rindexes()) {
        if (
          this.#valList[i] !== undefined &&
          this.#keyList[i] !== undefined &&
          !this.#isBackgroundFetch(this.#valList[i])
        ) {
          yield [this.#keyList[i], this.#valList[i]]
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i]
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i]
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i]
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i]
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i]
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i]
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
      return this.entries()
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache'
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined) {
          continue
        }
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions)
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined) {
          continue
        }
        fn.call(thisp, value, this.#keyList[i], this)
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined) {
          continue
        }
        fn.call(thisp, value, this.#keyList[i], this)
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false
      for (const i of this.#rindexes({
        allowStale: true
      })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], 'expire')
          deleted = true
        }
      }
      return deleted
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
      const i = this.#keyMap.get(key)
      if (i === undefined) {
        return undefined
      }
      const v = this.#valList[i]
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
      if (value === undefined) {
        return undefined
      }
      const entry = {
        value
      }
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i]
        const start = this.#starts[i]
        if (ttl && start) {
          const remain = ttl - (perf.now() - start)
          entry.ttl = remain
          entry.start = Date.now()
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i]
      }
      return entry
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
      const arr = []
      for (const i of this.#indexes({
        allowStale: true
      })) {
        const key = this.#keyList[i]
        const v = this.#valList[i]
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
        if (value === undefined || key === undefined) {
          continue
        }
        const entry = {
          value
        }
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i]
          // always dump the start relative to a portable timestamp
          // it's ok for this to be a bit slow, it's a rare operation.
          const age = perf.now() - this.#starts[i]
          entry.start = Math.floor(Date.now() - age)
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i]
        }
        arr.unshift([key, entry])
      }
      return arr
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
      this.clear()
      for (const [key, entry] of arr) {
        if (entry.start) {
          // entry.start is a portable timestamp, but we may be using
          // node's performance.now(), so calculate the offset, so that
          // we get the intended remaining TTL, no matter how long it's
          // been on ice.
          //
          // it's ok for this to be a bit slow, it's a rare operation.
          const age = Date.now() - entry.start
          entry.start = perf.now() - age
        }
        this.set(key, entry.value, entry)
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
      if (v === undefined) {
        this.delete(k)
        return this
      }
      const {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        sizeCalculation = this.sizeCalculation,
        status
      } = setOptions
      let { noUpdateTTL = this.noUpdateTTL } = setOptions
      const size = this.#requireSize(
        k,
        v,
        setOptions.size || 0,
        sizeCalculation
      )
      // if the item doesn't fit, don't do anything
      // NB: maxEntrySize set to maxSize by default
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = 'miss'
          status.maxEntrySizeExceeded = true
        }
        // have to delete, in case something is there already.
        this.#delete(k, 'set')
        return this
      }
      let index = this.#size === 0 ? undefined : this.#keyMap.get(k)
      if (index === undefined) {
        // addition
        index =
          this.#size === 0
            ? this.#tail
            : this.#free.length !== 0
              ? this.#free.pop()
              : this.#size === this.#max
                ? this.#evict(false)
                : this.#size
        this.#keyList[index] = k
        this.#valList[index] = v
        this.#keyMap.set(k, index)
        this.#next[this.#tail] = index
        this.#prev[index] = this.#tail
        this.#tail = index
        this.#size++
        this.#addItemSize(index, size, status)
        if (status) {
          status.set = 'add'
        }
        noUpdateTTL = false
        if (this.#hasOnInsert) {
          this.#onInsert?.(v, k, 'add')
        }
      } else {
        // update
        this.#moveToTail(index)
        const oldVal = this.#valList[index]
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error('replaced'))
            const { __staleWhileFetching: s } = oldVal
            if (s !== undefined && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s, k, 'set')
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s, k, 'set'])
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, 'set')
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, 'set'])
            }
          }
          this.#removeItemSize(index)
          this.#addItemSize(index, size, status)
          this.#valList[index] = v
          if (status) {
            status.set = 'replace'
            const oldValue =
              oldVal && this.#isBackgroundFetch(oldVal)
                ? oldVal.__staleWhileFetching
                : oldVal
            if (oldValue !== undefined) {
              status.oldValue = oldValue
            }
          }
        } else if (status) {
          status.set = 'update'
        }
        if (this.#hasOnInsert) {
          this.onInsert?.(v, k, v === oldVal ? 'update' : 'replace')
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking()
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start)
        }
        if (status) {
          this.#statusTTL(status, index)
        }
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed
        let task
        while ((task = dt?.shift())) {
          this.#disposeAfter?.(...task)
        }
      }
      return this
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head]
          this.#evict(true)
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching
            }
          } else if (val !== undefined) {
            return val
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed
          let task
          while ((task = dt?.shift())) {
            this.#disposeAfter?.(...task)
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head
      const k = this.#keyList[head]
      const v = this.#valList[head]
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error('evicted'))
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, 'evict')
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, 'evict'])
        }
      }
      this.#removeItemSize(head)
      // if we aren't about to use the index, then null these out
      if (free) {
        this.#keyList[head] = undefined
        this.#valList[head] = undefined
        this.#free.push(head)
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0
        this.#free.length = 0
      } else {
        this.#head = this.#next[head]
      }
      this.#keyMap.delete(k)
      this.#size--
      return head
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions
      const index = this.#keyMap.get(k)
      if (index !== undefined) {
        const v = this.#valList[index]
        if (
          this.#isBackgroundFetch(v) &&
          v.__staleWhileFetching === undefined
        ) {
          return false
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index)
          }
          if (status) {
            status.has = 'hit'
            this.#statusTTL(status, index)
          }
          return true
        } else if (status) {
          status.has = 'stale'
          this.#statusTTL(status, index)
        }
      } else if (status) {
        status.has = 'miss'
      }
      return false
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions
      const index = this.#keyMap.get(k)
      if (index === undefined || (!allowStale && this.#isStale(index))) {
        return
      }
      const v = this.#valList[index]
      // either stale and allowed, or forcing a refresh of non-stale value
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v
    }
    #backgroundFetch(k, index, options, context) {
      const v = index === undefined ? undefined : this.#valList[index]
      if (this.#isBackgroundFetch(v)) {
        return v
      }
      const ac = new AC()
      const { signal } = options
      // when/if our AC signals, then stop listening to theirs.
      signal?.addEventListener('abort', () => ac.abort(signal.reason), {
        signal: ac.signal
      })
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      }
      const cb = (v, updateCache = false) => {
        const { aborted } = ac.signal
        const ignoreAbort = options.ignoreFetchAbort && v !== undefined
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true
            options.status.fetchError = ac.signal.reason
            if (ignoreAbort) {
              options.status.fetchAbortIgnored = true
            }
          } else {
            options.status.fetchResolved = true
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason)
        }
        // either we didn't abort, and are still here, or we did, and ignored
        const bf = p
        if (this.#valList[index] === p) {
          if (v === undefined) {
            if (bf.__staleWhileFetching) {
              this.#valList[index] = bf.__staleWhileFetching
            } else {
              this.#delete(k, 'fetch')
            }
          } else {
            if (options.status) {
              options.status.fetchUpdated = true
            }
            this.set(k, v, fetchOpts.options)
          }
        }
        return v
      }
      const eb = er => {
        if (options.status) {
          options.status.fetchRejected = true
          options.status.fetchError = er
        }
        return fetchFail(er)
      }
      const fetchFail = er => {
        const { aborted } = ac.signal
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort
        const allowStale =
          allowStaleAborted || options.allowStaleOnFetchRejection
        const noDelete = allowStale || options.noDeleteOnFetchRejection
        const bf = p
        if (this.#valList[index] === p) {
          // if we allow stale on fetch rejections, then we need to ensure that
          // the stale value is not removed from the cache when the fetch fails.
          const del = !noDelete || bf.__staleWhileFetching === undefined
          if (del) {
            this.#delete(k, 'fetch')
          } else if (!allowStaleAborted) {
            // still replace the *promise* with the stale value,
            // since we are done with the promise at this point.
            // leave it untouched if we're still waiting for an
            // aborted background fetch that hasn't yet returned.
            this.#valList[index] = bf.__staleWhileFetching
          }
        }
        if (allowStale) {
          if (options.status && bf.__staleWhileFetching !== undefined) {
            options.status.returnedStale = true
          }
          return bf.__staleWhileFetching
        } else if (bf.__returned === bf) {
          throw er
        }
      }
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts)
        if (fmp && fmp instanceof Promise) {
          fmp.then(v => res(v === undefined ? undefined : v), rej)
        }
        // ignored, we go until we finish, regardless.
        // defer check until we are actually aborting,
        // so fetchMethod can override.
        ac.signal.addEventListener('abort', () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(undefined)
            // when it eventually resolves, update the cache.
            if (options.allowStaleOnFetchAbort) {
              res = v => cb(v, true)
            }
          }
        })
      }
      if (options.status) {
        options.status.fetchDispatched = true
      }
      const p = new Promise(pcall).then(cb, eb)
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: undefined
      })
      if (index === undefined) {
        // internal, don't expose status.
        this.set(k, bf, {
          ...fetchOpts.options,
          status: undefined
        })
        index = this.#keyMap.get(k)
      } else {
        this.#valList[index] = bf
      }
      return bf
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod) {
        return false
      }
      const b = p
      return (
        !!b &&
        b instanceof Promise &&
        b.hasOwnProperty('__staleWhileFetching') &&
        b.__abortController instanceof AC
      )
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions
      if (!this.#hasFetchMethod) {
        if (status) {
          status.fetch = 'get'
        }
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        })
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      }
      let index = this.#keyMap.get(k)
      if (index === undefined) {
        if (status) {
          status.fetch = 'miss'
        }
        const p = this.#backgroundFetch(k, index, options, context)
        return (p.__returned = p)
      } else {
        // in cache, maybe already fetching
        const v = this.#valList[index]
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined
          if (status) {
            status.fetch = 'inflight'
            if (stale) {
              status.returnedStale = true
            }
          }
          return stale ? v.__staleWhileFetching : (v.__returned = v)
        }
        // if we force a refresh, that means do NOT serve the cached value,
        // unless we are already in the process of refreshing the cache.
        const isStale = this.#isStale(index)
        if (!forceRefresh && !isStale) {
          if (status) {
            status.fetch = 'hit'
          }
          this.#moveToTail(index)
          if (updateAgeOnGet) {
            this.#updateItemAge(index)
          }
          if (status) {
            this.#statusTTL(status, index)
          }
          return v
        }
        // ok, it is stale or a forced refresh, and not already fetching.
        // refresh the cache.
        const p = this.#backgroundFetch(k, index, options, context)
        const hasStale = p.__staleWhileFetching !== undefined
        const staleVal = hasStale && allowStale
        if (status) {
          status.fetch = isStale ? 'stale' : 'refresh'
          if (staleVal && isStale) {
            status.returnedStale = true
          }
        }
        return staleVal ? p.__staleWhileFetching : (p.__returned = p)
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions)
      if (v === undefined) {
        throw new Error('fetch() returned undefined')
      }
      return v
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod
      if (!memoMethod) {
        throw new Error('no memoMethod provided to constructor')
      }
      const { context, forceRefresh, ...options } = memoOptions
      const v = this.get(k, options)
      if (!forceRefresh && v !== undefined) {
        return v
      }
      const vv = memoMethod(k, v, {
        options,
        context
      })
      this.set(k, vv, options)
      return vv
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        status
      } = getOptions
      const index = this.#keyMap.get(k)
      if (index !== undefined) {
        const value = this.#valList[index]
        const fetching = this.#isBackgroundFetch(value)
        if (status) {
          this.#statusTTL(status, index)
        }
        if (this.#isStale(index)) {
          if (status) {
            status.get = 'stale'
          }
          // delete only if not an in-flight background fetch
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, 'expire')
            }
            if (status && allowStale) {
              status.returnedStale = true
            }
            return allowStale ? value : undefined
          } else {
            if (
              status &&
              allowStale &&
              value.__staleWhileFetching !== undefined
            ) {
              status.returnedStale = true
            }
            return allowStale ? value.__staleWhileFetching : undefined
          }
        } else {
          if (status) {
            status.get = 'hit'
          }
          // if we're currently fetching it, we don't actually have it yet
          // it's not stale, which means this isn't a staleWhileRefetching.
          // If it's not stale, and fetching, AND has a __staleWhileFetching
          // value, then that means the user fetched with {forceRefresh:true},
          // so it's safe to return that value.
          if (fetching) {
            return value.__staleWhileFetching
          }
          this.#moveToTail(index)
          if (updateAgeOnGet) {
            this.#updateItemAge(index)
          }
          return value
        }
      } else if (status) {
        status.get = 'miss'
      }
    }
    #connect(p, n) {
      this.#prev[n] = p
      this.#next[p] = n
    }
    #moveToTail(index) {
      // if tail already, nothing to do
      // if head, move head to next[index]
      // else
      //   move next[prev[index]] to next[index] (head has no prev)
      //   move prev[next[index]] to prev[index]
      // prev[index] = tail
      // next[tail] = index
      // tail = index
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index]
        } else {
          this.#connect(this.#prev[index], this.#next[index])
        }
        this.#connect(this.#tail, index)
        this.#tail = index
      }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      return this.#delete(k, 'delete')
    }
    #delete(k, reason) {
      let deleted = false
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k)
        if (index !== undefined) {
          deleted = true
          if (this.#size === 1) {
            this.#clear(reason)
          } else {
            this.#removeItemSize(index)
            const v = this.#valList[index]
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error('deleted'))
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason)
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason])
              }
            }
            this.#keyMap.delete(k)
            this.#keyList[index] = undefined
            this.#valList[index] = undefined
            if (index === this.#tail) {
              this.#tail = this.#prev[index]
            } else if (index === this.#head) {
              this.#head = this.#next[index]
            } else {
              const pi = this.#prev[index]
              this.#next[pi] = this.#next[index]
              const ni = this.#next[index]
              this.#prev[ni] = this.#prev[index]
            }
            this.#size--
            this.#free.push(index)
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed
        let task
        while ((task = dt?.shift())) {
          this.#disposeAfter?.(...task)
        }
      }
      return deleted
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      return this.#clear('delete')
    }
    #clear(reason) {
      for (const index of this.#rindexes({
        allowStale: true
      })) {
        const v = this.#valList[index]
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error('deleted'))
        } else {
          const k = this.#keyList[index]
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason)
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason])
          }
        }
      }
      this.#keyMap.clear()
      this.#valList.fill(undefined)
      this.#keyList.fill(undefined)
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0)
        this.#starts.fill(0)
      }
      if (this.#sizes) {
        this.#sizes.fill(0)
      }
      this.#head = 0
      this.#tail = 0
      this.#free.length = 0
      this.#calculatedSize = 0
      this.#size = 0
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed
        let task
        while ((task = dt?.shift())) {
          this.#disposeAfter?.(...task)
        }
      }
    }
  }
  commonjs.LRUCache = LRUCache
  return commonjs
}

/* eslint-disable max-len */
let hosts_1
let hasRequiredHosts
function requireHosts() {
  if (hasRequiredHosts) {
    return hosts_1
  }
  hasRequiredHosts = 1
  const maybeJoin = (...args) => (args.every(arg => arg) ? args.join('') : '')
  const maybeEncode = arg => (arg ? encodeURIComponent(arg) : '')
  const formatHashFragment = f =>
    f
      .toLowerCase()
      .replace(/^\W+/g, '') // strip leading non-characters
      .replace(/(?<!\W)\W+$/, '') // strip trailing non-characters
      .replace(/\//g, '') // strip all slashes
      .replace(/\W+/g, '-') // replace remaining non-characters with '-'

  const defaults = {
    sshtemplate: ({ domain, user, project, committish }) =>
      `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,
    sshurltemplate: ({ domain, user, project, committish }) =>
      `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    edittemplate: ({ domain, user, project, committish, editpath, path }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,
    browsetemplate: ({ domain, user, project, committish, treepath }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,
    browsetreetemplate: ({
      domain,
      user,
      project,
      committish,
      treepath,
      path,
      fragment,
      hashformat
    }) =>
      `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
    browseblobtemplate: ({
      domain,
      user,
      project,
      committish,
      blobpath,
      path,
      fragment,
      hashformat
    }) =>
      `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
    docstemplate: ({ domain, user, project, treepath, committish }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,
    httpstemplate: ({ auth, domain, user, project, committish }) =>
      `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    filetemplate: ({ domain, user, project, committish, path }) =>
      `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,
    shortcuttemplate: ({ type, user, project, committish }) =>
      `${type}:${user}/${project}${maybeJoin('#', committish)}`,
    pathtemplate: ({ user, project, committish }) =>
      `${user}/${project}${maybeJoin('#', committish)}`,
    bugstemplate: ({ domain, user, project }) =>
      `https://${domain}/${user}/${project}/issues`,
    hashformat: formatHashFragment
  }
  const hosts = {}
  hosts.github = {
    // First two are insecure and generally shouldn't be used any more, but
    // they are still supported.
    protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'github.com',
    treepath: 'tree',
    blobpath: 'blob',
    editpath: 'edit',
    filetemplate: ({ auth, user, project, committish, path }) =>
      `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,
    gittemplate: ({ auth, domain, user, project, committish }) =>
      `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
    extract: url => {
      let [, user, project, type, committish] = url.pathname.split('/', 5)
      if (type && type !== 'tree') {
        return
      }
      if (!type) {
        committish = url.hash.slice(1)
      }
      if (project && project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish
      }
    }
  }
  hosts.bitbucket = {
    protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'bitbucket.org',
    treepath: 'src',
    blobpath: 'src',
    editpath: '?mode=edit',
    edittemplate: ({
      domain,
      user,
      project,
      committish,
      treepath,
      path,
      editpath
    }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,
    extract: url => {
      let [, user, project, aux] = url.pathname.split('/', 4)
      if (['get'].includes(aux)) {
        return
      }
      if (project && project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    }
  }
  hosts.gitlab = {
    protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'gitlab.com',
    treepath: 'tree',
    blobpath: 'tree',
    editpath: '-/edit',
    httpstemplate: ({ auth, domain, user, project, committish }) =>
      `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,
    extract: url => {
      const path = url.pathname.slice(1)
      if (path.includes('/-/') || path.includes('/archive.tar.gz')) {
        return
      }
      const segments = path.split('/')
      let project = segments.pop()
      if (project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      const user = segments.join('/')
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    }
  }
  hosts.gist = {
    protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
    domain: 'gist.github.com',
    editpath: 'edit',
    sshtemplate: ({ domain, project, committish }) =>
      `git@${domain}:${project}.git${maybeJoin('#', committish)}`,
    sshurltemplate: ({ domain, project, committish }) =>
      `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,
    edittemplate: ({ domain, user, project, committish, editpath }) =>
      `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,
    browsetemplate: ({ domain, project, committish }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
    browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
    browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
    docstemplate: ({ domain, project, committish }) =>
      `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
    httpstemplate: ({ domain, project, committish }) =>
      `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,
    filetemplate: ({ user, project, committish, path }) =>
      `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,
    shortcuttemplate: ({ type, project, committish }) =>
      `${type}:${project}${maybeJoin('#', committish)}`,
    pathtemplate: ({ project, committish }) =>
      `${project}${maybeJoin('#', committish)}`,
    bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
    gittemplate: ({ domain, project, committish }) =>
      `git://${domain}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ project, committish }) =>
      `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
    extract: url => {
      let [, user, project, aux] = url.pathname.split('/', 4)
      if (aux === 'raw') {
        return
      }
      if (!project) {
        if (!user) {
          return
        }
        project = user
        user = null
      }
      if (project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    },
    hashformat: function (fragment) {
      return fragment && 'file-' + formatHashFragment(fragment)
    }
  }
  hosts.sourcehut = {
    protocols: ['git+ssh:', 'https:'],
    domain: 'git.sr.ht',
    treepath: 'tree',
    blobpath: 'tree',
    filetemplate: ({ domain, user, project, committish, path }) =>
      `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,
    httpstemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
    tarballtemplate: ({ domain, user, project, committish }) =>
      `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,
    bugstemplate: () => null,
    extract: url => {
      let [, user, project, aux] = url.pathname.split('/', 4)

      // tarball url
      if (['archive'].includes(aux)) {
        return
      }
      if (project && project.endsWith('.git')) {
        project = project.slice(0, -4)
      }
      if (!user || !project) {
        return
      }
      return {
        user,
        project,
        committish: url.hash.slice(1)
      }
    }
  }
  for (const [name, host] of Object.entries(hosts)) {
    hosts[name] = Object.assign({}, defaults, host)
  }
  hosts_1 = hosts
  return hosts_1
}

let parseUrl
let hasRequiredParseUrl
function requireParseUrl() {
  if (hasRequiredParseUrl) {
    return parseUrl
  }
  hasRequiredParseUrl = 1
  const url = require$$0
  const lastIndexOfBefore = (str, char, beforeChar) => {
    const startPosition = str.indexOf(beforeChar)
    return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)
  }
  const safeUrl = u => {
    try {
      return new url.URL(u)
    } catch {
      // this fn should never throw
    }
  }

  // accepts input like git:github.com:user/repo and inserts the // after the first :
  const correctProtocol = (arg, protocols) => {
    const firstColon = arg.indexOf(':')
    const proto = arg.slice(0, firstColon + 1)
    if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
      return arg
    }
    const firstAt = arg.indexOf('@')
    if (firstAt > -1) {
      if (firstAt > firstColon) {
        return `git+ssh://${arg}`
      } else {
        return arg
      }
    }
    const doubleSlash = arg.indexOf('//')
    if (doubleSlash === firstColon + 1) {
      return arg
    }
    return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`
  }

  // attempt to correct an scp style url so that it will parse with `new URL()`
  const correctUrl = giturl => {
    // ignore @ that come after the first hash since the denotes the start
    // of a committish which can contain @ characters
    const firstAt = lastIndexOfBefore(giturl, '@', '#')
    // ignore colons that come after the hash since that could include colons such as:
    // git@github.com:user/package-2#semver:^1.0.0
    const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#')
    if (lastColonBeforeHash > firstAt) {
      // the last : comes after the first @ (or there is no @)
      // like it would in:
      // proto://hostname.com:user/repo
      // username@hostname.com:user/repo
      // :password@hostname.com:user/repo
      // username:password@hostname.com:user/repo
      // proto://username@hostname.com:user/repo
      // proto://:password@hostname.com:user/repo
      // proto://username:password@hostname.com:user/repo
      // then we replace the last : with a / to create a valid path
      giturl =
        giturl.slice(0, lastColonBeforeHash) +
        '/' +
        giturl.slice(lastColonBeforeHash + 1)
    }
    if (
      lastIndexOfBefore(giturl, ':', '#') === -1 &&
      giturl.indexOf('//') === -1
    ) {
      // we have no : at all
      // as it would be in:
      // username@hostname.com/user/repo
      // then we prepend a protocol
      giturl = `git+ssh://${giturl}`
    }
    return giturl
  }
  parseUrl = (giturl, protocols) => {
    const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl
    return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))
  }
  return parseUrl
}

let fromUrl
let hasRequiredFromUrl
function requireFromUrl() {
  if (hasRequiredFromUrl) {
    return fromUrl
  }
  hasRequiredFromUrl = 1
  const parseUrl = requireParseUrl()

  // look for github shorthand inputs, such as npm/cli
  const isGitHubShorthand = arg => {
    // it cannot contain whitespace before the first #
    // it cannot start with a / because that's probably an absolute file path
    // but it must include a slash since repos are username/repository
    // it cannot start with a . because that's probably a relative file path
    // it cannot start with an @ because that's a scoped package if it passes the other tests
    // it cannot contain a : before a # because that tells us that there's a protocol
    // a second / may not exist before a #
    const firstHash = arg.indexOf('#')
    const firstSlash = arg.indexOf('/')
    const secondSlash = arg.indexOf('/', firstSlash + 1)
    const firstColon = arg.indexOf(':')
    const firstSpace = /\s/.exec(arg)
    const firstAt = arg.indexOf('@')
    const spaceOnlyAfterHash =
      !firstSpace || (firstHash > -1 && firstSpace.index > firstHash)
    const atOnlyAfterHash =
      firstAt === -1 || (firstHash > -1 && firstAt > firstHash)
    const colonOnlyAfterHash =
      firstColon === -1 || (firstHash > -1 && firstColon > firstHash)
    const secondSlashOnlyAfterHash =
      secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash)
    const hasSlash = firstSlash > 0
    // if a # is found, what we really want to know is that the character
    // immediately before # is not a /
    const doesNotEndWithSlash =
      firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/')
    const doesNotStartWithDot = !arg.startsWith('.')
    return (
      spaceOnlyAfterHash &&
      hasSlash &&
      doesNotEndWithSlash &&
      doesNotStartWithDot &&
      atOnlyAfterHash &&
      colonOnlyAfterHash &&
      secondSlashOnlyAfterHash
    )
  }
  fromUrl = (giturl, opts, { gitHosts, protocols }) => {
    if (!giturl) {
      return
    }
    const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl
    const parsed = parseUrl(correctedUrl, protocols)
    if (!parsed) {
      return
    }
    const gitHostShortcut = gitHosts.byShortcut[parsed.protocol]
    const gitHostDomain =
      gitHosts.byDomain[
        parsed.hostname.startsWith('www.')
          ? parsed.hostname.slice(4)
          : parsed.hostname
      ]
    const gitHostName = gitHostShortcut || gitHostDomain
    if (!gitHostName) {
      return
    }
    const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain]
    let auth = null
    if (
      protocols[parsed.protocol]?.auth &&
      (parsed.username || parsed.password)
    ) {
      auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`
    }
    let committish = null
    let user = null
    let project = null
    let defaultRepresentation = null
    try {
      if (gitHostShortcut) {
        let pathname = parsed.pathname.startsWith('/')
          ? parsed.pathname.slice(1)
          : parsed.pathname
        const firstAt = pathname.indexOf('@')
        // we ignore auth for shortcuts, so just trim it out
        if (firstAt > -1) {
          pathname = pathname.slice(firstAt + 1)
        }
        const lastSlash = pathname.lastIndexOf('/')
        if (lastSlash > -1) {
          user = decodeURIComponent(pathname.slice(0, lastSlash))
          // we want nulls only, never empty strings
          if (!user) {
            user = null
          }
          project = decodeURIComponent(pathname.slice(lastSlash + 1))
        } else {
          project = decodeURIComponent(pathname)
        }
        if (project.endsWith('.git')) {
          project = project.slice(0, -4)
        }
        if (parsed.hash) {
          committish = decodeURIComponent(parsed.hash.slice(1))
        }
        defaultRepresentation = 'shortcut'
      } else {
        if (!gitHostInfo.protocols.includes(parsed.protocol)) {
          return
        }
        const segments = gitHostInfo.extract(parsed)
        if (!segments) {
          return
        }
        user = segments.user && decodeURIComponent(segments.user)
        project = decodeURIComponent(segments.project)
        committish = decodeURIComponent(segments.committish)
        defaultRepresentation =
          protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1)
      }
    } catch (err) {
      /* istanbul ignore else */
      if (err instanceof URIError) {
        return
      } else {
        throw err
      }
    }
    return [
      gitHostName,
      user,
      auth,
      project,
      committish,
      defaultRepresentation,
      opts
    ]
  }
  return fromUrl
}

let lib$2
let hasRequiredLib$2
function requireLib$2() {
  if (hasRequiredLib$2) {
    return lib$2
  }
  hasRequiredLib$2 = 1
  const { LRUCache } = /*@__PURE__*/ requireCommonjs()
  const hosts = requireHosts()
  const fromUrl = requireFromUrl()
  const parseUrl = requireParseUrl()
  const cache = new LRUCache({
    max: 1000
  })
  function unknownHostedUrl(url) {
    try {
      const { protocol, hostname, pathname } = new URL(url)
      if (!hostname) {
        return null
      }
      const proto = /(?:git\+)http:$/.test(protocol) ? 'http:' : 'https:'
      const path = pathname.replace(/\.git$/, '')
      return `${proto}//${hostname}${path}`
    } catch {
      return null
    }
  }
  class GitHost {
    constructor(
      type,
      user,
      auth,
      project,
      committish,
      defaultRepresentation,
      opts = {}
    ) {
      Object.assign(this, GitHost.#gitHosts[type], {
        type,
        user,
        auth,
        project,
        committish,
        default: defaultRepresentation,
        opts
      })
    }
    static #gitHosts = {
      byShortcut: {},
      byDomain: {}
    }
    static #protocols = {
      'git+ssh:': {
        name: 'sshurl'
      },
      'ssh:': {
        name: 'sshurl'
      },
      'git+https:': {
        name: 'https',
        auth: true
      },
      'git:': {
        auth: true
      },
      'http:': {
        auth: true
      },
      'https:': {
        auth: true
      },
      'git+http:': {
        auth: true
      }
    }
    static addHost(name, host) {
      GitHost.#gitHosts[name] = host
      GitHost.#gitHosts.byDomain[host.domain] = name
      GitHost.#gitHosts.byShortcut[`${name}:`] = name
      GitHost.#protocols[`${name}:`] = {
        name
      }
    }
    static fromUrl(giturl, opts) {
      if (typeof giturl !== 'string') {
        return
      }
      const key = giturl + JSON.stringify(opts || {})
      if (!cache.has(key)) {
        const hostArgs = fromUrl(giturl, opts, {
          gitHosts: GitHost.#gitHosts,
          protocols: GitHost.#protocols
        })
        cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined)
      }
      return cache.get(key)
    }
    static fromManifest(manifest, opts = {}) {
      if (!manifest || typeof manifest !== 'object') {
        return
      }
      const r = manifest.repository
      // TODO: look into also checking the `bugs`/`homepage` URLs

      const rurl =
        r &&
        (typeof r === 'string'
          ? r
          : typeof r === 'object' && typeof r.url === 'string'
            ? r.url
            : null)
      if (!rurl) {
        throw new Error('no repository')
      }
      const info =
        (rurl && GitHost.fromUrl(rurl.replace(/^git\+/, ''), opts)) || null
      if (info) {
        return info
      }
      const unk = unknownHostedUrl(rurl)
      return GitHost.fromUrl(unk, opts) || unk
    }
    static parseUrl(url) {
      return parseUrl(url)
    }
    #fill(template, opts) {
      if (typeof template !== 'function') {
        return null
      }
      const options = {
        ...this,
        ...this.opts,
        ...opts
      }

      // the path should always be set so we don't end up with 'undefined' in urls
      if (!options.path) {
        options.path = ''
      }

      // template functions will insert the leading slash themselves
      if (options.path.startsWith('/')) {
        options.path = options.path.slice(1)
      }
      if (options.noCommittish) {
        options.committish = null
      }
      const result = template(options)
      return options.noGitPlus && result.startsWith('git+')
        ? result.slice(4)
        : result
    }
    hash() {
      return this.committish ? `#${this.committish}` : ''
    }
    ssh(opts) {
      return this.#fill(this.sshtemplate, opts)
    }
    sshurl(opts) {
      return this.#fill(this.sshurltemplate, opts)
    }
    browse(path, ...args) {
      // not a string, treat path as opts
      if (typeof path !== 'string') {
        return this.#fill(this.browsetemplate, path)
      }
      if (typeof args[0] !== 'string') {
        return this.#fill(this.browsetreetemplate, {
          ...args[0],
          path
        })
      }
      return this.#fill(this.browsetreetemplate, {
        ...args[1],
        fragment: args[0],
        path
      })
    }

    // If the path is known to be a file, then browseFile should be used. For some hosts
    // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
    // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
    // path will redirect to a specific commit. Using the `/blob/` path avoids this and
    // does not redirect to a different commit.
    browseFile(path, ...args) {
      if (typeof args[0] !== 'string') {
        return this.#fill(this.browseblobtemplate, {
          ...args[0],
          path
        })
      }
      return this.#fill(this.browseblobtemplate, {
        ...args[1],
        fragment: args[0],
        path
      })
    }
    docs(opts) {
      return this.#fill(this.docstemplate, opts)
    }
    bugs(opts) {
      return this.#fill(this.bugstemplate, opts)
    }
    https(opts) {
      return this.#fill(this.httpstemplate, opts)
    }
    git(opts) {
      return this.#fill(this.gittemplate, opts)
    }
    shortcut(opts) {
      return this.#fill(this.shortcuttemplate, opts)
    }
    path(opts) {
      return this.#fill(this.pathtemplate, opts)
    }
    tarball(opts) {
      return this.#fill(this.tarballtemplate, {
        ...opts,
        noCommittish: false
      })
    }
    file(path, opts) {
      return this.#fill(this.filetemplate, {
        ...opts,
        path
      })
    }
    edit(path, opts) {
      return this.#fill(this.edittemplate, {
        ...opts,
        path
      })
    }
    getDefaultRepresentation() {
      return this.default
    }
    toString(opts) {
      if (this.default && typeof this[this.default] === 'function') {
        return this[this.default](opts)
      }
      return this.sshurl(opts)
    }
  }
  for (const [name, host] of Object.entries(hosts)) {
    GitHost.addHost(name, host)
  }
  lib$2 = GitHost
  return lib$2
}

const re = { exports: {} }

let constants
let hasRequiredConstants
function requireConstants() {
  if (hasRequiredConstants) {
    return constants
  }
  hasRequiredConstants = 1

  // Note: this is the semver.org version of the spec that it implements
  // Not necessarily the package version of this code.
  const SEMVER_SPEC_VERSION = '2.0.0'
  const MAX_LENGTH = 256
  const MAX_SAFE_INTEGER =
    Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991

  // Max safe segment length for coercion.
  const MAX_SAFE_COMPONENT_LENGTH = 16

  // Max safe length for a build identifier. The max length minus 6 characters for
  // the shortest version with a build 0.0.0+BUILD.
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6
  const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
  ]
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
  }
  return constants
}

let debug_1
let hasRequiredDebug
function requireDebug() {
  if (hasRequiredDebug) {
    return debug_1
  }
  hasRequiredDebug = 1
  const debug =
    typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...args) => console.error('SEMVER', ...args)
      : () => {}
  debug_1 = debug
  return debug_1
}

let hasRequiredRe
function requireRe() {
  if (hasRequiredRe) {
    return re.exports
  }
  hasRequiredRe = 1
  ;(function (module, exports) {
    const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } =
      requireConstants()
    const debug = requireDebug()
    exports = module.exports = {}

    // The actual regexps go on exports.re
    const re = (exports.re = [])
    const safeRe = (exports.safeRe = [])
    const src = (exports.src = [])
    const safeSrc = (exports.safeSrc = [])
    const t = (exports.t = {})
    let R = 0
    const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

    // Replace some greedy regex tokens to prevent regex dos issues. These regex are
    // used internally via the safeRe object since all inputs in this library get
    // normalized first to trim and collapse all extra whitespace. The original
    // regexes are exported for userland consumption and lower level usage. A
    // future breaking change could export the safer regex only with a note that
    // all input should have extra whitespace removed.
    const safeRegexReplacements = [
      ['\\s', 1],
      ['\\d', MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ]
    const makeSafeRegex = value => {
      for (const [token, max] of safeRegexReplacements) {
        value = value
          .split(`${token}*`)
          .join(`${token}{0,${max}}`)
          .split(`${token}+`)
          .join(`${token}{1,${max}}`)
      }
      return value
    }
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value)
      const index = R++
      debug(name, index, value)
      t[name] = index
      src[index] = value
      safeSrc[index] = safe
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
      safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
    }

    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.

    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
    createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

    // ## Main Version
    // Three dot-separated numeric identifiers.

    createToken(
      'MAINVERSION',
      `(${src[t.NUMERICIDENTIFIER]})\\.` +
        `(${src[t.NUMERICIDENTIFIER]})\\.` +
        `(${src[t.NUMERICIDENTIFIER]})`
    )
    createToken(
      'MAINVERSIONLOOSE',
      `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
        `(${src[t.NUMERICIDENTIFIERLOOSE]})`
    )

    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.
    // Non-numberic identifiers include numberic identifiers but can be longer.
    // Therefore non-numberic identifiers must go first.

    createToken(
      'PRERELEASEIDENTIFIER',
      `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`
    )
    createToken(
      'PRERELEASEIDENTIFIERLOOSE',
      `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`
    )

    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    createToken(
      'PRERELEASE',
      `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`
    )
    createToken(
      'PRERELEASELOOSE',
      `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`
    )

    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    createToken(
      'BUILD',
      `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`
    )

    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.

    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    createToken(
      'FULLPLAIN',
      `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`
    )
    createToken('FULL', `^${src[t.FULLPLAIN]}$`)

    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    createToken(
      'LOOSEPLAIN',
      `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`
    )
    createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)
    createToken('GTLT', '((?:<|>)?=?)')

    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    createToken(
      'XRANGEIDENTIFIERLOOSE',
      `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`
    )
    createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)
    createToken(
      'XRANGEPLAIN',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
        `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` +
        `)?)?`
    )
    createToken(
      'XRANGEPLAINLOOSE',
      `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
        `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` +
        `)?)?`
    )
    createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
    createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

    // Coercion.
    // Extract anything that could conceivably be a part of a valid semver
    createToken(
      'COERCEPLAIN',
      `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
        `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
        `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`
    )
    createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
    createToken(
      'COERCEFULL',
      src[t.COERCEPLAIN] +
        `(?:${src[t.PRERELEASE]})?` +
        `(?:${src[t.BUILD]})?` +
        `(?:$|[^\\d])`
    )
    createToken('COERCERTL', src[t.COERCE], true)
    createToken('COERCERTLFULL', src[t.COERCEFULL], true)

    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    createToken('LONETILDE', '(?:~>?)')
    createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
    exports.tildeTrimReplace = '$1~'
    createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
    createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    createToken('LONECARET', '(?:\\^)')
    createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
    exports.caretTrimReplace = '$1^'
    createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
    createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    createToken(
      'COMPARATORLOOSE',
      `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`
    )
    createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    createToken(
      'COMPARATORTRIM',
      `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,
      true
    )
    exports.comparatorTrimReplace = '$1$2$3'

    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    createToken(
      'HYPHENRANGE',
      `^\\s*(${src[t.XRANGEPLAIN]})` +
        `\\s+-\\s+` +
        `(${src[t.XRANGEPLAIN]})` +
        `\\s*$`
    )
    createToken(
      'HYPHENRANGELOOSE',
      `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
        `\\s+-\\s+` +
        `(${src[t.XRANGEPLAINLOOSE]})` +
        `\\s*$`
    )

    // Star ranges basically just allow anything at all.
    createToken('STAR', '(<|>)?=?\\s*\\*')
    // >=0.0.0 is like a star
    createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
    createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')
  })(re, re.exports)
  return re.exports
}

let parseOptions_1
let hasRequiredParseOptions
function requireParseOptions() {
  if (hasRequiredParseOptions) {
    return parseOptions_1
  }
  hasRequiredParseOptions = 1

  // parse out just the options we care about
  const looseOption = Object.freeze({
    loose: true
  })
  const emptyOpts = Object.freeze({})
  const parseOptions = options => {
    if (!options) {
      return emptyOpts
    }
    if (typeof options !== 'object') {
      return looseOption
    }
    return options
  }
  parseOptions_1 = parseOptions
  return parseOptions_1
}

let identifiers
let hasRequiredIdentifiers
function requireIdentifiers() {
  if (hasRequiredIdentifiers) {
    return identifiers
  }
  hasRequiredIdentifiers = 1
  const numeric = /^[0-9]+$/
  const compareIdentifiers = (a, b) => {
    const anum = numeric.test(a)
    const bnum = numeric.test(b)
    if (anum && bnum) {
      a = +a
      b = +b
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1
  }
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  }
  return identifiers
}

let semver$1
let hasRequiredSemver$1
function requireSemver$1() {
  if (hasRequiredSemver$1) {
    return semver$1
  }
  hasRequiredSemver$1 = 1
  const debug = requireDebug()
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants()
  const { safeRe: re, t } = requireRe()
  const parseOptions = requireParseOptions()
  const { compareIdentifiers } = requireIdentifiers()
  class SemVer {
    constructor(version, options) {
      options = parseOptions(options)
      if (version instanceof SemVer) {
        if (
          version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease
        ) {
          return version
        } else {
          version = version.version
        }
      } else if (typeof version !== 'string') {
        throw new TypeError(
          `Invalid version. Must be a string. Got type "${typeof version}".`
        )
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`)
      }
      debug('SemVer', version, options)
      this.options = options
      this.loose = !!options.loose
      // this isn't actually relevant for versions, but keep it so that we
      // don't run into trouble passing this.options around.
      this.includePrerelease = !!options.includePrerelease
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`)
      }
      this.raw = version

      // these are actually numbers
      this.major = +m[1]
      this.minor = +m[2]
      this.patch = +m[3]
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version')
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version')
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version')
      }

      // numberify any prerelease numeric ids
      if (!m[4]) {
        this.prerelease = []
      } else {
        this.prerelease = m[4].split('.').map(id => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num
            }
          }
          return id
        })
      }
      this.build = m[5] ? m[5].split('.') : []
      this.format()
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join('.')}`
      }
      return this.version
    }
    toString() {
      return this.version
    }
    compare(other) {
      debug('SemVer.compare', this.version, this.options, other)
      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0
        }
        other = new SemVer(other, this.options)
      }
      if (other.version === this.version) {
        return 0
      }
      return this.compareMain(other) || this.comparePre(other)
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options)
      }
      return (
        compareIdentifiers(this.major, other.major) ||
        compareIdentifiers(this.minor, other.minor) ||
        compareIdentifiers(this.patch, other.patch)
      )
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options)
      }

      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length) {
        return -1
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0
      }
      let i = 0
      do {
        const a = this.prerelease[i]
        const b = other.prerelease[i]
        debug('prerelease compare', i, a, b)
        if (a === undefined && b === undefined) {
          return 0
        } else if (b === undefined) {
          return 1
        } else if (a === undefined) {
          return -1
        } else if (a === b) {
          continue
        } else {
          return compareIdentifiers(a, b)
        }
      } while (++i)
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options)
      }
      let i = 0
      do {
        const a = this.build[i]
        const b = other.build[i]
        debug('build compare', i, a, b)
        if (a === undefined && b === undefined) {
          return 0
        } else if (b === undefined) {
          return 1
        } else if (a === undefined) {
          return -1
        } else if (a === b) {
          continue
        } else {
          return compareIdentifiers(a, b)
        }
      } while (++i)
    }

    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith('pre')) {
        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }
        // Avoid an invalid semver results
        if (identifier) {
          const match = `-${identifier}`.match(
            this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]
          )
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`)
          }
        }
      }
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0
          this.patch = 0
          this.minor = 0
          this.major++
          this.inc('pre', identifier, identifierBase)
          break
        case 'preminor':
          this.prerelease.length = 0
          this.patch = 0
          this.minor++
          this.inc('pre', identifier, identifierBase)
          break
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0
          this.inc('patch', identifier, identifierBase)
          this.inc('pre', identifier, identifierBase)
          break
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier, identifierBase)
          }
          this.inc('pre', identifier, identifierBase)
          break
        case 'release':
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`)
          }
          this.prerelease.length = 0
          break
        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (
            this.minor !== 0 ||
            this.patch !== 0 ||
            this.prerelease.length === 0
          ) {
            this.major++
          }
          this.minor = 0
          this.patch = 0
          this.prerelease = []
          break
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++
          }
          this.patch = 0
          this.prerelease = []
          break
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0) {
            this.patch++
          }
          this.prerelease = []
          break
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case 'pre': {
          const base = Number(identifierBase) ? 1 : 0
          if (this.prerelease.length === 0) {
            this.prerelease = [base]
          } else {
            let i = this.prerelease.length
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++
                i = -2
              }
            }
            if (i === -1) {
              // didn't increment anything
              if (
                identifier === this.prerelease.join('.') &&
                identifierBase === false
              ) {
                throw new Error(
                  'invalid increment argument: identifier already exists'
                )
              }
              this.prerelease.push(base)
            }
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            let prerelease = [identifier, base]
            if (identifierBase === false) {
              prerelease = [identifier]
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease
              }
            } else {
              this.prerelease = prerelease
            }
          }
          break
        }
        default:
          throw new Error(`invalid increment argument: ${release}`)
      }
      this.raw = this.format()
      if (this.build.length) {
        this.raw += `+${this.build.join('.')}`
      }
      return this
    }
  }
  semver$1 = SemVer
  return semver$1
}

let parse_1
let hasRequiredParse
function requireParse() {
  if (hasRequiredParse) {
    return parse_1
  }
  hasRequiredParse = 1
  const SemVer = requireSemver$1()
  const parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version
    }
    try {
      return new SemVer(version, options)
    } catch (er) {
      if (!throwErrors) {
        return null
      }
      throw er
    }
  }
  parse_1 = parse
  return parse_1
}

let valid_1
let hasRequiredValid$1
function requireValid$1() {
  if (hasRequiredValid$1) {
    return valid_1
  }
  hasRequiredValid$1 = 1
  const parse = requireParse()
  const valid = (version, options) => {
    const v = parse(version, options)
    return v ? v.version : null
  }
  valid_1 = valid
  return valid_1
}

let clean_1
let hasRequiredClean
function requireClean() {
  if (hasRequiredClean) {
    return clean_1
  }
  hasRequiredClean = 1
  const parse = requireParse()
  const clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ''), options)
    return s ? s.version : null
  }
  clean_1 = clean
  return clean_1
}

let inc_1
let hasRequiredInc
function requireInc() {
  if (hasRequiredInc) {
    return inc_1
  }
  hasRequiredInc = 1
  const SemVer = requireSemver$1()
  const inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === 'string') {
      identifierBase = identifier
      identifier = options
      options = undefined
    }
    try {
      return new SemVer(
        version instanceof SemVer ? version.version : version,
        options
      ).inc(release, identifier, identifierBase).version
    } catch (er) {
      return null
    }
  }
  inc_1 = inc
  return inc_1
}

let diff_1
let hasRequiredDiff
function requireDiff() {
  if (hasRequiredDiff) {
    return diff_1
  }
  hasRequiredDiff = 1
  const parse = requireParse()
  const diff = (version1, version2) => {
    const v1 = parse(version1, null, true)
    const v2 = parse(version2, null, true)
    const comparison = v1.compare(v2)
    if (comparison === 0) {
      return null
    }
    const v1Higher = comparison > 0
    const highVersion = v1Higher ? v1 : v2
    const lowVersion = v1Higher ? v2 : v1
    const highHasPre = !!highVersion.prerelease.length
    const lowHasPre = !!lowVersion.prerelease.length
    if (lowHasPre && !highHasPre) {
      // Going from prerelease -> no prerelease requires some special casing

      // If the low version has only a major, then it will always be a major
      // Some examples:
      // 1.0.0-1 -> 1.0.0
      // 1.0.0-1 -> 1.1.1
      // 1.0.0-1 -> 2.0.0
      if (!lowVersion.patch && !lowVersion.minor) {
        return 'major'
      }

      // If the main part has no difference
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return 'minor'
        }
        return 'patch'
      }
    }

    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? 'pre' : ''
    if (v1.major !== v2.major) {
      return prefix + 'major'
    }
    if (v1.minor !== v2.minor) {
      return prefix + 'minor'
    }
    if (v1.patch !== v2.patch) {
      return prefix + 'patch'
    }

    // high and low are preleases
    return 'prerelease'
  }
  diff_1 = diff
  return diff_1
}

let major_1
let hasRequiredMajor
function requireMajor() {
  if (hasRequiredMajor) {
    return major_1
  }
  hasRequiredMajor = 1
  const SemVer = requireSemver$1()
  const major = (a, loose) => new SemVer(a, loose).major
  major_1 = major
  return major_1
}

let minor_1
let hasRequiredMinor
function requireMinor() {
  if (hasRequiredMinor) {
    return minor_1
  }
  hasRequiredMinor = 1
  const SemVer = requireSemver$1()
  const minor = (a, loose) => new SemVer(a, loose).minor
  minor_1 = minor
  return minor_1
}

let patch_1
let hasRequiredPatch
function requirePatch() {
  if (hasRequiredPatch) {
    return patch_1
  }
  hasRequiredPatch = 1
  const SemVer = requireSemver$1()
  const patch = (a, loose) => new SemVer(a, loose).patch
  patch_1 = patch
  return patch_1
}

let prerelease_1
let hasRequiredPrerelease
function requirePrerelease() {
  if (hasRequiredPrerelease) {
    return prerelease_1
  }
  hasRequiredPrerelease = 1
  const parse = requireParse()
  const prerelease = (version, options) => {
    const parsed = parse(version, options)
    return parsed && parsed.prerelease.length ? parsed.prerelease : null
  }
  prerelease_1 = prerelease
  return prerelease_1
}

let compare_1
let hasRequiredCompare
function requireCompare() {
  if (hasRequiredCompare) {
    return compare_1
  }
  hasRequiredCompare = 1
  const SemVer = requireSemver$1()
  const compare = (a, b, loose) =>
    new SemVer(a, loose).compare(new SemVer(b, loose))
  compare_1 = compare
  return compare_1
}

let rcompare_1
let hasRequiredRcompare
function requireRcompare() {
  if (hasRequiredRcompare) {
    return rcompare_1
  }
  hasRequiredRcompare = 1
  const compare = requireCompare()
  const rcompare = (a, b, loose) => compare(b, a, loose)
  rcompare_1 = rcompare
  return rcompare_1
}

let compareLoose_1
let hasRequiredCompareLoose
function requireCompareLoose() {
  if (hasRequiredCompareLoose) {
    return compareLoose_1
  }
  hasRequiredCompareLoose = 1
  const compare = requireCompare()
  const compareLoose = (a, b) => compare(a, b, true)
  compareLoose_1 = compareLoose
  return compareLoose_1
}

let compareBuild_1
let hasRequiredCompareBuild
function requireCompareBuild() {
  if (hasRequiredCompareBuild) {
    return compareBuild_1
  }
  hasRequiredCompareBuild = 1
  const SemVer = requireSemver$1()
  const compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose)
    const versionB = new SemVer(b, loose)
    return versionA.compare(versionB) || versionA.compareBuild(versionB)
  }
  compareBuild_1 = compareBuild
  return compareBuild_1
}

let sort_1
let hasRequiredSort
function requireSort() {
  if (hasRequiredSort) {
    return sort_1
  }
  hasRequiredSort = 1
  const compareBuild = requireCompareBuild()
  const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
  sort_1 = sort
  return sort_1
}

let rsort_1
let hasRequiredRsort
function requireRsort() {
  if (hasRequiredRsort) {
    return rsort_1
  }
  hasRequiredRsort = 1
  const compareBuild = requireCompareBuild()
  const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
  rsort_1 = rsort
  return rsort_1
}

let gt_1
let hasRequiredGt
function requireGt() {
  if (hasRequiredGt) {
    return gt_1
  }
  hasRequiredGt = 1
  const compare = requireCompare()
  const gt = (a, b, loose) => compare(a, b, loose) > 0
  gt_1 = gt
  return gt_1
}

let lt_1
let hasRequiredLt
function requireLt() {
  if (hasRequiredLt) {
    return lt_1
  }
  hasRequiredLt = 1
  const compare = requireCompare()
  const lt = (a, b, loose) => compare(a, b, loose) < 0
  lt_1 = lt
  return lt_1
}

let eq_1
let hasRequiredEq
function requireEq() {
  if (hasRequiredEq) {
    return eq_1
  }
  hasRequiredEq = 1
  const compare = requireCompare()
  const eq = (a, b, loose) => compare(a, b, loose) === 0
  eq_1 = eq
  return eq_1
}

let neq_1
let hasRequiredNeq
function requireNeq() {
  if (hasRequiredNeq) {
    return neq_1
  }
  hasRequiredNeq = 1
  const compare = requireCompare()
  const neq = (a, b, loose) => compare(a, b, loose) !== 0
  neq_1 = neq
  return neq_1
}

let gte_1
let hasRequiredGte
function requireGte() {
  if (hasRequiredGte) {
    return gte_1
  }
  hasRequiredGte = 1
  const compare = requireCompare()
  const gte = (a, b, loose) => compare(a, b, loose) >= 0
  gte_1 = gte
  return gte_1
}

let lte_1
let hasRequiredLte
function requireLte() {
  if (hasRequiredLte) {
    return lte_1
  }
  hasRequiredLte = 1
  const compare = requireCompare()
  const lte = (a, b, loose) => compare(a, b, loose) <= 0
  lte_1 = lte
  return lte_1
}

let cmp_1
let hasRequiredCmp
function requireCmp() {
  if (hasRequiredCmp) {
    return cmp_1
  }
  hasRequiredCmp = 1
  const eq = requireEq()
  const neq = requireNeq()
  const gt = requireGt()
  const gte = requireGte()
  const lt = requireLt()
  const lte = requireLte()
  const cmp = (a, op, b, loose) => {
    switch (op) {
      case '===':
        if (typeof a === 'object') {
          a = a.version
        }
        if (typeof b === 'object') {
          b = b.version
        }
        return a === b
      case '!==':
        if (typeof a === 'object') {
          a = a.version
        }
        if (typeof b === 'object') {
          b = b.version
        }
        return a !== b
      case '':
      case '=':
      case '==':
        return eq(a, b, loose)
      case '!=':
        return neq(a, b, loose)
      case '>':
        return gt(a, b, loose)
      case '>=':
        return gte(a, b, loose)
      case '<':
        return lt(a, b, loose)
      case '<=':
        return lte(a, b, loose)
      default:
        throw new TypeError(`Invalid operator: ${op}`)
    }
  }
  cmp_1 = cmp
  return cmp_1
}

let coerce_1
let hasRequiredCoerce
function requireCoerce() {
  if (hasRequiredCoerce) {
    return coerce_1
  }
  hasRequiredCoerce = 1
  const SemVer = requireSemver$1()
  const parse = requireParse()
  const { safeRe: re, t } = requireRe()
  const coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version
    }
    if (typeof version === 'number') {
      version = String(version)
    }
    if (typeof version !== 'string') {
      return null
    }
    options = options || {}
    let match = null
    if (!options.rtl) {
      match = version.match(
        options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]
      )
    } else {
      // Find the right-most coercible string that does not share
      // a terminus with a more left-ward coercible string.
      // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
      // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
      //
      // Walk through the string checking with a /g regexp
      // Manually set the index so as to pick up overlapping matches.
      // Stop when we get a match that ends at the string end, since no
      // coercible string can be more right-ward without the same terminus.
      const coerceRtlRegex = options.includePrerelease
        ? re[t.COERCERTLFULL]
        : re[t.COERCERTL]
      let next
      while (
        (next = coerceRtlRegex.exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
      ) {
        if (
          !match ||
          next.index + next[0].length !== match.index + match[0].length
        ) {
          match = next
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length
      }
      // leave it in a clean state
      coerceRtlRegex.lastIndex = -1
    }
    if (match === null) {
      return null
    }
    const major = match[2]
    const minor = match[3] || '0'
    const patch = match[4] || '0'
    const prerelease =
      options.includePrerelease && match[5] ? `-${match[5]}` : ''
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
  }
  coerce_1 = coerce
  return coerce_1
}

let lrucache
let hasRequiredLrucache
function requireLrucache() {
  if (hasRequiredLrucache) {
    return lrucache
  }
  hasRequiredLrucache = 1
  class LRUCache {
    constructor() {
      this.max = 1000
      this.map = new Map()
    }
    get(key) {
      const value = this.map.get(key)
      if (value === undefined) {
        return undefined
      } else {
        // Remove the key from the map and add it to the end
        this.map.delete(key)
        this.map.set(key, value)
        return value
      }
    }
    delete(key) {
      return this.map.delete(key)
    }
    set(key, value) {
      const deleted = this.delete(key)
      if (!deleted && value !== undefined) {
        // If cache is full, delete the least recently used item
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value
          this.delete(firstKey)
        }
        this.map.set(key, value)
      }
      return this
    }
  }
  lrucache = LRUCache
  return lrucache
}

let range
let hasRequiredRange
function requireRange() {
  if (hasRequiredRange) {
    return range
  }
  hasRequiredRange = 1
  const SPACE_CHARACTERS = /\s+/g

  // hoisted class for cyclic dependency
  class Range {
    constructor(range, options) {
      options = parseOptions(options)
      if (range instanceof Range) {
        if (
          range.loose === !!options.loose &&
          range.includePrerelease === !!options.includePrerelease
        ) {
          return range
        } else {
          return new Range(range.raw, options)
        }
      }
      if (range instanceof Comparator) {
        // just put it in the set and return
        this.raw = range.value
        this.set = [[range]]
        this.formatted = undefined
        return this
      }
      this.options = options
      this.loose = !!options.loose
      this.includePrerelease = !!options.includePrerelease

      // First reduce all whitespace as much as possible so we do not have to rely
      // on potentially slow regexes like \s*. This is then stored and used for
      // future error messages as well.
      this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')

      // First, split on ||
      this.set = this.raw
        .split('||')
        // map the range to a 2d array of comparators
        .map(r => this.parseRange(r.trim()))
        // throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter(c => c.length)
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
      }

      // if we have any that are not the null set, throw out null sets.
      if (this.set.length > 1) {
        // keep the first one, in case they're all null sets
        const first = this.set[0]
        this.set = this.set.filter(c => !isNullSet(c[0]))
        if (this.set.length === 0) {
          this.set = [first]
        } else if (this.set.length > 1) {
          // if we have any that are *, then the range is just *
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c]
              break
            }
          }
        }
      }
      this.formatted = undefined
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = ''
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += '||'
          }
          const comps = this.set[i]
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += ' '
            }
            this.formatted += comps[k].toString().trim()
          }
        }
      }
      return this.formatted
    }
    format() {
      return this.range
    }
    toString() {
      return this.range
    }
    parseRange(range) {
      // memoize range parsing for performance.
      // this is a very hot path, and fully deterministic.
      const memoOpts =
        (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
        (this.options.loose && FLAG_LOOSE)
      const memoKey = memoOpts + ':' + range
      const cached = cache.get(memoKey)
      if (cached) {
        return cached
      }
      const loose = this.options.loose
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
      debug('hyphen replace', range)

      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
      debug('comparator trim', range)

      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
      debug('tilde trim', range)

      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[t.CARETTRIM], caretTrimReplace)
      debug('caret trim', range)

      // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      let rangeList = range
        .split(' ')
        .map(comp => parseComparator(comp, this.options))
        .join(' ')
        .split(/\s+/)
        // >=0.0.0 is equivalent to *
        .map(comp => replaceGTE0(comp, this.options))
      if (loose) {
        // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter(comp => {
          debug('loose invalid filter', comp, this.options)
          return !!comp.match(re[t.COMPARATORLOOSE])
        })
      }
      debug('range list', rangeList)

      // if any comparators are the null set, then replace with JUST null set
      // if more than one comparator, remove any * comparators
      // also, don't include the same comparator more than once
      const rangeMap = new Map()
      const comparators = rangeList.map(
        comp => new Comparator(comp, this.options)
      )
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp]
        }
        rangeMap.set(comp.value, comp)
      }
      if (rangeMap.size > 1 && rangeMap.has('')) {
        rangeMap.delete('')
      }
      const result = [...rangeMap.values()]
      cache.set(memoKey, result)
      return result
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required')
      }
      return this.set.some(thisComparators => {
        return (
          isSatisfiable(thisComparators, options) &&
          range.set.some(rangeComparators => {
            return (
              isSatisfiable(rangeComparators, options) &&
              thisComparators.every(thisComparator => {
                return rangeComparators.every(rangeComparator => {
                  return thisComparator.intersects(rangeComparator, options)
                })
              })
            )
          })
        )
      })
    }

    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false
      }
      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options)
        } catch (er) {
          return false
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true
        }
      }
      return false
    }
  }
  range = Range
  const LRU = requireLrucache()
  const cache = new LRU()
  const parseOptions = requireParseOptions()
  const Comparator = requireComparator()
  const debug = requireDebug()
  const SemVer = requireSemver$1()
  const {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe()
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants()
  const isNullSet = c => c.value === '<0.0.0-0'
  const isAny = c => c.value === ''

  // take a set of comparators and determine whether there
  // exists a version which can satisfy it
  const isSatisfiable = (comparators, options) => {
    let result = true
    const remainingComparators = comparators.slice()
    let testComparator = remainingComparators.pop()
    while (result && remainingComparators.length) {
      result = remainingComparators.every(otherComparator => {
        return testComparator.intersects(otherComparator, options)
      })
      testComparator = remainingComparators.pop()
    }
    return result
  }

  // comprised of xranges, tildes, stars, and gtlt's at this point.
  // already replaced the hyphen ranges
  // turn into a set of JUST comparators.
  const parseComparator = (comp, options) => {
    debug('comp', comp, options)
    comp = replaceCarets(comp, options)
    debug('caret', comp)
    comp = replaceTildes(comp, options)
    debug('tildes', comp)
    comp = replaceXRanges(comp, options)
    debug('xrange', comp)
    comp = replaceStars(comp, options)
    debug('stars', comp)
    return comp
  }
  const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

  // ~, ~> --> * (any, kinda silly)
  // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
  // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
  // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
  // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
  // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
  // ~0.0.1 --> >=0.0.1 <0.1.0-0
  const replaceTildes = (comp, options) => {
    return comp
      .trim()
      .split(/\s+/)
      .map(c => replaceTilde(c, options))
      .join(' ')
  }
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
    return comp.replace(r, (_, M, m, p, pr) => {
      debug('tilde', comp, _, M, m, p, pr)
      let ret
      if (isX(M)) {
        ret = ''
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
      } else if (isX(p)) {
        // ~1.2 == >=1.2.0 <1.3.0-0
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
      } else if (pr) {
        debug('replaceTilde pr', pr)
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`
      } else {
        // ~1.2.3 == >=1.2.3 <1.3.0-0
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`
      }
      debug('tilde return', ret)
      return ret
    })
  }

  // ^ --> * (any, kinda silly)
  // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
  // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
  // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
  // ^1.2.3 --> >=1.2.3 <2.0.0-0
  // ^1.2.0 --> >=1.2.0 <2.0.0-0
  // ^0.0.1 --> >=0.0.1 <0.0.2-0
  // ^0.1.0 --> >=0.1.0 <0.2.0-0
  const replaceCarets = (comp, options) => {
    return comp
      .trim()
      .split(/\s+/)
      .map(c => replaceCaret(c, options))
      .join(' ')
  }
  const replaceCaret = (comp, options) => {
    debug('caret', comp, options)
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
    const z = options.includePrerelease ? '-0' : ''
    return comp.replace(r, (_, M, m, p, pr) => {
      debug('caret', comp, _, M, m, p, pr)
      let ret
      if (isX(M)) {
        ret = ''
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
      } else if (isX(p)) {
        if (M === '0') {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
        }
      } else if (pr) {
        debug('replaceCaret pr', pr)
        if (M === '0') {
          if (m === '0') {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`
        }
      } else {
        debug('no pr')
        if (M === '0') {
          if (m === '0') {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`
        }
      }
      debug('caret return', ret)
      return ret
    })
  }
  const replaceXRanges = (comp, options) => {
    debug('replaceXRanges', comp, options)
    return comp
      .split(/\s+/)
      .map(c => replaceXRange(c, options))
      .join(' ')
  }
  const replaceXRange = (comp, options) => {
    comp = comp.trim()
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug('xRange', comp, ret, gtlt, M, m, p, pr)
      const xM = isX(M)
      const xm = xM || isX(m)
      const xp = xm || isX(p)
      const anyX = xp
      if (gtlt === '=' && anyX) {
        gtlt = ''
      }

      // if we're including prereleases in the match, then we need
      // to fix this to -0, the lowest possible prerelease value
      pr = options.includePrerelease ? '-0' : ''
      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          // nothing is allowed
          ret = '<0.0.0-0'
        } else {
          // nothing is forbidden
          ret = '*'
        }
      } else if (gtlt && anyX) {
        // we know patch is an x, because we have any x at all.
        // replace X with 0
        if (xm) {
          m = 0
        }
        p = 0
        if (gtlt === '>') {
          // >1 => >=2.0.0
          // >1.2 => >=1.3.0
          gtlt = '>='
          if (xm) {
            M = +M + 1
            m = 0
            p = 0
          } else {
            m = +m + 1
            p = 0
          }
        } else if (gtlt === '<=') {
          // <=0.7.x is actually <0.8.0, since any 0.7.x should
          // pass.  Similarly, <=7.x is actually <8.0.0, etc.
          gtlt = '<'
          if (xm) {
            M = +M + 1
          } else {
            m = +m + 1
          }
        }
        if (gtlt === '<') {
          pr = '-0'
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`
      }
      debug('xRange return', ret)
      return ret
    })
  }

  // Because * is AND-ed with everything else in the comparator,
  // and '' means "any version", just remove the *s entirely.
  const replaceStars = (comp, options) => {
    debug('replaceStars', comp, options)
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '')
  }
  const replaceGTE0 = (comp, options) => {
    debug('replaceGTE0', comp, options)
    return comp
      .trim()
      .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
  }

  // This function is passed to string.replace(re[t.HYPHENRANGE])
  // M, m, patch, prerelease, build
  // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
  // 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
  // 1.2 - 3.4 => >=1.2.0 <3.5.0-0
  // TODO build?
  const hyphenReplace =
    incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = ''
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? '-0' : ''}`
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
      } else if (fpr) {
        from = `>=${from}`
      } else {
        from = `>=${from}${incPr ? '-0' : ''}`
      }
      if (isX(tM)) {
        to = ''
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`
      } else {
        to = `<=${to}`
      }
      return `${from} ${to}`.trim()
    }
  const testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      // Find the set of versions that are allowed to have prereleases
      // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
      // That should allow `1.2.3-pr.2` to pass.
      // However, `1.2.4-alpha.notready` should NOT be allowed,
      // even though it's within the range set by the comparators.
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver)
        if (set[i].semver === Comparator.ANY) {
          continue
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver
          if (
            allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch
          ) {
            return true
          }
        }
      }

      // Version has a -pre, but it's not one of the ones we like.
      return false
    }
    return true
  }
  return range
}

let comparator
let hasRequiredComparator
function requireComparator() {
  if (hasRequiredComparator) {
    return comparator
  }
  hasRequiredComparator = 1
  const ANY = Symbol('SemVer ANY')
  // hoisted class for cyclic dependency
  class Comparator {
    static get ANY() {
      return ANY
    }
    constructor(comp, options) {
      options = parseOptions(options)
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp
        } else {
          comp = comp.value
        }
      }
      comp = comp.trim().split(/\s+/).join(' ')
      debug('comparator', comp, options)
      this.options = options
      this.loose = !!options.loose
      this.parse(comp)
      if (this.semver === ANY) {
        this.value = ''
      } else {
        this.value = this.operator + this.semver.version
      }
      debug('comp', this)
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
      const m = comp.match(r)
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`)
      }
      this.operator = m[1] !== undefined ? m[1] : ''
      if (this.operator === '=') {
        this.operator = ''
      }

      // if it literally is just '>' or '' then allow anything.
      if (!m[2]) {
        this.semver = ANY
      } else {
        this.semver = new SemVer(m[2], this.options.loose)
      }
    }
    toString() {
      return this.value
    }
    test(version) {
      debug('Comparator.test', version, this.options.loose)
      if (this.semver === ANY || version === ANY) {
        return true
      }
      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options)
        } catch (er) {
          return false
        }
      }
      return cmp(version, this.operator, this.semver, this.options)
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required')
      }
      if (this.operator === '') {
        if (this.value === '') {
          return true
        }
        return new Range(comp.value, options).test(this.value)
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true
        }
        return new Range(this.value, options).test(comp.semver)
      }
      options = parseOptions(options)

      // Special cases where nothing can possibly be lower
      if (
        options.includePrerelease &&
        (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')
      ) {
        return false
      }
      if (
        !options.includePrerelease &&
        (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))
      ) {
        return false
      }

      // Same direction increasing (> or >=)
      if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
        return true
      }
      // Same direction decreasing (< or <=)
      if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
        return true
      }
      // same SemVer and both sides are inclusive (<= or >=)
      if (
        this.semver.version === comp.semver.version &&
        this.operator.includes('=') &&
        comp.operator.includes('=')
      ) {
        return true
      }
      // opposite directions less than
      if (
        cmp(this.semver, '<', comp.semver, options) &&
        this.operator.startsWith('>') &&
        comp.operator.startsWith('<')
      ) {
        return true
      }
      // opposite directions greater than
      if (
        cmp(this.semver, '>', comp.semver, options) &&
        this.operator.startsWith('<') &&
        comp.operator.startsWith('>')
      ) {
        return true
      }
      return false
    }
  }
  comparator = Comparator
  const parseOptions = requireParseOptions()
  const { safeRe: re, t } = requireRe()
  const cmp = requireCmp()
  const debug = requireDebug()
  const SemVer = requireSemver$1()
  const Range = requireRange()
  return comparator
}

let satisfies_1
let hasRequiredSatisfies
function requireSatisfies() {
  if (hasRequiredSatisfies) {
    return satisfies_1
  }
  hasRequiredSatisfies = 1
  const Range = requireRange()
  const satisfies = (version, range, options) => {
    try {
      range = new Range(range, options)
    } catch (er) {
      return false
    }
    return range.test(version)
  }
  satisfies_1 = satisfies
  return satisfies_1
}

let toComparators_1
let hasRequiredToComparators
function requireToComparators() {
  if (hasRequiredToComparators) {
    return toComparators_1
  }
  hasRequiredToComparators = 1
  const Range = requireRange()

  // Mostly just for testing and legacy API reasons
  const toComparators = (range, options) =>
    new Range(range, options).set.map(comp =>
      comp
        .map(c => c.value)
        .join(' ')
        .trim()
        .split(' ')
    )
  toComparators_1 = toComparators
  return toComparators_1
}

let maxSatisfying_1
let hasRequiredMaxSatisfying
function requireMaxSatisfying() {
  if (hasRequiredMaxSatisfying) {
    return maxSatisfying_1
  }
  hasRequiredMaxSatisfying = 1
  const SemVer = requireSemver$1()
  const Range = requireRange()
  const maxSatisfying = (versions, range, options) => {
    let max = null
    let maxSV = null
    let rangeObj = null
    try {
      rangeObj = new Range(range, options)
    } catch (er) {
      return null
    }
    versions.forEach(v => {
      if (rangeObj.test(v)) {
        // satisfies(v, range, options)
        if (!max || maxSV.compare(v) === -1) {
          // compare(max, v, true)
          max = v
          maxSV = new SemVer(max, options)
        }
      }
    })
    return max
  }
  maxSatisfying_1 = maxSatisfying
  return maxSatisfying_1
}

let minSatisfying_1
let hasRequiredMinSatisfying
function requireMinSatisfying() {
  if (hasRequiredMinSatisfying) {
    return minSatisfying_1
  }
  hasRequiredMinSatisfying = 1
  const SemVer = requireSemver$1()
  const Range = requireRange()
  const minSatisfying = (versions, range, options) => {
    let min = null
    let minSV = null
    let rangeObj = null
    try {
      rangeObj = new Range(range, options)
    } catch (er) {
      return null
    }
    versions.forEach(v => {
      if (rangeObj.test(v)) {
        // satisfies(v, range, options)
        if (!min || minSV.compare(v) === 1) {
          // compare(min, v, true)
          min = v
          minSV = new SemVer(min, options)
        }
      }
    })
    return min
  }
  minSatisfying_1 = minSatisfying
  return minSatisfying_1
}

let minVersion_1
let hasRequiredMinVersion
function requireMinVersion() {
  if (hasRequiredMinVersion) {
    return minVersion_1
  }
  hasRequiredMinVersion = 1
  const SemVer = requireSemver$1()
  const Range = requireRange()
  const gt = requireGt()
  const minVersion = (range, loose) => {
    range = new Range(range, loose)
    let minver = new SemVer('0.0.0')
    if (range.test(minver)) {
      return minver
    }
    minver = new SemVer('0.0.0-0')
    if (range.test(minver)) {
      return minver
    }
    minver = null
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i]
      let setMin = null
      comparators.forEach(comparator => {
        // Clone to avoid manipulating the comparator's semver object.
        const compver = new SemVer(comparator.semver.version)
        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++
            } else {
              compver.prerelease.push(0)
            }
            compver.raw = compver.format()
          /* fallthrough */
          case '':
          case '>=':
            if (!setMin || gt(compver, setMin)) {
              setMin = compver
            }
            break
          case '<':
          case '<=':
            /* Ignore maximum versions */
            break
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`)
        }
      })
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin
      }
    }
    if (minver && range.test(minver)) {
      return minver
    }
    return null
  }
  minVersion_1 = minVersion
  return minVersion_1
}

let valid
let hasRequiredValid
function requireValid() {
  if (hasRequiredValid) {
    return valid
  }
  hasRequiredValid = 1
  const Range = requireRange()
  const validRange = (range, options) => {
    try {
      // Return '*' instead of '' so that truthiness works.
      // This will throw if it's invalid anyway
      return new Range(range, options).range || '*'
    } catch (er) {
      return null
    }
  }
  valid = validRange
  return valid
}

let outside_1
let hasRequiredOutside
function requireOutside() {
  if (hasRequiredOutside) {
    return outside_1
  }
  hasRequiredOutside = 1
  const SemVer = requireSemver$1()
  const Comparator = requireComparator()
  const { ANY } = Comparator
  const Range = requireRange()
  const satisfies = requireSatisfies()
  const gt = requireGt()
  const lt = requireLt()
  const lte = requireLte()
  const gte = requireGte()
  const outside = (version, range, hilo, options) => {
    version = new SemVer(version, options)
    range = new Range(range, options)
    let gtfn, ltefn, ltfn, comp, ecomp
    switch (hilo) {
      case '>':
        gtfn = gt
        ltefn = lte
        ltfn = lt
        comp = '>'
        ecomp = '>='
        break
      case '<':
        gtfn = lt
        ltefn = gte
        ltfn = gt
        comp = '<'
        ecomp = '<='
        break
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }

    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) {
      return false
    }

    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.

    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i]
      let high = null
      let low = null
      comparators.forEach(comparator => {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0')
        }
        high = high || comparator
        low = low || comparator
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator
        }
      })

      // If the edge version comparator has a operator then our version
      // isn't outside it
      if (high.operator === comp || high.operator === ecomp) {
        return false
      }

      // If the lowest version comparator has an operator and our version
      // is less than it then it isn't higher than the range
      if (
        (!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)
      ) {
        return false
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false
      }
    }
    return true
  }
  outside_1 = outside
  return outside_1
}

let gtr_1
let hasRequiredGtr
function requireGtr() {
  if (hasRequiredGtr) {
    return gtr_1
  }
  hasRequiredGtr = 1

  // Determine if version is greater than all the versions possible in the range.
  const outside = requireOutside()
  const gtr = (version, range, options) => outside(version, range, '>', options)
  gtr_1 = gtr
  return gtr_1
}

let ltr_1
let hasRequiredLtr
function requireLtr() {
  if (hasRequiredLtr) {
    return ltr_1
  }
  hasRequiredLtr = 1
  const outside = requireOutside()
  // Determine if version is less than all the versions possible in the range
  const ltr = (version, range, options) => outside(version, range, '<', options)
  ltr_1 = ltr
  return ltr_1
}

let intersects_1
let hasRequiredIntersects
function requireIntersects() {
  if (hasRequiredIntersects) {
    return intersects_1
  }
  hasRequiredIntersects = 1
  const Range = requireRange()
  const intersects = (r1, r2, options) => {
    r1 = new Range(r1, options)
    r2 = new Range(r2, options)
    return r1.intersects(r2, options)
  }
  intersects_1 = intersects
  return intersects_1
}

let simplify
let hasRequiredSimplify
function requireSimplify() {
  if (hasRequiredSimplify) {
    return simplify
  }
  hasRequiredSimplify = 1

  // given a set of versions and a range, create a "simplified" range
  // that includes the same versions that the original range does
  // If the original range is shorter than the simplified one, return that.
  const satisfies = requireSatisfies()
  const compare = requireCompare()
  simplify = (versions, range, options) => {
    const set = []
    let first = null
    let prev = null
    const v = versions.sort((a, b) => compare(a, b, options))
    for (const version of v) {
      const included = satisfies(version, range, options)
      if (included) {
        prev = version
        if (!first) {
          first = version
        }
      } else {
        if (prev) {
          set.push([first, prev])
        }
        prev = null
        first = null
      }
    }
    if (first) {
      set.push([first, null])
    }
    const ranges = []
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min)
      } else if (!max && min === v[0]) {
        ranges.push('*')
      } else if (!max) {
        ranges.push(`>=${min}`)
      } else if (min === v[0]) {
        ranges.push(`<=${max}`)
      } else {
        ranges.push(`${min} - ${max}`)
      }
    }
    const simplified = ranges.join(' || ')
    const original = typeof range.raw === 'string' ? range.raw : String(range)
    return simplified.length < original.length ? simplified : range
  }
  return simplify
}

let subset_1
let hasRequiredSubset
function requireSubset() {
  if (hasRequiredSubset) {
    return subset_1
  }
  hasRequiredSubset = 1
  const Range = requireRange()
  const Comparator = requireComparator()
  const { ANY } = Comparator
  const satisfies = requireSatisfies()
  const compare = requireCompare()

  // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
  // - Every simple range `r1, r2, ...` is a null set, OR
  // - Every simple range `r1, r2, ...` which is not a null set is a subset of
  //   some `R1, R2, ...`
  //
  // Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
  // - If c is only the ANY comparator
  //   - If C is only the ANY comparator, return true
  //   - Else if in prerelease mode, return false
  //   - else replace c with `[>=0.0.0]`
  // - If C is only the ANY comparator
  //   - if in prerelease mode, return true
  //   - else replace C with `[>=0.0.0]`
  // - Let EQ be the set of = comparators in c
  // - If EQ is more than one, return true (null set)
  // - Let GT be the highest > or >= comparator in c
  // - Let LT be the lowest < or <= comparator in c
  // - If GT and LT, and GT.semver > LT.semver, return true (null set)
  // - If any C is a = range, and GT or LT are set, return false
  // - If EQ
  //   - If GT, and EQ does not satisfy GT, return true (null set)
  //   - If LT, and EQ does not satisfy LT, return true (null set)
  //   - If EQ satisfies every C, return true
  //   - Else return false
  // - If GT
  //   - If GT.semver is lower than any > or >= comp in C, return false
  //   - If GT is >=, and GT.semver does not satisfy every C, return false
  //   - If GT.semver has a prerelease, and not in prerelease mode
  //     - If no C has a prerelease and the GT.semver tuple, return false
  // - If LT
  //   - If LT.semver is greater than any < or <= comp in C, return false
  //   - If LT is <=, and LT.semver does not satisfy every C, return false
  //   - If GT.semver has a prerelease, and not in prerelease mode
  //     - If no C has a prerelease and the LT.semver tuple, return false
  // - Else return true

  const subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true
    }
    sub = new Range(sub, options)
    dom = new Range(dom, options)
    let sawNonNull = false
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options)
        sawNonNull = sawNonNull || isSub !== null
        if (isSub) {
          continue OUTER
        }
      }
      // the null set is a subset of everything, but null simple ranges in
      // a complex range should be ignored.  so if we saw a non-null range,
      // then we know this isn't a subset, but if EVERY simple range was null,
      // then it is a subset.
      if (sawNonNull) {
        return false
      }
    }
    return true
  }
  const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
  const minimumVersion = [new Comparator('>=0.0.0')]
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease
      } else {
        sub = minimumVersion
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true
      } else {
        dom = minimumVersion
      }
    }
    const eqSet = new Set()
    let gt, lt
    for (const c of sub) {
      if (c.operator === '>' || c.operator === '>=') {
        gt = higherGT(gt, c, options)
      } else if (c.operator === '<' || c.operator === '<=') {
        lt = lowerLT(lt, c, options)
      } else {
        eqSet.add(c.semver)
      }
    }
    if (eqSet.size > 1) {
      return null
    }
    let gtltComp
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options)
      if (gtltComp > 0) {
        return null
      } else if (
        gtltComp === 0 &&
        (gt.operator !== '>=' || lt.operator !== '<=')
      ) {
        return null
      }
    }

    // will iterate one or zero times
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false
        }
      }
      return true
    }
    let higher, lower
    let hasDomLT, hasDomGT
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre =
      lt && !options.includePrerelease && lt.semver.prerelease.length
        ? lt.semver
        : false
    let needDomGTPre =
      gt && !options.includePrerelease && gt.semver.prerelease.length
        ? gt.semver
        : false
    // exception: <1.2.3-0 is the same as <1.2.3
    if (
      needDomLTPre &&
      needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' &&
      needDomLTPre.prerelease[0] === 0
    ) {
      needDomLTPre = false
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
      hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
      if (gt) {
        if (needDomGTPre) {
          if (
            c.semver.prerelease &&
            c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch
          ) {
            needDomGTPre = false
          }
        }
        if (c.operator === '>' || c.operator === '>=') {
          higher = higherGT(gt, c, options)
          if (higher === c && higher !== gt) {
            return false
          }
        } else if (
          gt.operator === '>=' &&
          !satisfies(gt.semver, String(c), options)
        ) {
          return false
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (
            c.semver.prerelease &&
            c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch
          ) {
            needDomLTPre = false
          }
        }
        if (c.operator === '<' || c.operator === '<=') {
          lower = lowerLT(lt, c, options)
          if (lower === c && lower !== lt) {
            return false
          }
        } else if (
          lt.operator === '<=' &&
          !satisfies(lt.semver, String(c), options)
        ) {
          return false
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false
      }
    }

    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false
    }

    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) {
      return false
    }
    return true
  }

  // >=1.2.3 is lower than >1.2.3
  const higherGT = (a, b, options) => {
    if (!a) {
      return b
    }
    const comp = compare(a.semver, b.semver, options)
    return comp > 0
      ? a
      : comp < 0
        ? b
        : b.operator === '>' && a.operator === '>='
          ? b
          : a
  }

  // <=1.2.3 is higher than <1.2.3
  const lowerLT = (a, b, options) => {
    if (!a) {
      return b
    }
    const comp = compare(a.semver, b.semver, options)
    return comp < 0
      ? a
      : comp > 0
        ? b
        : b.operator === '<' && a.operator === '<='
          ? b
          : a
  }
  subset_1 = subset
  return subset_1
}

let semver
let hasRequiredSemver
function requireSemver() {
  if (hasRequiredSemver) {
    return semver
  }
  hasRequiredSemver = 1

  // just pre-load all the stuff that index.js lazily exports
  const internalRe = requireRe()
  const constants = requireConstants()
  const SemVer = requireSemver$1()
  const identifiers = requireIdentifiers()
  const parse = requireParse()
  const valid = requireValid$1()
  const clean = requireClean()
  const inc = requireInc()
  const diff = requireDiff()
  const major = requireMajor()
  const minor = requireMinor()
  const patch = requirePatch()
  const prerelease = requirePrerelease()
  const compare = requireCompare()
  const rcompare = requireRcompare()
  const compareLoose = requireCompareLoose()
  const compareBuild = requireCompareBuild()
  const sort = requireSort()
  const rsort = requireRsort()
  const gt = requireGt()
  const lt = requireLt()
  const eq = requireEq()
  const neq = requireNeq()
  const gte = requireGte()
  const lte = requireLte()
  const cmp = requireCmp()
  const coerce = requireCoerce()
  const Comparator = requireComparator()
  const Range = requireRange()
  const satisfies = requireSatisfies()
  const toComparators = requireToComparators()
  const maxSatisfying = requireMaxSatisfying()
  const minSatisfying = requireMinSatisfying()
  const minVersion = requireMinVersion()
  const validRange = requireValid()
  const outside = requireOutside()
  const gtr = requireGtr()
  const ltr = requireLtr()
  const intersects = requireIntersects()
  const simplifyRange = requireSimplify()
  const subset = requireSubset()
  semver = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  }
  return semver
}

let lib$1
let hasRequiredLib$1
function requireLib$1() {
  if (hasRequiredLib$1) {
    return lib$1
  }
  hasRequiredLib$1 = 1
  const { builtinModules: builtins } = require$$0$1
  const scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$')
  const exclusionList = ['node_modules', 'favicon.ico']
  function validate(name) {
    const warnings = []
    const errors = []
    if (name === null) {
      errors.push('name cannot be null')
      return done(warnings, errors)
    }
    if (name === undefined) {
      errors.push('name cannot be undefined')
      return done(warnings, errors)
    }
    if (typeof name !== 'string') {
      errors.push('name must be a string')
      return done(warnings, errors)
    }
    if (!name.length) {
      errors.push('name length must be greater than zero')
    }
    if (name.startsWith('.')) {
      errors.push('name cannot start with a period')
    }
    if (name.match(/^_/)) {
      errors.push('name cannot start with an underscore')
    }
    if (name.trim() !== name) {
      errors.push('name cannot contain leading or trailing spaces')
    }

    // No funny business
    exclusionList.forEach(function (excludedName) {
      if (name.toLowerCase() === excludedName) {
        errors.push(excludedName + ' is not a valid package name')
      }
    })

    // Generate warnings for stuff that used to be allowed

    // core module names like http, events, util, etc
    if (builtins.includes(name.toLowerCase())) {
      warnings.push(name + ' is a core module name')
    }
    if (name.length > 214) {
      warnings.push('name can no longer contain more than 214 characters')
    }

    // mIxeD CaSe nAMEs
    if (name.toLowerCase() !== name) {
      warnings.push('name can no longer contain capital letters')
    }
    if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
      warnings.push('name can no longer contain special characters ("~\'!()*")')
    }
    if (encodeURIComponent(name) !== name) {
      // Maybe it's a scoped package name, like @user/package
      const nameMatch = name.match(scopedPackagePattern)
      if (nameMatch) {
        const user = nameMatch[1]
        const pkg = nameMatch[2]
        if (pkg.startsWith('.')) {
          errors.push('name cannot start with a period')
        }
        if (
          encodeURIComponent(user) === user &&
          encodeURIComponent(pkg) === pkg
        ) {
          return done(warnings, errors)
        }
      }
      errors.push('name can only contain URL-friendly characters')
    }
    return done(warnings, errors)
  }
  const done = function (warnings, errors) {
    const result = {
      validForNewPackages: errors.length === 0 && warnings.length === 0,
      validForOldPackages: errors.length === 0,
      warnings: warnings,
      errors: errors
    }
    if (!result.warnings.length) {
      delete result.warnings
    }
    if (!result.errors.length) {
      delete result.errors
    }
    return result
  }
  lib$1 = validate
  return lib$1
}

let lib
let hasRequiredLib
function requireLib() {
  if (hasRequiredLib) {
    return lib
  }
  hasRequiredLib = 1
  const META = Symbol('proc-log.meta')
  lib = {
    META: META,
    output: {
      LEVELS: ['standard', 'error', 'buffer', 'flush'],
      KEYS: {
        standard: 'standard',
        error: 'error',
        buffer: 'buffer',
        flush: 'flush'
      },
      standard: function (...args) {
        return process.emit('output', 'standard', ...args)
      },
      error: function (...args) {
        return process.emit('output', 'error', ...args)
      },
      buffer: function (...args) {
        return process.emit('output', 'buffer', ...args)
      },
      flush: function (...args) {
        return process.emit('output', 'flush', ...args)
      }
    },
    log: {
      LEVELS: [
        'notice',
        'error',
        'warn',
        'info',
        'verbose',
        'http',
        'silly',
        'timing',
        'pause',
        'resume'
      ],
      KEYS: {
        notice: 'notice',
        error: 'error',
        warn: 'warn',
        info: 'info',
        verbose: 'verbose',
        http: 'http',
        silly: 'silly',
        timing: 'timing',
        pause: 'pause',
        resume: 'resume'
      },
      error: function (...args) {
        return process.emit('log', 'error', ...args)
      },
      notice: function (...args) {
        return process.emit('log', 'notice', ...args)
      },
      warn: function (...args) {
        return process.emit('log', 'warn', ...args)
      },
      info: function (...args) {
        return process.emit('log', 'info', ...args)
      },
      verbose: function (...args) {
        return process.emit('log', 'verbose', ...args)
      },
      http: function (...args) {
        return process.emit('log', 'http', ...args)
      },
      silly: function (...args) {
        return process.emit('log', 'silly', ...args)
      },
      timing: function (...args) {
        return process.emit('log', 'timing', ...args)
      },
      pause: function () {
        return process.emit('log', 'pause')
      },
      resume: function () {
        return process.emit('log', 'resume')
      }
    },
    time: {
      LEVELS: ['start', 'end'],
      KEYS: {
        start: 'start',
        end: 'end'
      },
      start: function (name, fn) {
        process.emit('time', 'start', name)
        function end() {
          return process.emit('time', 'end', name)
        }
        if (typeof fn === 'function') {
          const res = fn()
          if (res && res.finally) {
            return res.finally(end)
          }
          end()
          return res
        }
        return end
      },
      end: function (name) {
        return process.emit('time', 'end', name)
      }
    },
    input: {
      LEVELS: ['start', 'end', 'read'],
      KEYS: {
        start: 'start',
        end: 'end',
        read: 'read'
      },
      start: function (fn) {
        process.emit('input', 'start')
        function end() {
          return process.emit('input', 'end')
        }
        if (typeof fn === 'function') {
          const res = fn()
          if (res && res.finally) {
            return res.finally(end)
          }
          end()
          return res
        }
        return end
      },
      end: function () {
        return process.emit('input', 'end')
      },
      read: function (...args) {
        let resolve, reject
        const promise = new Promise((_resolve, _reject) => {
          resolve = _resolve
          reject = _reject
        })
        process.emit('input', 'read', resolve, reject, ...args)
        return promise
      }
    }
  }
  return lib
}

let hasRequiredNpa
function requireNpa() {
  if (hasRequiredNpa) {
    return npa.exports
  }
  hasRequiredNpa = 1
  const isWindows = process.platform === 'win32'
  const { URL } = require$$0$2
  // We need to use path/win32 so that we get consistent results in tests, but this also means we need to manually convert backslashes to forward slashes when generating file: urls with paths.
  const path = isWindows ? require$$1 : require$$2
  const { homedir } = require$$3
  const HostedGit = requireLib$2()
  const semver = requireSemver()
  const validatePackageName = requireLib$1()
  const { log } = requireLib()
  const hasSlashes = isWindows ? /\\|[/]/ : /[/]/
  const isURL = /^(?:git[+])?[a-z]+:/i
  const isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i
  const isFileType = /[.](?:tgz|tar.gz|tar)$/i
  const isPortNumber = /:[0-9]+(\/|$)/i
  const isWindowsFile = /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/
  const isPosixFile = /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/
  const defaultRegistry = 'https://registry.npmjs.org'
  function npa$1(arg, where) {
    let name
    let spec
    if (typeof arg === 'object') {
      if (arg instanceof Result && (!where || where === arg.where)) {
        return arg
      } else if (arg.name && arg.rawSpec) {
        return npa$1.resolve(arg.name, arg.rawSpec, where || arg.where)
      } else {
        return npa$1(arg.raw, where || arg.where)
      }
    }
    const nameEndsAt = arg.indexOf('@', 1) // Skip possible leading @
    const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg
    if (isURL.test(arg)) {
      spec = arg
    } else if (isGit.test(arg)) {
      spec = `git+ssh://${arg}`
      // eslint-disable-next-line max-len
    } else if (
      !namePart.startsWith('@') &&
      (hasSlashes.test(namePart) || isFileType.test(namePart))
    ) {
      spec = arg
    } else if (nameEndsAt > 0) {
      name = namePart
      spec = arg.slice(nameEndsAt + 1) || '*'
    } else {
      const valid = validatePackageName(arg)
      if (valid.validForOldPackages) {
        name = arg
        spec = '*'
      } else {
        spec = arg
      }
    }
    return resolve(name, spec, where, arg)
  }
  function isFileSpec(spec) {
    if (!spec) {
      return false
    }
    if (spec.toLowerCase().startsWith('file:')) {
      return true
    }
    if (isWindows) {
      return isWindowsFile.test(spec)
    }
    // We never hit this in windows tests, obviously
    /* istanbul ignore next */
    return isPosixFile.test(spec)
  }
  function isAliasSpec(spec) {
    if (!spec) {
      return false
    }
    return spec.toLowerCase().startsWith('npm:')
  }
  function resolve(name, spec, where, arg) {
    const res = new Result({
      raw: arg,
      name: name,
      rawSpec: spec,
      fromArgument: arg != null
    })
    if (name) {
      res.name = name
    }
    if (!where) {
      where = process.cwd()
    }
    if (isFileSpec(spec)) {
      return fromFile(res, where)
    } else if (isAliasSpec(spec)) {
      return fromAlias(res, where)
    }
    const hosted = HostedGit.fromUrl(spec, {
      noGitPlus: true,
      noCommittish: true
    })
    if (hosted) {
      return fromHostedGit(res, hosted)
    } else if (spec && isURL.test(spec)) {
      return fromURL(res)
    } else if (spec && (hasSlashes.test(spec) || isFileType.test(spec))) {
      return fromFile(res, where)
    } else {
      return fromRegistry(res)
    }
  }
  function toPurl(arg, reg = defaultRegistry) {
    const res = npa$1(arg)
    if (res.type !== 'version') {
      throw invalidPurlType(res.type, res.raw)
    }

    // URI-encode leading @ of scoped packages
    let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec
    if (reg !== defaultRegistry) {
      purl += '?repository_url=' + reg
    }
    return purl
  }
  function invalidPackageName(name, valid, raw) {
    // eslint-disable-next-line max-len
    const err = new Error(
      `Invalid package name "${name}" of package "${raw}": ${valid.errors.join('; ')}.`
    )
    err.code = 'EINVALIDPACKAGENAME'
    return err
  }
  function invalidTagName(name, raw) {
    // eslint-disable-next-line max-len
    const err = new Error(
      `Invalid tag name "${name}" of package "${raw}": Tags may not have any characters that encodeURIComponent encodes.`
    )
    err.code = 'EINVALIDTAGNAME'
    return err
  }
  function invalidPurlType(type, raw) {
    // eslint-disable-next-line max-len
    const err = new Error(
      `Invalid type "${type}" of package "${raw}": Purl can only be generated for "version" types.`
    )
    err.code = 'EINVALIDPURLTYPE'
    return err
  }
  class Result {
    constructor(opts) {
      this.type = opts.type
      this.registry = opts.registry
      this.where = opts.where
      if (opts.raw == null) {
        this.raw = opts.name ? `${opts.name}@${opts.rawSpec}` : opts.rawSpec
      } else {
        this.raw = opts.raw
      }
      this.name = undefined
      this.escapedName = undefined
      this.scope = undefined
      this.rawSpec = opts.rawSpec || ''
      this.saveSpec = opts.saveSpec
      this.fetchSpec = opts.fetchSpec
      if (opts.name) {
        this.setName(opts.name)
      }
      this.gitRange = opts.gitRange
      this.gitCommittish = opts.gitCommittish
      this.gitSubdir = opts.gitSubdir
      this.hosted = opts.hosted
    }

    // TODO move this to a getter/setter in a semver major
    setName(name) {
      const valid = validatePackageName(name)
      if (!valid.validForOldPackages) {
        throw invalidPackageName(name, valid, this.raw)
      }
      this.name = name
      this.scope =
        name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined
      // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar
      this.escapedName = name.replace('/', '%2f')
      return this
    }
    toString() {
      const full = []
      if (this.name != null && this.name !== '') {
        full.push(this.name)
      }
      const spec = this.saveSpec || this.fetchSpec || this.rawSpec
      if (spec != null && spec !== '') {
        full.push(spec)
      }
      return full.length ? full.join('@') : this.raw
    }
    toJSON() {
      const result = Object.assign({}, this)
      delete result.hosted
      return result
    }
  }

  // sets res.gitCommittish, res.gitRange, and res.gitSubdir
  function setGitAttrs(res, committish) {
    if (!committish) {
      res.gitCommittish = null
      return
    }

    // for each :: separated item:
    for (const part of committish.split('::')) {
      // if the item has no : the n it is a commit-ish
      if (!part.includes(':')) {
        if (res.gitRange) {
          throw new Error(
            'cannot override existing semver range with a committish'
          )
        }
        if (res.gitCommittish) {
          throw new Error(
            'cannot override existing committish with a second committish'
          )
        }
        res.gitCommittish = part
        continue
      }
      // split on name:value
      const [name, value] = part.split(':')
      // if name is semver do semver lookup of ref or tag
      if (name === 'semver') {
        if (res.gitCommittish) {
          throw new Error(
            'cannot override existing committish with a semver range'
          )
        }
        if (res.gitRange) {
          throw new Error(
            'cannot override existing semver range with a second semver range'
          )
        }
        res.gitRange = decodeURIComponent(value)
        continue
      }
      if (name === 'path') {
        if (res.gitSubdir) {
          throw new Error('cannot override existing path with a second path')
        }
        res.gitSubdir = `/${value}`
        continue
      }
      log.warn('npm-package-arg', `ignoring unknown key "${name}"`)
    }
  }

  // Taken from: EncodePathChars and lookup_table in src/node_url.cc
  // url.pathToFileURL only returns absolute references.  We can't use it to encode paths.
  // encodeURI mangles windows paths. We can't use it to encode paths.
  // Under the hood, url.pathToFileURL does a limited set of encoding, with an extra windows step, and then calls path.resolve.
  // The encoding node does without path.resolve is not available outside of the source, so we are recreating it here.
  const encodedPathChars = new Map([
    ['\0', '%00'],
    ['\t', '%09'],
    ['\n', '%0A'],
    ['\r', '%0D'],
    [' ', '%20'],
    ['"', '%22'],
    ['#', '%23'],
    ['%', '%25'],
    ['?', '%3F'],
    ['[', '%5B'],
    ['\\', isWindows ? '/' : '%5C'],
    [']', '%5D'],
    ['^', '%5E'],
    ['|', '%7C'],
    ['~', '%7E']
  ])
  function pathToFileURL(str) {
    let result = ''
    for (let i = 0; i < str.length; i++) {
      result = `${result}${encodedPathChars.get(str[i]) ?? str[i]}`
    }
    if (result.startsWith('file:')) {
      return result
    }
    return `file:${result}`
  }
  function fromFile(res, where) {
    res.type = isFileType.test(res.rawSpec) ? 'file' : 'directory'
    res.where = where
    let rawSpec = pathToFileURL(res.rawSpec)
    if (rawSpec.startsWith('file:/')) {
      // XXX backwards compatibility lack of compliance with RFC 8089

      // turn file://path into file:/path
      if (/^file:\/\/[^/]/.test(rawSpec)) {
        rawSpec = `file:/${rawSpec.slice(5)}`
      }

      // turn file:/../path into file:../path
      // for 1 or 3 leading slashes (2 is already ruled out from handling file:// explicitly above)
      if (/^\/{1,3}\.\.?(\/|$)/.test(rawSpec.slice(5))) {
        rawSpec = rawSpec.replace(/^file:\/{1,3}/, 'file:')
      }
    }
    let resolvedUrl
    let specUrl
    try {
      // always put the '/' on "where", or else file:foo from /path/to/bar goes to /path/to/foo, when we want it to be /path/to/bar/foo
      resolvedUrl = new URL(rawSpec, `${pathToFileURL(path.resolve(where))}/`)
      specUrl = new URL(rawSpec)
    } catch (originalError) {
      const er = new Error('Invalid file: URL, must comply with RFC 8089')
      throw Object.assign(er, {
        raw: res.rawSpec,
        spec: res,
        where,
        originalError
      })
    }

    // turn /C:/blah into just C:/blah on windows
    let specPath = decodeURIComponent(specUrl.pathname)
    let resolvedPath = decodeURIComponent(resolvedUrl.pathname)
    if (isWindows) {
      specPath = specPath.replace(/^\/+([a-z]:\/)/i, '$1')
      resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, '$1')
    }

    // replace ~ with homedir, but keep the ~ in the saveSpec
    // otherwise, make it relative to where param
    if (/^\/~(\/|$)/.test(specPath)) {
      res.saveSpec = `file:${specPath.substr(1)}`
      resolvedPath = path.resolve(homedir(), specPath.substr(3))
    } else if (!path.isAbsolute(rawSpec.slice(5))) {
      res.saveSpec = `file:${path.relative(where, resolvedPath)}`
    } else {
      res.saveSpec = `file:${path.resolve(resolvedPath)}`
    }
    res.fetchSpec = path.resolve(where, resolvedPath)
    // re-normalize the slashes in saveSpec due to node:path/win32 behavior in windows
    res.saveSpec = res.saveSpec.split('\\').join('/')
    // Ignoring because this only happens in windows
    /* istanbul ignore next */
    if (res.saveSpec.startsWith('file://')) {
      // normalization of \\win32\root paths can cause a double / which we don't want
      res.saveSpec = `file:/${res.saveSpec.slice(7)}`
    }
    return res
  }
  function fromHostedGit(res, hosted) {
    res.type = 'git'
    res.hosted = hosted
    res.saveSpec = hosted.toString({
      noGitPlus: false,
      noCommittish: false
    })
    res.fetchSpec =
      hosted.getDefaultRepresentation() === 'shortcut'
        ? null
        : hosted.toString()
    setGitAttrs(res, hosted.committish)
    return res
  }
  function unsupportedURLType(protocol, spec) {
    const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`)
    err.code = 'EUNSUPPORTEDPROTOCOL'
    return err
  }
  function fromURL(res) {
    let rawSpec = res.rawSpec
    res.saveSpec = rawSpec
    if (rawSpec.startsWith('git+ssh:')) {
      // git ssh specifiers are overloaded to also use scp-style git
      // specifiers, so we have to parse those out and treat them special.
      // They are NOT true URIs, so we can't hand them to URL.

      // This regex looks for things that look like:
      // git+ssh://git@my.custom.git.com:username/project.git#deadbeef
      // ...and various combinations. The username in the beginning is *required*.
      const matched = rawSpec.match(
        /^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i
      )
      // Filter out all-number "usernames" which are really port numbers
      // They can either be :1234 :1234/ or :1234/path but not :12abc
      if (matched && !matched[1].match(isPortNumber)) {
        res.type = 'git'
        setGitAttrs(res, matched[2])
        res.fetchSpec = matched[1]
        return res
      }
    } else if (rawSpec.startsWith('git+file://')) {
      // URL can't handle windows paths
      rawSpec = rawSpec.replace(/\\/g, '/')
    }
    const parsedUrl = new URL(rawSpec)
    // check the protocol, and then see if it's git or not
    switch (parsedUrl.protocol) {
      case 'git:':
      case 'git+http:':
      case 'git+https:':
      case 'git+rsync:':
      case 'git+ftp:':
      case 'git+file:':
      case 'git+ssh:':
        res.type = 'git'
        setGitAttrs(res, parsedUrl.hash.slice(1))
        if (
          parsedUrl.protocol === 'git+file:' &&
          /^git\+file:\/\/[a-z]:/i.test(rawSpec)
        ) {
          // URL can't handle drive letters on windows file paths, the host can't contain a :
          res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`
        } else {
          parsedUrl.hash = ''
          res.fetchSpec = parsedUrl.toString()
        }
        if (res.fetchSpec.startsWith('git+')) {
          res.fetchSpec = res.fetchSpec.slice(4)
        }
        break
      case 'http:':
      case 'https:':
        res.type = 'remote'
        res.fetchSpec = res.saveSpec
        break
      default:
        throw unsupportedURLType(parsedUrl.protocol, rawSpec)
    }
    return res
  }
  function fromAlias(res, where) {
    const subSpec = npa$1(res.rawSpec.substr(4), where)
    if (subSpec.type === 'alias') {
      throw new Error('nested aliases not supported')
    }
    if (!subSpec.registry) {
      throw new Error('aliases only work for registry deps')
    }
    if (!subSpec.name) {
      throw new Error('aliases must have a name')
    }
    res.subSpec = subSpec
    res.registry = true
    res.type = 'alias'
    res.saveSpec = null
    res.fetchSpec = null
    return res
  }
  function fromRegistry(res) {
    res.registry = true
    const spec = res.rawSpec.trim()
    // no save spec for registry components as we save based on the fetched
    // version, not on the argument so this can't compute that.
    res.saveSpec = null
    res.fetchSpec = spec
    const version = semver.valid(spec, true)
    const range = semver.validRange(spec, true)
    if (version) {
      res.type = 'version'
    } else if (range) {
      res.type = 'range'
    } else {
      if (encodeURIComponent(spec) !== spec) {
        throw invalidTagName(spec, res.raw)
      }
      res.type = 'tag'
    }
    return res
  }
  npa.exports = npa$1
  npa.exports.resolve = resolve
  npa.exports.toPurl = toPurl
  npa.exports.Result = Result
  return npa.exports
}

const npaExports = requireNpa()

module.exports = npaExports
