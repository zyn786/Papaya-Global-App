'use strict'

function getIterator(iterable) {
  if (typeof iterable.next === 'function') {
    return iterable
  }
  if (typeof iterable[Symbol.iterator] === 'function') {
    return iterable[Symbol.iterator]()
  }
  if (typeof iterable[Symbol.asyncIterator] === 'function') {
    return iterable[Symbol.asyncIterator]()
  }
  throw new TypeError(
    '"values" does not to conform to any of the iterator or iterable protocols'
  )
}
function defer() {
  let reject
  let resolve
  const promise = new Promise((resolveFunc, rejectFunc) => {
    resolve = resolveFunc
    reject = rejectFunc
  })
  return {
    promise,
    reject,
    resolve
  }
}
function _buffer(size, iterable) {
  const iterator = getIterator(iterable)
  const resultQueue = []
  const readQueue = []
  let reading = false
  let ended = false
  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      const readDeferred = readQueue.shift()
      const { error, value } = resultQueue.shift()
      if (error) {
        readDeferred.reject(error)
      } else {
        readDeferred.resolve({
          done: false,
          value
        })
      }
    }
    while (readQueue.length > 0 && ended) {
      const { resolve } = readQueue.shift()
      resolve({
        done: true,
        value: undefined
      })
    }
  }
  async function fillQueue() {
    if (ended) {
      return
    }
    if (reading) {
      return
    }
    if (resultQueue.length >= size) {
      return
    }
    reading = true
    try {
      const { done, value } = await iterator.next()
      if (done) {
        ended = true
      } else {
        resultQueue.push({
          value
        })
      }
    } catch (error) {
      ended = true
      resultQueue.push({
        error
      })
    }
    fulfillReadQueue()
    reading = false
    fillQueue()
  }
  async function next() {
    if (resultQueue.length > 0) {
      const { error, value } = resultQueue.shift()
      if (error) {
        throw error
      }
      fillQueue()
      return {
        done: false,
        value
      }
    }
    if (ended) {
      return {
        done: true,
        value: undefined
      } // stupid ts
    }
    const deferred = defer()
    readQueue.push(deferred)
    fillQueue()
    return deferred.promise
  }
  const asyncIterableIterator = {
    next,
    [Symbol.asyncIterator]: () => asyncIterableIterator
  }
  return asyncIterableIterator
}
function* syncBuffer(size, iterable) {
  const valueQueue = []
  let e
  try {
    for (const value of iterable) {
      valueQueue.push(value)
      if (valueQueue.length <= size) {
        continue
      }
      yield valueQueue.shift()
    }
  } catch (error) {
    e = error
  }
  for (const value of valueQueue) {
    yield value
  }
  if (e) {
    throw e
  }
}
function buffer(size, iterable) {
  if (iterable === undefined) {
    return curriedIterable => buffer(size, curriedIterable)
  }
  if (size === 0) {
    return iterable
  }
  if (iterable[Symbol.asyncIterator]) {
    return _buffer(size, iterable)
  }
  return syncBuffer(size, iterable)
}
async function* _map(func, iterable) {
  for await (const val of iterable) {
    yield await func(val)
  }
}
function map(func, iterable) {
  if (iterable === undefined) {
    return curriedIterable => _map(func, curriedIterable)
  }
  return _map(func, iterable)
}
function pipeline(firstFn, ...fns) {
  let previousFn = firstFn()
  for (const func of fns) {
    previousFn = func(previousFn)
  }
  return previousFn
}
async function* _parallelMap(concurrency, func, iterable) {
  let transformError = null
  const wrapFunc = value => ({
    value: func(value)
  })
  const stopOnError = async function* (source) {
    for await (const value of source) {
      if (transformError) {
        return
      }
      yield value
    }
  }
  const output = pipeline(
    () => iterable,
    buffer(1),
    stopOnError,
    map(wrapFunc),
    buffer(concurrency - 1)
  )
  const itr = getIterator(output)
  while (true) {
    const { value, done } = await itr.next()
    if (done) {
      break
    }
    try {
      const val = await value.value
      if (!transformError) {
        yield val
      }
    } catch (error) {
      transformError = error
    }
  }
  if (transformError) {
    throw transformError
  }
}
function parallelMap(concurrency, func, iterable) {
  if (func === undefined) {
    return (curriedFunc, curriedIterable) =>
      parallelMap(concurrency, curriedFunc, curriedIterable)
  }
  if (iterable === undefined) {
    return curriedIterable => parallelMap(concurrency, func, curriedIterable)
  }
  if (concurrency === 1) {
    return map(func, iterable)
  }
  return _parallelMap(concurrency, func, iterable)
}
function _transform(concurrency, func, iterable) {
  const iterator = getIterator(iterable)
  const resultQueue = []
  const readQueue = []
  let ended = false
  let reading = false
  let inflightCount = 0
  let lastError = null
  function fulfillReadQueue() {
    while (readQueue.length > 0 && resultQueue.length > 0) {
      const { resolve } = readQueue.shift()
      const value = resultQueue.shift()
      resolve({
        done: false,
        value
      })
    }
    while (readQueue.length > 0 && inflightCount === 0 && ended) {
      const { resolve, reject } = readQueue.shift()
      if (lastError) {
        reject(lastError)
        lastError = null
      } else {
        resolve({
          done: true,
          value: undefined
        })
      }
    }
  }
  async function fillQueue() {
    if (ended) {
      fulfillReadQueue()
      return
    }
    if (reading) {
      return
    }
    if (inflightCount + resultQueue.length >= concurrency) {
      return
    }
    reading = true
    inflightCount++
    try {
      const { done, value } = await iterator.next()
      if (done) {
        ended = true
        inflightCount--
        fulfillReadQueue()
      } else {
        mapAndQueue(value)
      }
    } catch (error) {
      ended = true
      inflightCount--
      lastError = error
      fulfillReadQueue()
    }
    reading = false
    fillQueue()
  }
  async function mapAndQueue(itrValue) {
    try {
      const value = await func(itrValue)
      resultQueue.push(value)
    } catch (error) {
      ended = true
      lastError = error
    }
    inflightCount--
    fulfillReadQueue()
    fillQueue()
  }
  async function next() {
    if (resultQueue.length === 0) {
      const deferred = defer()
      readQueue.push(deferred)
      fillQueue()
      return deferred.promise
    }
    const value = resultQueue.shift()
    fillQueue()
    return {
      done: false,
      value
    }
  }
  const asyncIterableIterator = {
    next,
    [Symbol.asyncIterator]: () => asyncIterableIterator
  }
  return asyncIterableIterator
}
function transform(concurrency, func, iterable) {
  if (func === undefined) {
    return (curriedFunc, curriedIterable) =>
      curriedIterable
        ? transform(concurrency, curriedFunc, curriedIterable)
        : transform(concurrency, curriedFunc)
  }
  if (iterable === undefined) {
    return curriedIterable => transform(concurrency, func, curriedIterable)
  }
  return _transform(concurrency, func, iterable)
}

exports.parallelMap = parallelMap
exports.transform = transform
