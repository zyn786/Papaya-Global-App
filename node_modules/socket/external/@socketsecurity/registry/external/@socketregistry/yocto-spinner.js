'use strict'

const require$$0$1 = require('process')
const require$$0 = require('tty')
const require$$2 = require('util')

let yoctocolorsCjs
let hasRequiredYoctocolorsCjs
function requireYoctocolorsCjs() {
  if (hasRequiredYoctocolorsCjs) {
    return yoctocolorsCjs
  }
  hasRequiredYoctocolorsCjs = 1
  const tty = require$$0

  // eslint-disable-next-line no-warning-comments
  // TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)
  // Lots of optionals here to support Deno.
  const hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false
  const format = (open, close) => {
    if (!hasColors) {
      return input => input
    }
    const openCode = `\u001B[${open}m`
    const closeCode = `\u001B[${close}m`
    return input => {
      const string = input + '' // eslint-disable-line no-implicit-coercion -- This is faster.
      let index = string.indexOf(closeCode)
      if (index === -1) {
        // Note: Intentionally not using string interpolation for performance reasons.
        return openCode + string + closeCode
      }

      // Handle nested colors.

      // We could have done this, but it's too slow (as of Node.js 22).
      // return openCode + string.replaceAll(closeCode, openCode) + closeCode;

      let result = openCode
      let lastIndex = 0
      while (index !== -1) {
        result += string.slice(lastIndex, index) + openCode
        lastIndex = index + closeCode.length
        index = string.indexOf(closeCode, lastIndex)
      }
      result += string.slice(lastIndex) + closeCode
      return result
    }
  }
  const colors = {}
  colors.reset = format(0, 0)
  colors.bold = format(1, 22)
  colors.dim = format(2, 22)
  colors.italic = format(3, 23)
  colors.underline = format(4, 24)
  colors.overline = format(53, 55)
  colors.inverse = format(7, 27)
  colors.hidden = format(8, 28)
  colors.strikethrough = format(9, 29)
  colors.black = format(30, 39)
  colors.red = format(31, 39)
  colors.green = format(32, 39)
  colors.yellow = format(33, 39)
  colors.blue = format(34, 39)
  colors.magenta = format(35, 39)
  colors.cyan = format(36, 39)
  colors.white = format(37, 39)
  colors.gray = format(90, 39)
  colors.bgBlack = format(40, 49)
  colors.bgRed = format(41, 49)
  colors.bgGreen = format(42, 49)
  colors.bgYellow = format(43, 49)
  colors.bgBlue = format(44, 49)
  colors.bgMagenta = format(45, 49)
  colors.bgCyan = format(46, 49)
  colors.bgWhite = format(47, 49)
  colors.bgGray = format(100, 49)
  colors.redBright = format(91, 39)
  colors.greenBright = format(92, 39)
  colors.yellowBright = format(93, 39)
  colors.blueBright = format(94, 39)
  colors.magentaBright = format(95, 39)
  colors.cyanBright = format(96, 39)
  colors.whiteBright = format(97, 39)
  colors.bgRedBright = format(101, 49)
  colors.bgGreenBright = format(102, 49)
  colors.bgYellowBright = format(103, 49)
  colors.bgBlueBright = format(104, 49)
  colors.bgMagentaBright = format(105, 49)
  colors.bgCyanBright = format(106, 49)
  colors.bgWhiteBright = format(107, 49)
  yoctocolorsCjs = colors
  return yoctocolorsCjs
}

let yoctoSpinner
let hasRequiredYoctoSpinner
function requireYoctoSpinner() {
  if (hasRequiredYoctoSpinner) {
    return yoctoSpinner
  }
  hasRequiredYoctoSpinner = 1
  const defaultTtyColumns = 80
  let _defaultSpinner
  function getDefaultSpinner() {
    if (_defaultSpinner === undefined) {
      _defaultSpinner = {
        frames: isUnicodeSupported()
          ? ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']
          : ['-', '\\', '|', '/'],
        interval: 80
      }
    }
    return _defaultSpinner
  }
  let _logSymbols
  function getLogSymbols() {
    if (_logSymbols === undefined) {
      const supported = isUnicodeSupported()
      const colors = getYoctocolors()
      _logSymbols = {
        error: colors.red(supported ? '✖' : '×'),
        info: colors.blue(supported ? 'ℹ' : 'i'),
        success: colors.green(supported ? '✔' : '√'),
        warning: colors.yellow(supported ? '⚠' : '‼')
      }
    }
    return _logSymbols
  }
  let _process
  function getProcess() {
    if (_process === undefined) {
      // Use non-'node:' prefixed require to avoid Webpack errors.
      // eslint-disable-next-line n/prefer-node-protocol
      _process = require$$0$1
    }
    return _process
  }
  let _yoctocolors
  function getYoctocolors() {
    if (_yoctocolors === undefined) {
      _yoctocolors = {
        .../*@__PURE__*/ /*@__PURE__*/ requireYoctocolorsCjs()
      }
    }
    return _yoctocolors
  }
  let _processInteractive
  function isProcessInteractive() {
    if (_processInteractive === undefined) {
      const { env } = getProcess()
      _processInteractive = env.TERM !== 'dumb' && !('CI' in env)
    }
    return _processInteractive
  }
  let _unicodeSupported
  function isUnicodeSupported() {
    if (_unicodeSupported === undefined) {
      const process = getProcess()
      if (process.platform !== 'win32') {
        // Linux console (kernel).
        _unicodeSupported = process.env.TERM !== 'linux'
        return _unicodeSupported
      }
      const { env } = process
      if (
        // Windows Terminal.
        env.WT_SESSION ||
        // Terminus (<0.2.27).
        env.TERMINUS_SUBLIME ||
        // ConEmu and cmder.
        env.ConEmuTask === '{cmd::Cmder}'
      ) {
        _unicodeSupported = true
        return _unicodeSupported
      }
      const { TERM, TERM_PROGRAM } = env
      _unicodeSupported =
        TERM_PROGRAM === 'Terminus-Sublime' ||
        TERM_PROGRAM === 'vscode' ||
        TERM === 'xterm-256color' ||
        TERM === 'alacritty' ||
        TERM === 'rxvt-unicode' ||
        TERM === 'rxvt-unicode-256color' ||
        env.TERMINAL_EMULATOR === 'JetBrains-JediTerm'
    }
    return _unicodeSupported
  }
  let _stripVTControlCharacters
  function stripVTControlCharacters(string) {
    if (_stripVTControlCharacters === undefined) {
      // Use non-'node:' prefixed require to avoid Webpack errors.
      // eslint-disable-next-line n/prefer-node-protocol
      const nodeUtil = require$$2
      _stripVTControlCharacters = nodeUtil.stripVTControlCharacters
    }
    return _stripVTControlCharacters(string)
  }
  function normalizeText(value) {
    return typeof value === 'string' ? value.trimStart() : ''
  }
  class YoctoSpinner {
    #color
    #currentFrame = -1
    #exitHandlerBound
    #frames
    #indention = ''
    #interval
    #isInteractive
    #isSpinning = false
    #lastSpinnerFrameTime = 0
    #lines = 0
    #stream
    #text
    #timer
    constructor(options = {}) {
      const opts = {
        __proto__: null,
        ...options
      }
      const spinner = opts.spinner ?? getDefaultSpinner()
      const stream = opts.stream ?? getProcess().stderr
      const { frames } = spinner
      this.#frames =
        (frames?.length ?? 0) < 1 ? [''] : frames.map(f => f.trim())
      this.#interval = spinner.interval
      this.#text = normalizeText(options.text)
      this.#stream = stream ?? process.stderr
      this.#color = options.color ?? 'cyan'
      this.#isInteractive = !!stream.isTTY && isProcessInteractive()
      this.#exitHandlerBound = this.#exitHandler.bind(this)
    }
    #exitHandler(signal) {
      if (this.isSpinning) {
        this.stop()
      }
      // SIGINT: 128 + 2
      // SIGTERM: 128 + 15
      const exitCode =
        signal === 'SIGINT' ? 130 : signal === 'SIGTERM' ? 143 : 1
      // eslint-disable-next-line n/no-process-exit
      process.exit(exitCode)
    }
    #hideCursor() {
      if (this.#isInteractive) {
        this.#write('\u001B[?25l')
      }
    }
    #lineCount(text) {
      const width = this.#stream.columns ?? defaultTtyColumns
      const lines = stripVTControlCharacters(text).split('\n')
      let lineCount = 0
      for (const line of lines) {
        lineCount += Math.max(1, Math.ceil(line.length / width))
      }
      return lineCount
    }
    #render() {
      // Ensure we only update the spinner frame at the wanted interval,
      // even if the frame method is called more often.
      const now = Date.now()
      if (
        this.#currentFrame === -1 ||
        now - this.#lastSpinnerFrameTime >= this.#interval
      ) {
        this.#currentFrame = ++this.#currentFrame % this.#frames.length
        this.#lastSpinnerFrameTime = now
      }
      const colors = getYoctocolors()
      const applyColor = colors[this.#color] ?? colors.cyan
      const frame = this.#frames[this.#currentFrame]
      let string = `${frame ? `${applyColor(frame)} ` : ''}${this.#text}`
      if (string) {
        if (this.#indention.length) {
          string = `${this.#indention}${string}`
        }
        if (!this.#isInteractive) {
          string += '\n'
        }
      }
      if (this.#isInteractive) {
        this.clear()
      }
      if (string) {
        this.#write(string)
      }
      if (this.#isInteractive) {
        this.#lines = this.#lineCount(string)
      }
    }
    #showCursor() {
      if (this.#isInteractive) {
        this.#write('\u001B[?25h')
      }
    }
    #subscribeToProcessEvents() {
      process.once('SIGINT', this.#exitHandlerBound)
      process.once('SIGTERM', this.#exitHandlerBound)
    }
    #symbolStop(symbolType, text) {
      const symbols = getLogSymbols()
      return this.stop(`${symbols[symbolType]} ${text ?? this.#text}`)
    }
    #write(text) {
      this.#stream.write(text)
    }
    #unsubscribeFromProcessEvents() {
      process.off('SIGINT', this.#exitHandlerBound)
      process.off('SIGTERM', this.#exitHandlerBound)
    }
    get color() {
      return this.#color
    }
    set color(value) {
      this.#color = value
      this.#render()
    }
    get isSpinning() {
      return this.#isSpinning
    }
    get text() {
      return this.#text
    }
    set text(value) {
      this.#text = normalizeText(value)
      this.#render()
    }
    clear() {
      if (!this.#isInteractive) {
        return this
      }
      this.#stream.cursorTo(0)
      for (let index = 0; index < this.#lines; index += 1) {
        if (index > 0) {
          this.#stream.moveCursor(0, -1)
        }
        this.#stream.clearLine(1)
      }
      this.#lines = 0
      return this
    }
    dedent(spaces = 2) {
      this.#indention = this.#indention.slice(0, -spaces)
      return this
    }
    error(text) {
      return this.#symbolStop('error', text)
    }
    indent(spaces = 2) {
      this.#indention += ' '.repeat(spaces)
      return this
    }
    info(text) {
      return this.#symbolStop('info', text)
    }
    resetIndent() {
      this.#indention = ''
      return this
    }
    start(text) {
      const normalized = normalizeText(text)
      if (normalized) {
        this.#text = normalized
      }
      if (this.isSpinning) {
        return this
      }
      this.#isSpinning = true
      this.#hideCursor()
      this.#render()
      this.#subscribeToProcessEvents()

      // Only start the timer in interactive mode
      if (this.#isInteractive) {
        this.#timer = setInterval(() => {
          this.#render()
        }, this.#interval)
      }
      return this
    }
    stop(finalText) {
      if (!this.isSpinning) {
        return this
      }
      this.#isSpinning = false
      if (this.#timer) {
        clearInterval(this.#timer)
        this.#timer = undefined
      }
      this.#showCursor()
      this.clear()
      this.#unsubscribeFromProcessEvents()
      if (finalText) {
        this.#write(`${this.#indention}${finalText}\n`)
      }
      return this
    }
    success(text) {
      return this.#symbolStop('success', text)
    }
    warning(text) {
      return this.#symbolStop('warning', text)
    }
  }
  yoctoSpinner = function yoctoSpinner(options) {
    return new YoctoSpinner(options)
  }
  return yoctoSpinner
}

const yoctoSpinnerExports = /*@__PURE__*/ requireYoctoSpinner()

module.exports = yoctoSpinnerExports
