{"version":3,"file":"shadow-npm-inject.js","sources":["../src/shadow/npm/paths.mts","../src/shadow/npm/arborist/types.mts","../src/shadow/npm/arborist-helpers.mts","../src/shadow/npm/arborist/lib/arborist/index.mts","../src/shadow/npm/arborist/index.mts","../src/shadow/npm/inject.mts"],"sourcesContent":["import path from 'node:path'\n\nimport { normalizePath } from '@socketsecurity/registry/lib/path'\n\nimport constants from '../../constants.mts'\nimport { getNpmRequire } from '../../utils/npm-paths.mts'\n\nlet _arboristPkgPath: string | undefined\nexport function getArboristPackagePath() {\n  if (_arboristPkgPath === undefined) {\n    const pkgName = '@npmcli/arborist'\n    const mainPathWithForwardSlashes = normalizePath(\n      getNpmRequire().resolve(pkgName),\n    )\n    const arboristPkgPathWithForwardSlashes = mainPathWithForwardSlashes.slice(\n      0,\n      mainPathWithForwardSlashes.lastIndexOf(pkgName) + pkgName.length,\n    )\n    // Lazily access constants.WIN32.\n    _arboristPkgPath = constants.WIN32\n      ? path.normalize(arboristPkgPathWithForwardSlashes)\n      : arboristPkgPathWithForwardSlashes\n  }\n  return _arboristPkgPath\n}\n\nlet _arboristClassPath: string | undefined\nexport function getArboristClassPath() {\n  if (_arboristClassPath === undefined) {\n    _arboristClassPath = path.join(\n      getArboristPackagePath(),\n      'lib/arborist/index.js',\n    )\n  }\n  return _arboristClassPath\n}\n\nlet _arboristDepValidPath: string | undefined\nexport function getArboristDepValidPath() {\n  if (_arboristDepValidPath === undefined) {\n    _arboristDepValidPath = path.join(\n      getArboristPackagePath(),\n      'lib/dep-valid.js',\n    )\n  }\n  return _arboristDepValidPath\n}\n\nlet _arboristEdgeClassPath: string | undefined\nexport function getArboristEdgeClassPath() {\n  if (_arboristEdgeClassPath === undefined) {\n    _arboristEdgeClassPath = path.join(getArboristPackagePath(), 'lib/edge.js')\n  }\n  return _arboristEdgeClassPath\n}\n\nlet _arboristNodeClassPath: string | undefined\nexport function getArboristNodeClassPath() {\n  if (_arboristNodeClassPath === undefined) {\n    _arboristNodeClassPath = path.join(getArboristPackagePath(), 'lib/node.js')\n  }\n  return _arboristNodeClassPath\n}\n\nlet _arboristOverrideSetClassPath: string | undefined\nexport function getArboristOverrideSetClassPath() {\n  if (_arboristOverrideSetClassPath === undefined) {\n    _arboristOverrideSetClassPath = path.join(\n      getArboristPackagePath(),\n      'lib/override-set.js',\n    )\n  }\n  return _arboristOverrideSetClassPath\n}\n","import { createEnum } from '../../../utils/objects.mts'\n\nimport type {\n  Advisory as BaseAdvisory,\n  Arborist as BaseArborist,\n  Options as BaseArboristOptions,\n  AuditReport as BaseAuditReport,\n  Diff as BaseDiff,\n  Edge as BaseEdge,\n  Node as BaseNode,\n  BaseOverrideSet,\n  BuildIdealTreeOptions,\n  ReifyOptions,\n} from '@npmcli/arborist'\n\nexport type ArboristOptions = BaseArboristOptions & {\n  npmCommand?: string\n  npmVersion?: string\n}\n\nexport type ArboristClass = ArboristInstance & {\n  new (...args: any): ArboristInstance\n}\n\nexport type ArboristInstance = Omit<\n  typeof BaseArborist,\n  | 'actualTree'\n  | 'auditReport'\n  | 'buildIdealTree'\n  | 'diff'\n  | 'idealTree'\n  | 'loadActual'\n  | 'loadVirtual'\n  | 'reify'\n> & {\n  auditReport?: AuditReportInstance | null | undefined\n  actualTree?: NodeClass | null | undefined\n  diff: Diff | null\n  idealTree?: NodeClass | null | undefined\n  buildIdealTree(options?: BuildIdealTreeOptions): Promise<NodeClass>\n  loadActual(options?: ArboristOptions): Promise<NodeClass>\n  loadVirtual(options?: ArboristOptions): Promise<NodeClass>\n  reify(options?: ArboristReifyOptions): Promise<NodeClass>\n}\n\nexport type ArboristReifyOptions = ReifyOptions & ArboristOptions\n\nexport type AuditAdvisory = Omit<BaseAdvisory, 'id'> & {\n  id: number\n  cwe: string[]\n  cvss: {\n    score: number\n    vectorString: string\n  }\n  vulnerable_versions: string\n}\n\nexport type AuditReportInstance = Omit<BaseAuditReport, 'report'> & {\n  report: { [dependency: string]: AuditAdvisory[] }\n}\n\nexport const DiffAction = createEnum({\n  add: 'ADD',\n  change: 'CHANGE',\n  remove: 'REMOVE',\n})\n\nexport type Diff = Omit<\n  BaseDiff,\n  | 'actual'\n  | 'children'\n  | 'filterSet'\n  | 'ideal'\n  | 'leaves'\n  | 'removed'\n  | 'shrinkwrapInflated'\n  | 'unchanged'\n> & {\n  actual: NodeClass\n  children: Diff[]\n  filterSet: Set<NodeClass>\n  ideal: NodeClass\n  leaves: NodeClass[]\n  parent: Diff | null\n  removed: NodeClass[]\n  shrinkwrapInflated: Set<NodeClass>\n  unchanged: NodeClass[]\n}\n\nexport type EdgeClass = Omit<\n  BaseEdge,\n  | 'accept'\n  | 'detach'\n  | 'optional'\n  | 'overrides'\n  | 'peer'\n  | 'peerConflicted'\n  | 'rawSpec'\n  | 'reload'\n  | 'satisfiedBy'\n  | 'spec'\n  | 'to'\n> & {\n  optional: boolean\n  overrides: OverrideSetClass | undefined\n  peer: boolean\n  peerConflicted: boolean\n  rawSpec: string\n  get accept(): string | undefined\n  get spec(): string\n  get to(): NodeClass | null\n  new (...args: any): EdgeClass\n  detach(): void\n  reload(hard?: boolean): void\n  satisfiedBy(node: NodeClass): boolean\n}\n\nexport type LinkClass = Omit<NodeClass, 'isLink'> & {\n  readonly isLink: true\n}\n\nexport type NodeClass = Omit<\n  BaseNode,\n  | 'addEdgeIn'\n  | 'addEdgeOut'\n  | 'canDedupe'\n  | 'canReplace'\n  | 'canReplaceWith'\n  | 'children'\n  | 'deleteEdgeIn'\n  | 'edgesIn'\n  | 'edgesOut'\n  | 'from'\n  | 'hasShrinkwrap'\n  | 'inDepBundle'\n  | 'inShrinkwrap'\n  | 'integrity'\n  | 'isTop'\n  | 'matches'\n  | 'meta'\n  | 'name'\n  | 'overrides'\n  | 'packageName'\n  | 'parent'\n  | 'recalculateOutEdgesOverrides'\n  | 'resolve'\n  | 'resolveParent'\n  | 'root'\n  | 'target'\n  | 'updateOverridesEdgeInAdded'\n  | 'updateOverridesEdgeInRemoved'\n  | 'version'\n  | 'versions'\n> & {\n  name: string\n  version: string\n  children: Map<string, NodeClass | LinkClass>\n  edgesIn: Set<EdgeClass>\n  edgesOut: Map<string, EdgeClass>\n  from: NodeClass | null\n  hasShrinkwrap: boolean\n  inShrinkwrap: boolean | undefined\n  integrity?: string | null\n  isTop: boolean | undefined\n  meta: BaseNode['meta'] & {\n    addEdge(edge: EdgeClass): void\n  }\n  overrides: OverrideSetClass | undefined\n  target: NodeClass\n  versions: string[]\n  get inDepBundle(): boolean\n  get packageName(): string | null\n  get parent(): NodeClass | null\n  set parent(value: NodeClass | null)\n  get resolveParent(): NodeClass | null\n  get root(): NodeClass | null\n  set root(value: NodeClass | null)\n  new (...args: any): NodeClass\n  addEdgeIn(edge: EdgeClass): void\n  addEdgeOut(edge: EdgeClass): void\n  canDedupe(preferDedupe?: boolean): boolean\n  canReplace(node: NodeClass, ignorePeers?: string[]): boolean\n  canReplaceWith(node: NodeClass, ignorePeers?: string[]): boolean\n  deleteEdgeIn(edge: EdgeClass): void\n  matches(node: NodeClass): boolean\n  recalculateOutEdgesOverrides(): void\n  resolve(name: string): NodeClass\n  updateOverridesEdgeInAdded(\n    otherOverrideSet: OverrideSetClass | undefined,\n  ): boolean\n  updateOverridesEdgeInRemoved(otherOverrideSet: OverrideSetClass): boolean\n}\n\nexport interface OverrideSetClass\n  extends Omit<\n    BaseOverrideSet,\n    | 'ancestry'\n    | 'children'\n    | 'getEdgeRule'\n    | 'getMatchingRule'\n    | 'getNodeRule'\n    | 'parent'\n    | 'ruleset'\n  > {\n  children: Map<string, OverrideSetClass>\n  key: string | undefined\n  keySpec: string | undefined\n  name: string | undefined\n  parent: OverrideSetClass | undefined\n  value: string | undefined\n  version: string | undefined\n  // eslint-disable-next-line @typescript-eslint/no-misused-new\n  new (...args: any[]): OverrideSetClass\n  get isRoot(): boolean\n  get ruleset(): Map<string, OverrideSetClass>\n  ancestry(): Generator<OverrideSetClass>\n  childrenAreEqual(otherOverrideSet: OverrideSetClass | undefined): boolean\n  getEdgeRule(edge: EdgeClass): OverrideSetClass\n  getMatchingRule(node: NodeClass): OverrideSetClass | null\n  getNodeRule(node: NodeClass): OverrideSetClass\n  isEqual(otherOverrideSet: OverrideSetClass | undefined): boolean\n}\n","import semver from 'semver'\n\nimport { PackageURL } from '@socketregistry/packageurl-js'\nimport { getManifestData } from '@socketsecurity/registry'\nimport { debugFn } from '@socketsecurity/registry/lib/debug'\nimport { hasOwn } from '@socketsecurity/registry/lib/objects'\nimport { fetchPackagePackument } from '@socketsecurity/registry/lib/packages'\n\nimport constants from '../../constants.mts'\nimport { Edge } from './arborist/index.mts'\nimport { DiffAction } from './arborist/types.mts'\nimport { getAlertsMapFromPurls } from '../../utils/alerts-map.mts'\nimport { npa } from '../../utils/npm-package-arg.mts'\nimport { applyRange, getMajor, getMinVersion } from '../../utils/semver.mts'\nimport { idToNpmPurl } from '../../utils/spec.mts'\n\nimport type {\n  ArboristInstance,\n  Diff,\n  EdgeClass,\n  LinkClass,\n  NodeClass,\n} from './arborist/types.mts'\nimport type { AliasResult } from '../../utils/npm-package-arg.mts'\nimport type { RangeStyle } from '../../utils/semver.mts'\nimport type {\n  AlertIncludeFilter,\n  AlertsByPurl,\n} from '../../utils/socket-package-alert.mts'\nimport type { EditablePackageJson } from '@socketsecurity/registry/lib/packages'\nimport type { Spinner } from '@socketsecurity/registry/lib/spinner'\n\nconst { LOOP_SENTINEL, NPM, NPM_REGISTRY_URL } = constants\n\nfunction getUrlOrigin(input: string): string {\n  try {\n    // TODO: URL.parse is available in Node 22.1.0. We can use it when we drop Node 18.\n    // https://nodejs.org/docs/latest-v22.x/api/url.html#urlparseinput-base\n    // return URL.parse(input)?.origin ?? ''\n    return new URL(input).origin ?? ''\n  } catch {}\n  return ''\n}\n\nexport type BestPatchVersionOptions = {\n  minSatisfying?: boolean | undefined\n  vulnerableVersionRange?: string | undefined\n}\n\nexport function findBestPatchVersion(\n  node: NodeClass,\n  availableVersions: string[],\n  options?: BestPatchVersionOptions | undefined,\n): string | null {\n  const { minSatisfying = false, vulnerableVersionRange } = {\n    __proto__: null,\n    ...options,\n  } as BestPatchVersionOptions\n  const manifestData = getManifestData(NPM, node.name)\n  let eligibleVersions\n  if (manifestData && manifestData.name === manifestData.package) {\n    const major = getMajor(manifestData.version)\n    if (typeof major !== 'number') {\n      return null\n    }\n    eligibleVersions = availableVersions.filter(v => getMajor(v) === major)\n  } else {\n    const major = getMajor(node.version)\n    if (typeof major !== 'number') {\n      return null\n    }\n    eligibleVersions = availableVersions.filter(\n      v =>\n        // Filter for versions that are within the current major version and\n        // are NOT in the vulnerable range.\n        getMajor(v) === major &&\n        (!vulnerableVersionRange ||\n          !semver.satisfies(v, vulnerableVersionRange)),\n    )\n  }\n  if (eligibleVersions) {\n    const satisfying = minSatisfying\n      ? semver.minSatisfying\n      : semver.maxSatisfying\n    return satisfying(eligibleVersions, '*')\n  }\n  return null\n}\n\nexport function findPackageNode(\n  tree: NodeClass,\n  name: string,\n  version?: string | undefined,\n): NodeClass | undefined {\n  const queue: Array<NodeClass | LinkClass> = [tree]\n  const visited = new Set<NodeClass>()\n  let sentinel = 0\n  while (queue.length) {\n    if (sentinel++ === LOOP_SENTINEL) {\n      throw new Error('Detected infinite loop in findPackageNode')\n    }\n    const nodeOrLink = queue.pop()!\n    const node = getTargetNode(nodeOrLink)\n    if (visited.has(node)) {\n      continue\n    }\n    visited.add(node)\n    if (\n      node.name === name &&\n      (typeof version !== 'string' || node.version === version)\n    ) {\n      return node\n    }\n    for (const child of node.children.values()) {\n      queue.push(child)\n    }\n    for (const edge of node.edgesOut.values()) {\n      const { to } = edge\n      if (to) {\n        queue.push(to)\n      }\n    }\n  }\n  return undefined\n}\n\nexport function findPackageNodes(\n  tree: NodeClass,\n  name: string,\n  version?: string | undefined,\n): NodeClass[] {\n  const matches: NodeClass[] = []\n  const queue: Array<NodeClass | LinkClass> = [tree]\n  const visited = new Set<NodeClass>()\n  let sentinel = 0\n  while (queue.length) {\n    if (sentinel++ === LOOP_SENTINEL) {\n      throw new Error('Detected infinite loop in findPackageNodes')\n    }\n    const nodeOrLink = queue.pop()!\n    const node = getTargetNode(nodeOrLink)\n    if (visited.has(node)) {\n      continue\n    }\n    visited.add(node)\n\n    const { version: targetVersion } = node\n    if (!targetVersion && Array.isArray(node.errors) && node.errors.length) {\n      debugFn(\n        'notice',\n        `miss: version for ${node.name} due to errors:\\n`,\n        node.errors,\n      )\n    }\n    if (\n      node.name === name &&\n      (typeof version !== 'string' || node.version === version)\n    ) {\n      matches.push(node)\n    }\n    for (const child of node.children.values()) {\n      queue.push(child)\n    }\n    for (const edge of node.edgesOut.values()) {\n      const { to } = edge\n      if (to) {\n        queue.push(to)\n      }\n    }\n  }\n  return matches\n}\n\nexport type GetAlertsMapFromArboristOptions = {\n  consolidate?: boolean | undefined\n  include?: AlertIncludeFilter | undefined\n  nothrow?: boolean | undefined\n  spinner?: Spinner | undefined\n}\n\nexport async function getAlertsMapFromArborist(\n  arb: ArboristInstance,\n  options?: GetAlertsMapFromArboristOptions | undefined,\n): Promise<AlertsByPurl> {\n  const opts = {\n    __proto__: null,\n    consolidate: false,\n    include: undefined,\n    nothrow: false,\n    ...options,\n  } as GetAlertsMapFromArboristOptions\n\n  opts.include = {\n    __proto__: null,\n    // Leave 'actions' unassigned so it can be given a default value in\n    // subsequent functions where `options` is passed.\n    // actions: undefined,\n    blocked: true,\n    critical: true,\n    cve: true,\n    existing: false,\n    unfixable: true,\n    upgradable: false,\n    ...opts.include,\n  } as AlertIncludeFilter\n\n  const needInfoOn = getDetailsFromDiff(arb.diff, {\n    include: {\n      unchanged: opts.include.existing,\n    },\n  })\n\n  const purls = needInfoOn.map(d => idToNpmPurl(d.node.pkgid))\n\n  let overrides: { [key: string]: string } | undefined\n  const overridesMap = (\n    arb.actualTree ??\n    arb.idealTree ??\n    (await arb.loadActual())\n  )?.overrides?.children\n  if (overridesMap) {\n    overrides = Object.fromEntries(\n      Array.from(overridesMap.entries()).map(([key, overrideSet]) => {\n        return [key, overrideSet.value!]\n      }),\n    )\n  }\n\n  return await getAlertsMapFromPurls(purls, {\n    overrides,\n    ...options,\n  })\n}\n\nexport type DiffQueryIncludeFilter = {\n  unchanged?: boolean | undefined\n  unknownOrigin?: boolean | undefined\n}\n\nexport type DiffQueryOptions = {\n  include?: DiffQueryIncludeFilter | undefined\n}\n\nexport type PackageDetail = {\n  node: NodeClass\n  existing?: NodeClass | undefined\n}\n\nexport function getDetailsFromDiff(\n  diff: Diff | null,\n  options?: DiffQueryOptions | undefined,\n): PackageDetail[] {\n  const details: PackageDetail[] = []\n  // `diff` is `null` when `npm install --package-lock-only` is passed.\n  if (!diff) {\n    debugFn('notice', `miss: diff is ${diff}`)\n    return details\n  }\n\n  const include = {\n    __proto__: null,\n    unchanged: false,\n    unknownOrigin: true,\n    ...({ __proto__: null, ...options } as DiffQueryOptions).include,\n  } as DiffQueryIncludeFilter\n\n  const queue: Diff[] = [...diff.children]\n  let pos = 0\n  let { length: queueLength } = queue\n  while (pos < queueLength) {\n    if (pos === LOOP_SENTINEL) {\n      throw new Error('Detected infinite loop while walking Arborist diff')\n    }\n    const currDiff = queue[pos++]!\n    const { action } = currDiff\n    if (action) {\n      // The `pkgNode`, i.e. the `ideal` node, will be `undefined` if the diff\n      // action is 'REMOVE'\n      // The `oldNode`, i.e. the `actual` node, will be `undefined` if the diff\n      // action is 'ADD'.\n      const { actual: oldNode, ideal: pkgNode } = currDiff\n      let existing: NodeClass | undefined\n      let keep = false\n      if (action === DiffAction.change) {\n        if (pkgNode?.package.version !== oldNode?.package.version) {\n          keep = true\n          if (\n            oldNode?.package.name &&\n            oldNode.package.name === pkgNode?.package.name\n          ) {\n            existing = oldNode\n          }\n        }\n      } else {\n        keep = action !== DiffAction.remove\n      }\n      if (keep && pkgNode?.resolved && (!oldNode || oldNode.resolved)) {\n        if (\n          include.unknownOrigin ||\n          getUrlOrigin(pkgNode.resolved) === NPM_REGISTRY_URL\n        ) {\n          details.push({\n            node: pkgNode,\n            existing,\n          })\n        }\n      }\n    }\n    for (const child of currDiff.children) {\n      queue[queueLength++] = child\n    }\n  }\n  if (include.unchanged) {\n    const { unchanged } = diff\n    for (let i = 0, { length } = unchanged; i < length; i += 1) {\n      const pkgNode = unchanged[i]!\n      if (\n        include.unknownOrigin ||\n        getUrlOrigin(pkgNode.resolved!) === NPM_REGISTRY_URL\n      ) {\n        details.push({\n          node: pkgNode,\n          existing: pkgNode,\n        })\n      }\n    }\n  }\n  return details\n}\n\nexport function getTargetNode(nodeOrLink: NodeClass | LinkClass): NodeClass\nexport function getTargetNode<T>(nodeOrLink: T): NodeClass | null\nexport function getTargetNode(nodeOrLink: any): NodeClass | null {\n  return nodeOrLink?.isLink ? nodeOrLink.target : (nodeOrLink ?? null)\n}\n\nexport function isTopLevel(tree: NodeClass, node: NodeClass): boolean {\n  return getTargetNode(tree.children.get(node.name)) === node\n}\n\nexport type Packument = Exclude<\n  Awaited<ReturnType<typeof fetchPackagePackument>>,\n  null\n>\n\nexport function updateNode(\n  node: NodeClass,\n  newVersion: string,\n  newVersionPackument: Packument['versions'][number],\n): void {\n  // Object.defineProperty is needed to set the version property and replace\n  // the old value with newVersion.\n  Object.defineProperty(node, 'version', {\n    configurable: true,\n    enumerable: true,\n    get: () => newVersion,\n  })\n  // Update package.version associated with the node.\n  node.package.version = newVersion\n  // Update node.resolved.\n  const purlObj = PackageURL.fromString(idToNpmPurl(node.name))\n  node.resolved = `${NPM_REGISTRY_URL}/${node.name}/-/${purlObj.name}-${newVersion}.tgz`\n  // Update node.integrity with the targetPackument.dist.integrity value if available\n  // else delete node.integrity so a new value is resolved for the target version.\n  const { integrity } = newVersionPackument.dist\n  if (integrity) {\n    node.integrity = integrity\n  } else {\n    delete node.integrity\n  }\n  // Update node.package.deprecated based on targetPackument.deprecated.\n  if (hasOwn(newVersionPackument, 'deprecated')) {\n    node.package['deprecated'] = newVersionPackument.deprecated as string\n  } else {\n    delete node.package['deprecated']\n  }\n  // Update node.package.dependencies.\n  const newDeps = { ...newVersionPackument.dependencies }\n  const { dependencies: oldDeps } = node.package\n  node.package.dependencies = newDeps\n  if (oldDeps) {\n    for (const oldDepName of Object.keys(oldDeps)) {\n      if (!hasOwn(newDeps, oldDepName)) {\n        // Detach old edges for dependencies that don't exist on the updated\n        // node.package.dependencies.\n        node.edgesOut.get(oldDepName)?.detach()\n      }\n    }\n  }\n  for (const newDepName of Object.keys(newDeps)) {\n    if (!hasOwn(oldDeps, newDepName)) {\n      // Add new edges for dependencies that don't exist on the old\n      // node.package.dependencies.\n      node.addEdgeOut(\n        new Edge({\n          from: node,\n          name: newDepName,\n          spec: newDeps[newDepName],\n          type: 'prod',\n        }) as unknown as EdgeClass,\n      )\n    }\n  }\n}\n\nexport function updatePackageJsonFromNode(\n  editablePkgJson: EditablePackageJson,\n  tree: NodeClass,\n  node: NodeClass,\n  newVersion: string,\n  rangeStyle?: RangeStyle | undefined,\n): boolean {\n  let result = false\n  if (!isTopLevel(tree, node)) {\n    return result\n  }\n  const { name } = node\n  for (const depField of [\n    'dependencies',\n    'optionalDependencies',\n    'peerDependencies',\n  ]) {\n    const depObject = editablePkgJson.content[depField] as\n      | { [key: string]: string }\n      | undefined\n    const depValue = hasOwn(depObject, name) ? depObject[name] : undefined\n    if (typeof depValue !== 'string' || depValue.startsWith('catalog:')) {\n      continue\n    }\n    let oldRange = depValue\n    // Use npa if depValue looks like more than just a semver range.\n    if (depValue.includes(':')) {\n      const npaResult = npa(depValue)\n      if (!npaResult || (npaResult as AliasResult).subSpec) {\n        continue\n      }\n      oldRange = npaResult.rawSpec\n    }\n    const oldMin = getMinVersion(oldRange)\n    const newRange =\n      oldMin &&\n      // Ensure we're on the same major version...\n      getMajor(newVersion) === oldMin.major &&\n      // and not a downgrade.\n      semver.gte(newVersion, oldMin.version)\n        ? applyRange(oldRange, newVersion, rangeStyle)\n        : oldRange\n    if (oldRange !== newRange) {\n      result = true\n      editablePkgJson.update({\n        [depField]: {\n          ...depObject,\n          [name]: newRange,\n        },\n      })\n    }\n  }\n  return result\n}\n","// @ts-ignore\nimport UntypedArborist from '@npmcli/arborist/lib/arborist/index.js'\n\nimport { logger } from '@socketsecurity/registry/lib/logger'\n\nimport constants from '../../../../../constants.mts'\nimport { logAlertsMap } from '../../../../../utils/socket-package-alert.mts'\nimport { getAlertsMapFromArborist } from '../../../arborist-helpers.mts'\n\nimport type {\n  ArboristClass,\n  ArboristReifyOptions,\n  NodeClass,\n} from '../../types.mts'\n\nconst {\n  NPM,\n  NPX,\n  SOCKET_CLI_ACCEPT_RISKS,\n  SOCKET_CLI_SAFE_BIN,\n  SOCKET_CLI_SAFE_PROGRESS,\n  SOCKET_CLI_VIEW_ALL_RISKS,\n  kInternalsSymbol,\n  [kInternalsSymbol as unknown as 'Symbol(kInternalsSymbol)']: { getIpc },\n} = constants\n\nexport const SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = {\n  __proto__: null,\n  audit: false,\n  dryRun: true,\n  fund: false,\n  ignoreScripts: true,\n  progress: false,\n  save: false,\n  saveBundle: false,\n  silent: true,\n}\n\nexport const SAFE_WITH_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES = {\n  // @ts-ignore\n  __proto__: null,\n  ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n  dryRun: false,\n  save: true,\n}\n\nexport const kCtorArgs = Symbol('ctorArgs')\n\nexport const kRiskyReify = Symbol('riskyReify')\n\nexport const Arborist: ArboristClass = UntypedArborist\n\n// Implementation code not related to our custom behavior is based on\n// https://github.com/npm/cli/blob/v11.0.0/workspaces/arborist/lib/arborist/index.js:\nexport class SafeArborist extends Arborist {\n  constructor(...ctorArgs: ConstructorParameters<ArboristClass>) {\n    super(\n      {\n        path:\n          (ctorArgs.length ? ctorArgs[0]?.path : undefined) ?? process.cwd(),\n        ...(ctorArgs.length ? ctorArgs[0] : undefined),\n        ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n      },\n      ...ctorArgs.slice(1),\n    )\n    ;(this as any)[kCtorArgs] = ctorArgs\n  }\n\n  async [kRiskyReify](\n    ...args: Parameters<InstanceType<ArboristClass>['reify']>\n  ): Promise<NodeClass> {\n    const ctorArgs = (this as any)[kCtorArgs]\n    const arb = new Arborist(\n      {\n        ...(ctorArgs.length ? ctorArgs[0] : undefined),\n        progress: false,\n      },\n      ...ctorArgs.slice(1),\n    )\n    const ret = await (arb.reify as (...args: any[]) => Promise<NodeClass>)(\n      {\n        ...(args.length ? args[0] : undefined),\n        progress: false,\n      },\n      ...args.slice(1),\n    )\n    Object.assign(this, arb)\n    return ret\n  }\n\n  // @ts-ignore Incorrectly typed.\n  override async reify(\n    this: SafeArborist,\n    ...args: Parameters<InstanceType<ArboristClass>['reify']>\n  ): Promise<NodeClass> {\n    const options = {\n      __proto__: null,\n      ...(args.length ? args[0] : undefined),\n    } as ArboristReifyOptions\n    const ipc = await getIpc()\n    const binName = ipc[SOCKET_CLI_SAFE_BIN]\n    if (!binName) {\n      return await this[kRiskyReify](...args)\n    }\n    await super.reify(\n      {\n        ...options,\n        ...SAFE_NO_SAVE_ARBORIST_REIFY_OPTIONS_OVERRIDES,\n        progress: false,\n      },\n      // @ts-ignore: TypeScript gets grumpy about rest parameters.\n      ...args.slice(1),\n    )\n    // Lazily access constants.ENV.SOCKET_CLI_ACCEPT_RISKS.\n    const acceptRisks = constants.ENV.SOCKET_CLI_ACCEPT_RISKS\n    const progress = ipc[SOCKET_CLI_SAFE_PROGRESS]\n    const spinner =\n      options['silent'] || !progress\n        ? undefined\n        : // Lazily access constants.spinner.\n          constants.spinner\n    const isSafeNpm = binName === NPM\n    const isSafeNpx = binName === NPX\n    const alertsMap = await getAlertsMapFromArborist(this, {\n      spinner,\n      include:\n        acceptRisks || options.dryRun || options['yes']\n          ? {\n              actions: ['error'],\n              blocked: true,\n              critical: false,\n              cve: false,\n              existing: true,\n              unfixable: false,\n            }\n          : {\n              existing: isSafeNpx,\n              unfixable: isSafeNpm,\n            },\n    })\n    if (alertsMap.size) {\n      process.exitCode = 1\n      // Lazily access constants.ENV.SOCKET_CLI_VIEW_ALL_RISKS.\n      const viewAllRisks = constants.ENV.SOCKET_CLI_VIEW_ALL_RISKS\n      logAlertsMap(alertsMap, {\n        hideAt: viewAllRisks ? 'none' : 'middle',\n        output: process.stderr,\n      })\n      throw new Error(\n        `\n          Socket ${binName} exiting due to risks.${\n            viewAllRisks\n              ? ''\n              : `\\nView all risks - Rerun with environment variable ${SOCKET_CLI_VIEW_ALL_RISKS}=1.`\n          }${\n            acceptRisks\n              ? ''\n              : `\\nAccept risks - Rerun with environment variable ${SOCKET_CLI_ACCEPT_RISKS}=1.`\n          }\n        `.trim(),\n      )\n    } else if (!options['silent']) {\n      logger.success(\n        `Socket ${binName} ${acceptRisks ? 'accepted' : 'found no'} risks`,\n      )\n      if (binName === NPX) {\n        logger.log(`Running ${options.add![0]}`)\n      }\n    }\n    return await this[kRiskyReify](...args)\n  }\n}\n","import { createRequire } from 'node:module'\n\n// @ts-ignore\nimport UntypedEdge from '@npmcli/arborist/lib/edge.js'\n// @ts-ignore\nimport UntypedNode from '@npmcli/arborist/lib/node.js'\n// @ts-ignore\nimport UntypedOverrideSet from '@npmcli/arborist/lib/override-set.js'\n\nimport {\n  getArboristClassPath,\n  getArboristEdgeClassPath,\n  getArboristNodeClassPath,\n  getArboristOverrideSetClassPath,\n} from '../paths.mts'\nimport { Arborist, SafeArborist } from './lib/arborist/index.mts'\n\nimport type { EdgeClass, NodeClass, OverrideSetClass } from './types.mts'\n\nconst require = createRequire(import.meta.url)\n\nexport { Arborist, SafeArborist }\n\nexport const Edge: EdgeClass = UntypedEdge\n\nexport const Node: NodeClass = UntypedNode\n\nexport const OverrideSet: OverrideSetClass = UntypedOverrideSet\n\nexport function installSafeArborist() {\n  // Override '@npmcli/arborist' module exports with patched variants based on\n  // https://github.com/npm/cli/pull/8089.\n  const cache: { [key: string]: any } = require.cache\n  cache[getArboristClassPath()] = { exports: SafeArborist }\n  cache[getArboristEdgeClassPath()] = { exports: Edge }\n  cache[getArboristNodeClassPath()] = { exports: Node }\n  cache[getArboristOverrideSetClassPath()] = { exports: OverrideSet }\n}\n","import { installSafeArborist } from './arborist/index.mts'\n\ninstallSafeArborist()\n"],"names":["_arboristPkgPath","add","change","remove","NPM_REGISTRY_URL","minSatisfying","vulnerableVersionRange","__proto__","eligibleVersions","getMajor","visited","queue","to","version","debugFn","matches","consolidate","nothrow","blocked","critical","cve","existing","unfixable","upgradable","include","unchanged","unknownOrigin","length","action","actual","ideal","keep","node","Object","configurable","enumerable","integrity","dependencies","from","name","spec","type","semver","result","getIpc","audit","dryRun","fund","ignoreScripts","progress","save","saveBundle","silent","path","constants","hideAt","logger","cache","exports","installSafeArborist"],"mappings":";;;;;;;;;;;;;;AAOA;AACO;;;AAGH;AAGA;AAIA;AACAA;AAGF;AACA;AACF;AAEA;AACO;;;AAML;AACA;AACF;AAaA;AACO;;;AAGL;AACA;AACF;AAEA;AACO;;;AAGL;AACA;AACF;AAEA;AACO;;;AAML;AACA;AACF;;ACZO;AACLC;AACAC;AACAC;AACF;;ACjCA;;;AAA4BC;AAAiB;AAE7C;;AAEI;AACA;AACA;;;AAGF;AACF;AAOO;;AAKGC;AAAuBC;AAAuB;AACpDC;;;;AAIF;;AAEE;AACA;AACE;AACF;AACAC;AACF;AACE;AACA;AACE;AACF;AACAA;AAEI;AACA;AACAC;AAIN;AACA;;AAIE;AACF;AACA;AACF;AAEO;AAKL;AACA;;;AAGE;AACE;AACF;AACA;AACA;AACA;AACE;AACF;AACAC;AACA;AAIE;AACF;;AAEEC;AACF;;;AAEUC;AAAG;AACX;AACED;AACF;AACF;AACF;AACA;AACF;AAEO;;AAML;AACA;;;AAGE;AACE;AACF;AACA;AACA;AACA;AACE;AACF;AACAD;;AAEQG;AAAuB;AAC/B;AACEC;AAKF;AACA;AAIEC;AACF;;AAEEJ;AACF;;;AAEUC;AAAG;AACX;AACED;AACF;AACF;AACF;AACA;AACF;AASO;AAIL;AACEJ;AACAS;AAEAC;;;AAKAV;AACA;AACA;AACA;AACAW;AACAC;AACAC;AACAC;AACAC;AACAC;AACA;;AAGF;AACEC;AACEC;AACF;AACF;AAEA;AAEA;;AAMA;;AAGM;AACF;AAEJ;AAEA;;;AAGA;AACF;AAgBO;;AAKL;;AAEEX;AACA;AACF;AAEA;AACEP;AACAkB;AACAC;;AACMnB;;AAA4B;;AAGpC;;;AAEMoB;AAAoB;;;AAGtB;AACF;AACA;;AACQC;AAAO;AACf;AACE;AACA;AACA;AACA;;AACQC;AAAiBC;AAAe;AACxC;;AAEA;;AAEIC;AACA;AAIEV;AACF;AACF;AACF;AACEU;AACF;AACA;AACE;;AAKIC;AACAX;AACF;AACF;AACF;AACF;AACA;AACEV;AACF;AACF;;;AAEUc;AAAU;AAClB;AAAkBE;;AAChB;AACA;;AAKIK;AACAX;AACF;AACF;AACF;AACF;AACA;AACF;AAIO;;AAEP;AAEO;AACL;AACF;AAOO;AAKL;AACA;AACAY;AACEC;AACAC;;AAEF;AACA;AACAH;AACA;AACA;AACAA;AACA;AACA;;AACQI;;AACR;;AAEA;;AAEA;AACA;AACA;;AAEA;AACE;AACF;AACA;AACA;AAAkB;;;AACVC;;AACRL;AACA;;AAEI;AACE;AACA;;AAEF;AACF;AACF;;AAEE;AACE;AACA;AACAA;AAEIM;AACAC;AACAC;AACAC;AACF;AAEJ;AACF;AACF;AAEO;;AAQL;AACE;AACF;;AACQF;AAAK;;AAMX;AAGA;;AAEE;AACF;;AAEA;AACA;AACE;AACA;AACE;AACF;;AAEF;AACA;;AAGE;AACA9B;AACA;AACAiC;;AAIAC;;AAEE;AACE;AACA;AACF;AACF;AACF;AACF;AACA;AACF;;AC1cA;AAeA;;;;;;;;AAQE;AAA+DC;AAAO;AACxE;AAEO;AACLrC;AACAsC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACF;AAEO;AACL;AACA7C;AACA;AACAuC;AACAI;AACF;AAEO;AAEA;AAEA;;AAEP;AACA;AACO;;AAEH;AAEIG;;;;AAOF;AACJ;AAEA;AAGE;AACA;;AAGIJ;;AAIJ;;AAGIA;;AAIJhB;AACA;AACF;;AAEA;AACA;AAIE;AACE1B;;;AAGF;AACA;;;AAGA;;AAGI;AACA;AACA0C;;AAEF;AACA;AAEF;AACA;AACA;;AAIM;AACAK;AACN;AACA;AACA;;;;AAMUpC;AACAC;AACAC;AACAC;AACAC;AACF;AAEED;AACAC;AACF;AACR;;;AAGE;AACA;;AAEEiC;;AAEF;;AAGN;AAQA;AAGI;AACEC;;;AAKA;AACF;;AAEF;AACF;;ACxJA;AAIO;AAEA;AAEA;AAEA;AACL;AACA;AACA;AACAC;AAAkCC;;AAClCD;AAAsCC;;AACtCD;AAAsCC;;AACtCD;AAA6CC;;AAC/C;;ACnCAC;;;;;;;;;;","debugId":"bfd47197-3803-45f5-b7bf-b12f906816a9"}