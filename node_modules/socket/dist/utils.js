'use strict';

var vendor = require('./vendor.js');
var logger = require('../external/@socketsecurity/registry/lib/logger');
var strings = require('../external/@socketsecurity/registry/lib/strings');
var require$$6 = require('../external/@socketsecurity/registry/lib/debug');
var arrays = require('../external/@socketsecurity/registry/lib/arrays');
var require$$7 = require('../external/@socketsecurity/registry/lib/objects');
var path$1 = require('../external/@socketsecurity/registry/lib/path');
var sorts = require('../external/@socketsecurity/registry/lib/sorts');
var constants = require('./constants.js');
var flags = require('./flags.js');
var path = require('node:path');
var regexps = require('../external/@socketsecurity/registry/lib/regexps');
var prompts = require('../external/@socketsecurity/registry/lib/prompts');
var spawn = require('../external/@socketsecurity/registry/lib/spawn');
var fs = require('../external/@socketsecurity/registry/lib/fs');
var fs$1 = require('node:fs');
var registry = require('../external/@socketsecurity/registry');
var packages = require('../external/@socketsecurity/registry/lib/packages');
var require$$5 = require('node:module');
var npm = require('../external/@socketsecurity/registry/lib/npm');
var streams = require('../external/@socketsecurity/registry/lib/streams');
var globs = require('../external/@socketsecurity/registry/lib/globs');
var promises = require('node:timers/promises');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const sensitiveConfigKeyLookup = new Set(['apiToken']);
const supportedConfig = new Map([['apiBaseUrl', 'Base URL of the Socket API endpoint'], ['apiProxy', 'A proxy through which to access the Socket API'], ['apiToken', 'The Socket API token required to access most Socket API endpoints'], ['defaultOrg', 'The default org slug to use; usually the org your Socket API token has access to. When set, all orgSlug arguments are implied to be this value.'], ['enforcedOrgs', 'Orgs in this list have their security policies enforced on this machine'], ['skipAskToPersistDefaultOrg', 'This flag prevents the Socket CLI from asking you to persist the org slug when you selected one interactively'], ['org', 'Alias for defaultOrg']]);
const supportedConfigEntries = [...supportedConfig.entries()].sort((a, b) => sorts.naturalCompare(a[0], b[0]));
const supportedConfigKeys = supportedConfigEntries.map(p => p[0]);
function getConfigValues() {
  if (_cachedConfig === undefined) {
    // Order: env var > --config flag > file
    _cachedConfig = {};
    // Lazily access constants.socketAppDataPath.
    const {
      socketAppDataPath
    } = constants;
    if (socketAppDataPath) {
      const raw = fs.safeReadFileSync(socketAppDataPath);
      if (raw) {
        try {
          Object.assign(_cachedConfig, JSON.parse(Buffer.from(raw, 'base64').toString()));
        } catch {
          logger.logger.warn(`Failed to parse config at ${socketAppDataPath}`);
        }
        // Normalize apiKey to apiToken and persist it.
        // This is a one time migration per user.
        if (_cachedConfig['apiKey']) {
          const token = _cachedConfig['apiKey'];
          delete _cachedConfig['apiKey'];
          updateConfigValue('apiToken', token);
        }
      } else {
        fs$1.mkdirSync(path.dirname(socketAppDataPath), {
          recursive: true
        });
      }
    }
  }
  return _cachedConfig;
}
function normalizeConfigKey(key) {
  // Note: apiKey was the old name of the token. When we load a config with
  //       property apiKey, we'll copy that to apiToken and delete the old property.
  // We added `org` as a convenience alias for `defaultOrg`
  const normalizedKey = key === 'apiKey' ? 'apiToken' : key === 'org' ? 'defaultOrg' : key;
  if (!isSupportedConfigKey(normalizedKey)) {
    return {
      ok: false,
      message: `Invalid config key: ${normalizedKey}`,
      data: undefined
    };
  }
  return {
    ok: true,
    data: normalizedKey
  };
}
function findSocketYmlSync(dir = process.cwd()) {
  let prevDir = null;
  while (dir !== prevDir) {
    let ymlPath = path.join(dir, 'socket.yml');
    let yml = fs.safeReadFileSync(ymlPath);
    if (yml === undefined) {
      ymlPath = path.join(dir, 'socket.yaml');
      yml = fs.safeReadFileSync(ymlPath);
    }
    if (typeof yml === 'string') {
      try {
        return {
          path: ymlPath,
          parsed: vendor.configExports.parseSocketConfig(yml)
        };
      } catch {
        throw new Error(`Found file but was unable to parse ${ymlPath}`);
      }
    }
    prevDir = dir;
    dir = path.join(dir, '..');
  }
  return null;
}
function getConfigValue(key) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(key);
  if (!keyResult.ok) {
    return keyResult;
  }
  return {
    ok: true,
    data: localConfig[keyResult.data]
  };
}

// This version squashes errors, returning undefined instead.
// Should be used when we can reasonably predict the call can't fail.
function getConfigValueOrUndef(key) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(key);
  if (!keyResult.ok) {
    return undefined;
  }
  return localConfig[keyResult.data];
}

// Ensure export because dist/utils.js is required in src/constants.mts.
// eslint-disable-next-line n/exports-style
exports.getConfigValueOrUndef = getConfigValueOrUndef;
function getSupportedConfigEntries() {
  return [...supportedConfigEntries];
}
function getSupportedConfigKeys() {
  return [...supportedConfigKeys];
}
function isReadOnlyConfig() {
  return _readOnlyConfig;
}
function isSensitiveConfigKey(key) {
  return sensitiveConfigKeyLookup.has(key);
}
function isSupportedConfigKey(key) {
  return supportedConfig.has(key);
}
let _cachedConfig;
// When using --config or SOCKET_CLI_CONFIG, do not persist the config.
let _readOnlyConfig = false;
function overrideCachedConfig(jsonConfig) {
  require$$6.debugFn('notice', 'override: full config (not stored)');
  let config;
  try {
    config = JSON.parse(String(jsonConfig));
    if (!config || typeof config !== 'object') {
      // `null` is valid json, so are primitive values.
      // They're not valid config objects :)
      return {
        ok: false,
        message: 'Could not parse Config as JSON',
        cause: "Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again."
      };
    }
  } catch {
    // Force set an empty config to prevent accidentally using system settings.
    _cachedConfig = {};
    _readOnlyConfig = true;
    return {
      ok: false,
      message: 'Could not parse Config as JSON',
      cause: "Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again."
    };
  }

  // @ts-ignore Override an illegal object.
  _cachedConfig = config;
  _readOnlyConfig = true;

  // Normalize apiKey to apiToken.
  if (_cachedConfig['apiKey']) {
    if (_cachedConfig['apiToken']) {
      logger.logger.warn('Note: The config override had both apiToken and apiKey. Using the apiToken value. Remove the apiKey to get rid of this message.');
    }
    _cachedConfig['apiToken'] = _cachedConfig['apiKey'];
    delete _cachedConfig['apiKey'];
  }
  return {
    ok: true,
    data: undefined
  };
}
function overrideConfigApiToken(apiToken) {
  require$$6.debugFn('notice', 'override: Socket API token (not stored)');
  // Set token to the local cached config and mark it read-only so it doesn't persist.
  _cachedConfig = {
    ...vendor.configExports,
    ...(apiToken === undefined ? {} : {
      apiToken: String(apiToken)
    })
  };
  _readOnlyConfig = true;
}
let _pendingSave = false;
function updateConfigValue(configKey, value) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(configKey);
  if (!keyResult.ok) {
    return keyResult;
  }
  const key = keyResult.data;
  // Implicitly deleting when serializing.
  let wasDeleted = value === undefined;
  if (key === 'skipAskToPersistDefaultOrg') {
    if (value === 'true' || value === 'false') {
      localConfig['skipAskToPersistDefaultOrg'] = value === 'true';
    } else {
      delete localConfig['skipAskToPersistDefaultOrg'];
      wasDeleted = true;
    }
  } else {
    if (value === 'undefined' || value === 'true' || value === 'false') {
      logger.logger.warn(`Note: The value is set to "${value}", as a string (!). Use \`socket config unset\` to reset a key.`);
    }
    localConfig[key] = value;
  }
  if (_readOnlyConfig) {
    return {
      ok: true,
      message: `Config key '${key}' was ${wasDeleted ? 'deleted' : `updated`}`,
      data: 'Change applied but not persisted; current config is overridden through env var or flag'
    };
  }
  if (!_pendingSave) {
    _pendingSave = true;
    process.nextTick(() => {
      _pendingSave = false;
      // Lazily access constants.socketAppDataPath.
      const {
        socketAppDataPath
      } = constants;
      if (socketAppDataPath) {
        fs$1.writeFileSync(socketAppDataPath, Buffer.from(JSON.stringify(localConfig)).toString('base64'));
      }
    });
  }
  return {
    ok: true,
    message: `Config key '${key}' was ${wasDeleted ? 'deleted' : `updated`}`,
    data: undefined
  };
}

const TOKEN_PREFIX = 'sktsec_';
const {
  length: TOKEN_PREFIX_LENGTH
} = TOKEN_PREFIX;

// The Socket API server that should be used for operations.
function getDefaultApiBaseUrl$1() {
  const baseUrl =
  // Lazily access constants.ENV.SOCKET_CLI_API_BASE_URL.
  constants.ENV.SOCKET_CLI_API_BASE_URL || getConfigValueOrUndef('apiBaseUrl');
  return isUrl(baseUrl) ? baseUrl : undefined;
}

// The Socket API server that should be used for operations.
function getDefaultProxyUrl() {
  const apiProxy =
  // Lazily access constants.ENV.SOCKET_CLI_API_PROXY.
  constants.ENV.SOCKET_CLI_API_PROXY || getConfigValueOrUndef('apiProxy');
  return isUrl(apiProxy) ? apiProxy : undefined;
}
function isUrl(value) {
  if (strings.isNonEmptyString(value)) {
    try {
      // eslint-disable-next-line no-new
      new URL(value);
      return true;
    } catch {}
  }
  return false;
}

// This Socket API token should be stored globally for the duration of the CLI execution.
let _defaultToken;
function getDefaultToken() {
  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.
  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {
    _defaultToken = undefined;
  } else {
    const key =
    // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN.
    constants.ENV.SOCKET_CLI_API_TOKEN || getConfigValueOrUndef('apiToken') || _defaultToken;
    _defaultToken = strings.isNonEmptyString(key) ? key : undefined;
  }
  return _defaultToken;
}
function getVisibleTokenPrefix() {
  const apiToken = getDefaultToken();
  return apiToken ? apiToken.slice(TOKEN_PREFIX_LENGTH, TOKEN_PREFIX_LENGTH + 5) : '';
}
function hasDefaultToken() {
  return !!getDefaultToken();
}
function getPublicToken() {
  return getDefaultToken() ||
  // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN.
  constants.ENV.SOCKET_CLI_API_TOKEN ||
  // Lazily access constants.SOCKET_PUBLIC_API_TOKEN.
  constants.SOCKET_PUBLIC_API_TOKEN;
}
async function setupSdk(options) {
  const opts = {
    __proto__: null,
    ...options
  };
  let {
    apiToken = getDefaultToken()
  } = opts;
  if (typeof apiToken !== 'string' && vendor.isInteractiveExports()) {
    apiToken = await prompts.password({
      message: 'Enter your Socket.dev API token (not saved, use socket login to persist)'
    });
    _defaultToken = apiToken;
  }
  if (!apiToken) {
    return {
      ok: false,
      message: 'Auth Error',
      cause: 'You need to provide an API token. Run `socket login` first.'
    };
  }
  let {
    apiProxy
  } = opts;
  if (!isUrl(apiProxy)) {
    apiProxy = getDefaultProxyUrl();
  }
  const {
    apiBaseUrl = getDefaultApiBaseUrl$1()
  } = opts;
  const ProxyAgent = apiProxy?.startsWith('http:') ? vendor.HttpProxyAgent : vendor.HttpsProxyAgent;
  return {
    ok: true,
    data: new vendor.distExports.SocketSdk(apiToken, {
      agent: apiProxy ? new ProxyAgent({
        proxy: apiProxy
      }) : undefined,
      baseUrl: apiBaseUrl,
      userAgent: vendor.distExports.createUserAgentFromPkgJson({
        // Lazily access constants.ENV.INLINED_SOCKET_CLI_NAME.
        name: constants.ENV.INLINED_SOCKET_CLI_NAME,
        // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.
        version: constants.ENV.INLINED_SOCKET_CLI_VERSION,
        // Lazily access constants.ENV.INLINED_SOCKET_CLI_HOMEPAGE.
        homepage: constants.ENV.INLINED_SOCKET_CLI_HOMEPAGE
      })
    })
  };
}

const NO_ERROR_MESSAGE = 'No error message returned';

// The Socket API server that should be used for operations.
function getDefaultApiBaseUrl() {
  const baseUrl =
  // Lazily access constants.ENV.SOCKET_CLI_API_BASE_URL.
  constants.ENV.SOCKET_CLI_API_BASE_URL || getConfigValueOrUndef('apiBaseUrl');
  if (strings.isNonEmptyString(baseUrl)) {
    return baseUrl;
  }
  // Lazily access constants.API_V0_URL.
  const API_V0_URL = constants.API_V0_URL;
  return API_V0_URL;
}
async function getErrorMessageForHttpStatusCode(code) {
  if (code === 400) {
    return 'One of the options passed might be incorrect';
  }
  if (code === 403 || code === 401) {
    return 'Your Socket API token may not have the required permissions for this command or you might be trying to access (data from) an organization that is not linked to the API token you are logged in with';
  }
  if (code === 404) {
    return 'The requested Socket API endpoint was not found (404) or there was no result for the requested parameters. If unexpected, this could be a temporary problem caused by an incident or a bug in the CLI. If the problem persists please let us know.';
  }
  if (code === 500) {
    return 'There was an unknown server side problem with your request. This ought to be temporary. Please let us know if this problem persists.';
  }
  return `Server responded with status code ${code}`;
}
async function handleApiCall(value, options) {
  const {
    desc,
    spinner
  } = {
    __proto__: null,
    ...options
  };
  if (desc) {
    spinner?.start(`Requesting ${desc} from API...`);
  } else {
    spinner?.start();
  }
  let sdkResult;
  try {
    sdkResult = await value;
    spinner?.stop();
    if (desc) {
      const message = `Received Socket API response (after requesting ${desc}).`;
      if (sdkResult.success) {
        logger.logger.success(message);
      } else {
        logger.logger.info(message);
      }
    }
  } catch (e) {
    spinner?.stop();
    const socketSdkErrorResult = {
      ok: false,
      message: 'Socket API returned an error',
      cause: vendor.messageWithCauses(e)
    };
    if (desc) {
      logger.logger.fail(`An error was thrown while requesting ${desc}`);
      require$$6.debugFn('error', `caught: ${desc} error`);
    } else {
      require$$6.debugFn('error', `caught: Socket API request error`);
    }
    require$$6.debugDir('inspect', {
      error: e,
      socketSdkErrorResult
    });
    return socketSdkErrorResult;
  }

  // Note: TS can't narrow down the type of result due to generics.
  if (sdkResult.success === false) {
    const errorResult = sdkResult;
    const message = `${errorResult.error || NO_ERROR_MESSAGE}`;
    const {
      cause: reason
    } = errorResult;
    const socketSdkErrorResult = {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${reason ? ` ( Reason: ${reason} )` : ''}`,
      data: {
        code: sdkResult.status
      }
    };
    require$$6.debugFn('error', `fail:${desc ? ` ${desc}` : ''} bad response`);
    require$$6.debugDir('inspect', {
      sdkResult
    });
    return socketSdkErrorResult;
  }
  const socketSdkSuccessResult = {
    ok: true,
    data: sdkResult.data
  };
  return socketSdkSuccessResult;
}
async function handleApiCallNoSpinner(value, description) {
  let result;
  try {
    result = await value;
  } catch (e) {
    const message = `${e || NO_ERROR_MESSAGE}`;
    const reason = `${e || NO_ERROR_MESSAGE}`;
    require$$6.debugFn('error', `caught: ${description} error`);
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${reason ? ` ( Reason: ${reason} )` : ''}`
    };
  }

  // Note: TS can't narrow down the type of result due to generics
  if (result.success === false) {
    const error = result;
    const message = `${error.error || NO_ERROR_MESSAGE}`;
    require$$6.debugFn('error', `fail: ${description} bad response`);
    require$$6.debugDir('inspect', {
      error
    });
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${error.cause ? ` ( Reason: ${error.cause} )` : ''}`,
      data: {
        code: result.status
      }
    };
  } else {
    const ok = result;
    return {
      ok: true,
      data: ok.data
    };
  }
}
async function queryApi(path, apiToken) {
  const baseUrl = getDefaultApiBaseUrl() || '';
  if (!baseUrl) {
    logger.logger.warn('API endpoint is not set and default was empty. Request is likely to fail.');
  }
  return await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiToken}:`)}`
    }
  });
}
async function queryApiSafeText(path, fetchSpinnerDesc) {
  const apiToken = getDefaultToken();
  if (!apiToken) {
    return {
      ok: false,
      message: 'Authentication Error',
      cause: 'User must be authenticated to run this command. Run `socket login` and enter your Socket API token.'
    };
  }

  // Lazily access constants.spinner.
  const {
    spinner
  } = constants;
  if (fetchSpinnerDesc) {
    spinner.start(`Requesting ${fetchSpinnerDesc} from API...`);
  }
  let result;
  try {
    result = await queryApi(path, apiToken);
    if (fetchSpinnerDesc) {
      spinner.successAndStop(`Received Socket API response (after requesting ${fetchSpinnerDesc}).`);
    }
  } catch (e) {
    if (fetchSpinnerDesc) {
      spinner.failAndStop(`An error was thrown while requesting ${fetchSpinnerDesc}.`);
    }
    const cause = e?.message;
    require$$6.debugFn('error', 'caught: await queryApi() error');
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'API Request failed to complete',
      ...(cause ? {
        cause
      } : {})
    };
  }
  if (!result.ok) {
    const cause = await getErrorMessageForHttpStatusCode(result.status);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${result.statusText}${cause ? ` (cause: ${cause})` : ''}`
    };
  }
  try {
    const data = await result.text();
    return {
      ok: true,
      data
    };
  } catch (e) {
    require$$6.debugFn('error', 'caught: await result.text() error');
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'API Request failed to complete',
      cause: 'There was an unexpected error trying to read the response text'
    };
  }
}
async function queryApiSafeJson(path, fetchSpinnerDesc = '') {
  const result = await queryApiSafeText(path, fetchSpinnerDesc);
  if (!result.ok) {
    return result;
  }
  try {
    return {
      ok: true,
      data: JSON.parse(result.data)
    };
  } catch (e) {
    return {
      ok: false,
      message: 'Server returned invalid JSON',
      cause: `Please report this. JSON.parse threw an error over the following response: \`${(result.data?.slice?.(0, 100) || '<empty>').trim() + (result.data?.length > 100 ? '...' : '')}\``
    };
  }
}
async function sendApiRequest(path, options) {
  const apiToken = getDefaultToken();
  if (!apiToken) {
    return {
      ok: false,
      message: 'Authentication Error',
      cause: 'User must be authenticated to run this command. To log in, run the command `socket login` and enter your Socket API token.'
    };
  }
  const baseUrl = getDefaultApiBaseUrl() || '';
  if (!baseUrl) {
    logger.logger.warn('API endpoint is not set and default was empty. Request is likely to fail.');
  }

  // Lazily access constants.spinner.
  const {
    spinner
  } = constants;
  if (options.fetchSpinnerDesc) {
    spinner.start(`Requesting ${options.fetchSpinnerDesc} from API...`);
  }
  let result;
  try {
    const fetchOptions = {
      method: options.method,
      headers: {
        Authorization: `Basic ${btoa(`${apiToken}:`)}`,
        'Content-Type': 'application/json'
      },
      ...(options.body ? {
        body: JSON.stringify(options.body)
      } : {})
    };
    result = await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, fetchOptions);
    if (options.fetchSpinnerDesc) {
      spinner.successAndStop(`Received Socket API response (after requesting ${options.fetchSpinnerDesc}).`);
    }
  } catch (e) {
    if (options.fetchSpinnerDesc) {
      spinner.failAndStop(`An error was thrown while requesting ${options.fetchSpinnerDesc}.`);
    }
    const cause = e?.message;
    require$$6.debugFn('error', `caught: await fetch() ${options.method} error`);
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'API Request failed to complete',
      ...(cause ? {
        cause
      } : {})
    };
  }
  if (!result.ok) {
    const cause = await getErrorMessageForHttpStatusCode(result.status);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${result.statusText}${cause ? ` (cause: ${cause})` : ''}`,
      data: {
        code: result.status
      }
    };
  }
  try {
    const data = await result.json();
    return {
      ok: true,
      data: data
    };
  } catch (e) {
    require$$6.debugFn('error', 'caught: await result.json() error');
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'API Request failed to complete',
      cause: 'There was an unexpected error trying to parse the response JSON'
    };
  }
}

function failMsgWithBadge(badge, message) {
  const prefix = vendor.yoctocolorsCjsExports.bgRed(vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.white(` ${badge}${message ? ': ' : ''}`)));
  const postfix = message ? ` ${vendor.yoctocolorsCjsExports.bold(message)}` : '';
  return `${prefix}${postfix}`;
}

function mdTableStringNumber(title1, title2, obj) {
  // | Date        | Counts |
  // | ----------- | ------ |
  // | Header      | 201464 |
  // | Paragraph   |     18 |
  let mw1 = title1.length;
  let mw2 = title2.length;
  for (const [key, value] of Object.entries(obj)) {
    mw1 = Math.max(mw1, key.length);
    mw2 = Math.max(mw2, String(value ?? '').length);
  }
  const lines = [];
  lines.push(`| ${title1.padEnd(mw1, ' ')} | ${title2.padEnd(mw2)} |`);
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`);
  for (const [key, value] of Object.entries(obj)) {
    lines.push(`| ${key.padEnd(mw1, ' ')} | ${String(value ?? '').padStart(mw2, ' ')} |`);
  }
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`);
  return lines.join('\n');
}
function mdTable(logs,
// This is saying "an array of strings and the strings are a valid key of elements of T"
// In turn, T is defined above as the audit log event type from our OpenAPI docs.
cols, titles = cols) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length);
  for (const log of logs) {
    for (let i = 0, {
        length
      } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? '';
      cws[i] = Math.max(cws[i] ?? 0, String(val).length, (titles[i] || '').length);
    }
  }
  let div = '|';
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |';
  }
  let header = '|';
  for (let i = 0, {
      length
    } = titles; i < length; i += 1) {
    header += ' ' + String(titles[i]).padEnd(cws[i] ?? 0, ' ') + ' |';
  }
  let body = '';
  for (const log of logs) {
    body += '|';
    for (let i = 0, {
        length
      } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? '';
      body += ' ' + String(val).padEnd(cws[i] ?? 0, ' ') + ' |';
    }
    body += '\n';
  }
  return [div, header, div, body.trim(), div].filter(s => s.trim()).join('\n');
}
function mdTableOfPairs(arr,
// This is saying "an array of strings and the strings are a valid key of elements of T"
// In turn, T is defined above as the audit log event type from our OpenAPI docs.
cols) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length);
  for (const [key, val] of arr) {
    cws[0] = Math.max(cws[0] ?? 0, String(key).length);
    cws[1] = Math.max(cws[1] ?? 0, String(val ?? '').length);
  }
  let div = '|';
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |';
  }
  let header = '|';
  for (let i = 0, {
      length
    } = cols; i < length; i += 1) {
    header += ' ' + String(cols[i]).padEnd(cws[i] ?? 0, ' ') + ' |';
  }
  let body = '';
  for (const [key, val] of arr) {
    body += '|';
    body += ' ' + String(key).padEnd(cws[0] ?? 0, ' ') + ' |';
    body += ' ' + String(val ?? '').padEnd(cws[1] ?? 0, ' ') + ' |';
    body += '\n';
  }
  return [div, header, div, body.trim(), div].filter(s => s.trim()).join('\n');
}

// Serialize the final result object before printing it
// All commands that support the --json flag should call this before printing
function serializeResultJson(data) {
  if (typeof data !== 'object' || !data) {
    process.exitCode = 1;
    require$$6.debugFn('inspect', 'typeof data=', typeof data);
    if (typeof data !== 'object' && data) {
      require$$6.debugFn('inspect', 'data:\n', data);
    }

    // We should not allow the JSON value to be "null", or a boolean/number/string,
    // even if they are valid "json".
    const message = 'There was a problem converting the data set to JSON. The JSON was not an object. Please try again without --json';
    return JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      data: message
    }).trim() + '\n';
  }
  try {
    return JSON.stringify(data, null, 2).trim() + '\n';
  } catch (e) {
    process.exitCode = 1;

    // This could be caused by circular references, which is an "us" problem
    const message = 'There was a problem converting the data set to JSON. Please try again without --json';
    logger.logger.fail(message);
    require$$6.debugDir('inspect', {
      error: e
    });
    return JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      data: message
    }).trim() + '\n';
  }
}

function checkCommandInput(outputKind, ...checks) {
  if (checks.every(d => d.test)) {
    return true;
  }
  const msg = ['Please review the input requirements and try again', ''];
  for (const d of checks) {
    // If nook, then ignore when test is ok
    if (d.nook && d.test) {
      continue;
    }
    const lines = d.message.split('\n');
    const {
      length: lineCount
    } = lines;
    if (!lineCount) {
      continue;
    }
    // If the message has newlines then format the first line with the input
    // expectation and the rest indented below it.
    const logSymbol = d.test ? logger.LOG_SYMBOLS.success : logger.LOG_SYMBOLS.fail;
    const reason = d.test ? d.pass : d.fail;
    let listItem = `  ${logSymbol} ${lines[0]}`;
    if (reason) {
      const styledReason = d.test ? vendor.yoctocolorsCjsExports.green(reason) : vendor.yoctocolorsCjsExports.red(reason);
      listItem += ` (${styledReason})`;
    }
    msg.push(listItem);
    if (lineCount > 1) {
      msg.push(...lines.slice(1).map(str => `    ${str}`));
    }
  }

  // Use exit status of 2 to indicate incorrect usage, generally invalid
  // options or missing arguments.
  // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html
  process.exitCode = 2;
  if (outputKind === 'json') {
    logger.logger.log(serializeResultJson({
      ok: false,
      message: 'Input error',
      data: strings.stripAnsi(msg.join('\n'))
    }));
  } else {
    logger.logger.fail(failMsgWithBadge('Input error', msg.join('\n')));
  }
  return false;
}

function getOutputKind(json, markdown) {
  if (json) {
    return 'json';
  }
  if (markdown) {
    return 'markdown';
  }
  return 'text';
}

function camelToKebab(string) {
  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
function getFlagListOutput(list, options) {
  const {
    keyPrefix = '--'
  } = {
    __proto__: null,
    ...options
  };
  return getHelpListOutput({
    ...list
  }, {
    ...options,
    keyPrefix
  });
}
function getHelpListOutput(list, options) {
  const {
    indent = 6,
    keyPrefix = '',
    padName = 20
  } = {
    __proto__: null,
    ...options
  };
  let result = '';
  const names = Object.keys(list).sort(sorts.naturalCompare);
  for (const name of names) {
    const entry = list[name];
    const entryIsObj = require$$7.isObject(entry);
    if (entryIsObj && 'hidden' in entry && entry?.hidden) {
      continue;
    }
    const printedName = keyPrefix + camelToKebab(name);
    const preDescription = `${''.padEnd(indent)}${printedName.padEnd(Math.max(printedName.length + 2, padName))}`;
    result += preDescription;
    const description = entryIsObj ? entry.description : String(entry);
    if (description) {
      result += strings.indentString(description, preDescription.length).trimStart();
    }
    result += '\n';
  }
  return result.trim() || '(none)';
}

// Replace the start of a path with ~/ when it starts with your home dir.
// A common way to abbreviate the user home dir (though not strictly posix).
function tildify(cwd) {
  return cwd.replace(new RegExp(`^${regexps.escapeRegExp(constants.homePath)}(?:${path.sep}|$)`, 'i'), '~/');
}

// Property names are picked such that the name is at the top when the props
// get ordered by alphabet while flags is near the bottom and the help text
// at the bottom, because they tend ot occupy the most lines of code.

const HELP_INDENT = 2;
const HELP_PAD_NAME = 28;
function description(command) {
  const description = command?.description;
  const str = typeof description === 'string' ? description : String(description);
  return strings.indentString(str, HELP_PAD_NAME).trimStart();
}
async function meowWithSubcommands(subcommands, options) {
  const {
    aliases = {},
    argv,
    defaultSub,
    importMeta,
    name,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const [commandOrAliasName_, ...rawCommandArgv] = argv;
  let commandOrAliasName = commandOrAliasName_;
  if (!commandOrAliasName && defaultSub) {
    commandOrAliasName = defaultSub;
  }
  const flags$1 = {
    ...flags.commonFlags,
    version: {
      type: 'boolean',
      hidden: true,
      description: 'Print the app version'
    },
    ...additionalOptions.flags
  };

  // No further args or first arg is a flag (shrug)
  const isRootCommand = name === 'socket' && (!commandOrAliasName || commandOrAliasName?.startsWith('-'));

  // Try to support `socket <purl>` as a shorthand for `socket package score <purl>`
  if (!isRootCommand) {
    if (commandOrAliasName?.startsWith('pkg:')) {
      logger.logger.info('Invoking `socket package score`.');
      return await meowWithSubcommands(subcommands, {
        ...options,
        argv: ['package', 'deep', ...argv]
      });
    }
    // Support `socket npm/lodash` or whatever as a shorthand, too.
    // Accept any ecosystem and let the remote sort it out.
    if (/^[a-z]+\//.test(commandOrAliasName || '')) {
      logger.logger.info('Invoking `socket package score`.');
      return await meowWithSubcommands(subcommands, {
        ...options,
        argv: ['package', 'deep', `pkg:${commandOrAliasName}`, ...rawCommandArgv]
      });
    }
  }
  if (isRootCommand) {
    flags$1['help'] = {
      ...flags$1['help'],
      hidden: false
    };
    flags$1['config'] = {
      ...flags$1['config'],
      hidden: false
    };
    flags$1['dryRun'] = {
      ...flags$1['dryRun'],
      hidden: false
    };
    flags$1['maxOldSpaceSize'] = {
      ...flags$1['maxOldSpaceSize'],
      hidden: false
    };
    flags$1['maxSemiSpaceSize'] = {
      ...flags$1['maxSemiSpaceSize'],
      hidden: false
    };
    flags$1['version'] = {
      ...flags$1['version'],
      hidden: false
    };
    delete flags$1['json'];
    delete flags$1['markdown'];
  } else {
    delete flags$1['help'];
    delete flags$1['version'];
  }

  // This is basically a dry-run parse of cli args and flags. We use this to
  // determine config overrides and expected output mode.
  const cli1 = vendor.meow({
    argv,
    importMeta,
    ...additionalOptions,
    flags: flags$1,
    // Ensure we don't check unknown flags.
    allowUnknownFlags: true,
    // Prevent meow from potentially exiting early.
    autoHelp: false,
    autoVersion: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined
  });
  const orgFlag = String(cli1.flags['org'] || '') || undefined;

  // Hard override the config if instructed to do so.
  // The env var overrides the --flag, which overrides the persisted config
  // Also, when either of these are used, config updates won't persist.
  let configOverrideResult;
  // Lazily access constants.ENV.SOCKET_CLI_CONFIG.
  if (constants.ENV.SOCKET_CLI_CONFIG) {
    configOverrideResult = overrideCachedConfig(
    // Lazily access constants.ENV.SOCKET_CLI_CONFIG.
    constants.ENV.SOCKET_CLI_CONFIG);
  } else if (cli1.flags['config']) {
    configOverrideResult = overrideCachedConfig(String(cli1.flags['config'] || ''));
  }

  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.
  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {
    // This overrides the config override and even the explicit token env var.
    // The config will be marked as readOnly to prevent persisting it.
    overrideConfigApiToken(undefined);
  } else {
    // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN.
    const tokenOverride = constants.ENV.SOCKET_CLI_API_TOKEN;
    if (tokenOverride) {
      // This will set the token (even if there was a config override) and
      // set it to readOnly, making sure the temp token won't be persisted.
      overrideConfigApiToken(tokenOverride);
    }
  }
  if (configOverrideResult?.ok === false) {
    emitBanner(name, orgFlag);
    // Add newline in stderr.
    logger.logger.error('');
    logger.logger.fail(configOverrideResult.message);
    process.exitCode = 2;
    return;
  }

  // If we have got some args, then lets find out if we can find a command.
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName];
    // First: Resolve argv data from alias if its an alias that's been given.
    const [commandName, ...commandArgv] = alias ? [...alias.argv, ...rawCommandArgv] : [commandOrAliasName, ...rawCommandArgv];
    // Second: Find a command definition using that data.
    const commandDefinition = commandName ? subcommands[commandName] : undefined;
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      });
    }
  }
  const lines = ['', 'Usage', `  $ ${name} <command>`];
  if (isRootCommand) {
    lines.push(`  $ ${name} scan create --json`, `  $ ${name} package score npm lodash --markdown`);
  }
  lines.push('');
  if (isRootCommand) {
    // "Bucket" some commands for easier usage.
    const commands = new Set(['analytics', 'audit-log', 'ci', 'cdxgen', 'config', 'deps', 'fix', 'install',
    //'json',
    'license', 'login', 'logout', 'manifest', 'npm', 'npx', 'optimize', 'organization', 'package', 'raw-npm', 'raw-npx', 'repository', 'scan',
    //'security',
    'threat-feed', 'uninstall', 'wrapper']);
    Object.entries(subcommands).filter(([_name, subcommand]) => !subcommand.hidden).map(([name]) => name).forEach(name => {
      if (commands.has(name)) {
        commands.delete(name);
      } else {
        logger.logger.fail('Received a visible command that was not added to the list here:', name);
      }
    });
    if (commands.size) {
      logger.logger.fail('Found commands in the list that were not marked as public or not defined at all:',
      // Node < 22 will print 'Object (n)' before the array. So to have consistent
      // test snapshots we use joinAnd.
      arrays.joinAnd(Array.from(commands).sort(sorts.naturalCompare).map(c => `'${c}'`)));
    }
    lines.push('Note: All commands have their own --help', '', 'Main commands', `  socket login                ${description(subcommands['login'])}`, `  socket scan create          Create a new Socket scan and report`, `  socket npm/lodash@4.17.21   Request the Socket score of a package`, `  socket ci                   ${description(subcommands['ci'])}`, ``, 'Socket API', `  analytics                   ${description(subcommands['analytics'])}`, `  audit-log                   ${description(subcommands['audit-log'])}`, `  organization                ${description(subcommands['organization'])}`, `  package                     ${description(subcommands['package'])}`, `  repository                  ${description(subcommands['repository'])}`, `  scan                        ${description(subcommands['scan'])}`, `  threat-feed                 ${description(subcommands['threat-feed'])}`, ``, 'Local tools', `  fix                         ${description(subcommands['fix'])}`, `  manifest                    ${description(subcommands['manifest'])}`, `  npm                         ${description(subcommands['npm'])}`, `  npx                         ${description(subcommands['npx'])}`, `  optimize                    ${description(subcommands['optimize'])}`, `  raw-npm                     ${description(subcommands['raw-npm'])}`, `  raw-npx                     ${description(subcommands['raw-npx'])}`, '', 'CLI configuration', `  config                      ${description(subcommands['config'])}`, `  install                     ${description(subcommands['install'])}`, `  login                       Socket API login and CLI setup`, `  logout                      ${description(subcommands['logout'])}`, `  uninstall                   ${description(subcommands['uninstall'])}`, `  wrapper                     ${description(subcommands['wrapper'])}`);
  } else {
    lines.push('Commands');
    lines.push(`  ${getHelpListOutput({
      ...require$$7.toSortedObject(Object.fromEntries(Object.entries(subcommands).filter(({
        1: subcommand
      }) => !subcommand.hidden))),
      ...require$$7.toSortedObject(Object.fromEntries(Object.entries(aliases).filter(({
        1: alias
      }) => {
        const {
          hidden
        } = alias;
        const cmdName = hidden ? '' : alias.argv[0];
        const subcommand = cmdName ? subcommands[cmdName] : undefined;
        return subcommand && !subcommand.hidden;
      })))
    }, {
      indent: HELP_INDENT,
      padName: HELP_PAD_NAME
    })}`);
  }
  lines.push('', 'Options');
  if (isRootCommand) {
    lines.push('  Note: All commands have these flags even when not displayed in their help', '');
  } else {
    lines.push('');
  }
  lines.push(`  ${getFlagListOutput(flags$1, {
    indent: HELP_INDENT,
    padName: HELP_PAD_NAME
  })}`);
  if (isRootCommand) {
    lines.push('', 'Environment variables', '  SOCKET_CLI_API_TOKEN        Set the Socket API token', '  SOCKET_CLI_CONFIG           A JSON stringified Socket configuration object', '  SOCKET_CLI_GITHUB_API_URL   Change the base URL for GitHub REST API calls', '  SOCKET_CLI_GIT_USER_EMAIL   The git config `user.email` used by Socket CLI', `                              ${vendor.yoctocolorsCjsExports.italic('Defaults:')} github-actions[bot]@users.noreply.github.com`, '  SOCKET_CLI_GIT_USER_NAME    The git config `user.name` used by Socket CLI', `                              ${vendor.yoctocolorsCjsExports.italic('Defaults:')} github-actions[bot]`, `  SOCKET_CLI_GITHUB_TOKEN     A classic or fine-grained ${vendor.terminalLinkExports('GitHub personal access token', 'https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens')}`, `                              ${vendor.yoctocolorsCjsExports.italic('Aliases:')} GITHUB_TOKEN`, '  SOCKET_CLI_NO_API_TOKEN     Make the default API token `undefined`', '  SOCKET_CLI_NPM_PATH         The absolute location of the npm directory', '  SOCKET_CLI_ORG_SLUG         Specify the Socket organization slug', '', '  SOCKET_CLI_ACCEPT_RISKS     Accept risks of a Socket wrapped npm/npx run', '  SOCKET_CLI_VIEW_ALL_RISKS   View all risks of a Socket wrapped npm/npx run', '', 'Environment variables for development', '  SOCKET_CLI_API_BASE_URL     Change the base URL for Socket API calls', `                              ${vendor.yoctocolorsCjsExports.italic('Defaults:')} The "apiBaseUrl" value of socket/settings local app data`, '                              if present, else https://api.socket.dev/v0/', '  SOCKET_CLI_API_PROXY        Set the proxy all requests are routed through, e.g. if set to', `                              ${vendor.terminalLinkExports('http://127.0.0.1:9090', 'https://docs.proxyman.io/troubleshooting/couldnt-see-any-requests-from-3rd-party-network-libraries')} then all request are passed through that proxy`, `                              ${vendor.yoctocolorsCjsExports.italic('Aliases:')} HTTPS_PROXY, https_proxy, HTTP_PROXY, and http_proxy`, '  SOCKET_CLI_DEBUG            Enable debug logging in Socket CLI', `  DEBUG                       Enable debug logging based on the ${vendor.terminalLinkExports('debug', 'https://socket.dev/npm/package/debug')} package`);
  }

  // Parse it again. Config overrides should now be applied (may affect help).
  // Note: this is displayed as help screen if the command does not override it
  //       (which is the case for most sub-commands with sub-commands)
  const cli2 = vendor.meow({
    argv,
    importMeta,
    ...additionalOptions,
    flags: flags$1,
    // Do not strictly check for flags here.
    allowUnknownFlags: true,
    // We will emit help when we're ready.
    // Plus, if we allow this then meow may exit here.
    autoHelp: false,
    autoVersion: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined,
    help: lines.map(l => strings.indentString(l, HELP_INDENT)).join('\n')
  });

  // ...else we provide basic instructions and help.
  if (!cli2.flags['nobanner']) {
    emitBanner(name, orgFlag);
    // meow will add newline so don't add stderr spacing here
  }
  if (!cli2.flags['help'] && cli2.flags['dryRun']) {
    process.exitCode = 0;
    // Lazily access constants.DRY_RUN_LABEL.
    logger.logger.log(`${constants.DRY_RUN_LABEL}: No-op, call a sub-command; ok`);
  } else {
    // When you explicitly request --help, the command should be successful
    // so we exit(0). If we do it because we need more input, we exit(2).
    cli2.showHelp(cli2.flags['help'] ? 0 : 2);
  }
}

/**
 * Note: meow will exit immediately if it calls its .showHelp()
 */
function meowOrExit({
  allowUnknownFlags = true,
  argv,
  config,
  importMeta,
  parentName
}) {
  const command = `${parentName} ${config.commandName}`;

  // This exits if .printHelp() is called either by meow itself or by us.
  const cli = vendor.meow({
    argv,
    // Prevent meow from potentially exiting early.
    autoHelp: false,
    autoVersion: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined,
    collectUnknownFlags: true,
    description: config.description,
    flags: config.flags,
    help: strings.trimNewlines(config.help(command, config)),
    importMeta
  });
  if (!cli.flags['nobanner']) {
    emitBanner(command, String(cli.flags['org'] || '') || undefined);
    // Add newline in stderr.
    // Meow help adds a newline too so we do it here.
    logger.logger.error('');
  }

  // As per https://github.com/sindresorhus/meow/issues/178
  // Setting `allowUnknownFlags: false` makes it reject camel cased flags.
  // if (!allowUnknownFlags) {
  //   // Run meow specifically with the flag setting. It will exit(2) if an
  //   // invalid flag is set and print a message.
  //   meow({
  //     argv,
  //     allowUnknownFlags: false,
  //     // Prevent meow from potentially exiting early.
  //     autoHelp: false,
  //     autoVersion: false,
  //     description: config.description,
  //     flags: config.flags,
  //     help: trimNewlines(config.help(command, config)),
  //     importMeta,
  //   })
  // }

  if (cli.flags['help']) {
    cli.showHelp(0);
  }

  // meow doesn't detect 'version' as an unknown flag, so we do the leg work here.
  if (!require$$7.hasOwn(config.flags, 'version') && cli.flags['version']) {
    // Use `console.error` here instead of `logger.error` to match meow behavior.
    console.error('Unknown flag\n--version');
    // eslint-disable-next-line n/no-process-exit
    process.exit(2);
  }

  // Now test for help state. Run meow again. If it exits now, it must be due
  // to wanting to print the help screen. But it would exit(0) and we want a
  // consistent exit(2) for that case (missing input).
  // TODO: Move away from meow.
  process.exitCode = 2;
  vendor.meow({
    argv,
    // As per https://github.com/sindresorhus/meow/issues/178
    // Setting `allowUnknownFlags: false` makes it reject camel cased flags.
    allowUnknownFlags: Boolean(allowUnknownFlags),
    // Prevent meow from potentially exiting early.
    autoHelp: false,
    autoVersion: false,
    description: config.description,
    help: strings.trimNewlines(config.help(command, config)),
    importMeta,
    flags: config.flags
  });
  // Ok, no help, reset to default.
  process.exitCode = 0;
  return cli;
}
function emitBanner(name, orgFlag) {
  // Print a banner at the top of each command.
  // This helps with brand recognition and marketing.
  // It also helps with debugging since it contains version and command details.
  // Note: print over stderr to preserve stdout for flags like --json and
  //       --markdown. If we don't do this, you can't use --json in particular
  //       and pipe the result to other tools. By emitting the banner over stderr
  //       you can do something like `socket scan view xyz | jq | process`.
  //       The spinner also emits over stderr for example.
  logger.logger.error(getAsciiHeader(name, orgFlag));
}
function getAsciiHeader(command, orgFlag) {
  // Note: In tests we return <redacted> because otherwise snapshots will fail.
  const {
    REDACTED
  } = constants;
  // Lazily access constants.ENV.VITEST.
  const redacting = constants.ENV.VITEST;
  const cliVersion = redacting ? REDACTED :
  // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH.
  constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH;
  const nodeVersion = redacting ? REDACTED : process.version;
  const defaultOrg = getConfigValueOrUndef('defaultOrg');
  const readOnlyConfig = isReadOnlyConfig() ? '*' : '.';
  const shownToken = redacting ? REDACTED : getVisibleTokenPrefix() || '(not set)';
  const relCwd = redacting ? REDACTED : path$1.normalizePath(tildify(process.cwd()));
  // Note: we must redact org when creating snapshots because dev machine probably
  //       has a default org set but CI won't. Showing --org is fine either way.
  const orgPart = orgFlag ? `--org: ${orgFlag}` : redacting ? 'org: <redacted>' : defaultOrg ? `default org: ${defaultOrg}` : '(org not set)';
  // Note: We could draw these with ascii box art instead but I worry about
  //       portability and paste-ability. "simple" ascii chars just work.
  const body = `
   _____         _       _        /---------------
  |   __|___ ___| |_ ___| |_      | Socket.dev CLI ver ${cliVersion}
  |__   | ${readOnlyConfig} |  _| '_| -_|  _|     | Node: ${nodeVersion}, API token: ${shownToken}, ${orgPart}
  |_____|___|___|_,_|___|_|.dev   | Command: \`${command}\`, cwd: ${relCwd}
  `.trim();
  // Note: logger will auto-append a newline.
  return `   ${body}`;
}

function msAtHome(isoTimeStamp) {
  const timeStart = Date.parse(isoTimeStamp);
  const timeEnd = Date.now();
  const rtf = new Intl.RelativeTimeFormat('en', {
    numeric: 'always',
    style: 'short'
  });
  const delta = timeEnd - timeStart;
  if (delta < 60 * 60 * 1000) {
    return rtf.format(-Math.round(delta / (60 * 1000)), 'minute');
    // return Math.round(delta / (60 * 1000)) + ' min ago'
  } else if (delta < 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (60 * 60 * 1000)).toFixed(1), 'hour');
    // return (delta / (60 * 60 * 1000)).toFixed(1) + ' hr ago'
  } else if (delta < 7 * 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (24 * 60 * 60 * 1000)).toFixed(1), 'day');
    // return (delta / (24 * 60 * 60 * 1000)).toFixed(1) + ' day ago'
  } else {
    return isoTimeStamp.slice(0, 10);
  }
}

async function fetchOrganization(options) {
  const {
    sdkOptions
  } = {
    __proto__: null,
    ...options
  };
  const sockSdkCResult = await setupSdk(sdkOptions);
  if (!sockSdkCResult.ok) {
    return sockSdkCResult;
  }
  const sockSdk = sockSdkCResult.data;
  return await handleApiCall(sockSdk.getOrganizations(), {
    desc: 'organization list'
  });
}

async function suggestOrgSlug() {
  const orgsCResult = await fetchOrganization();
  if (!orgsCResult.ok) {
    logger.logger.fail('Failed to lookup organization list from API, unable to suggest');
    return undefined;
  }

  // Ignore a failed request here. It was not the primary goal of
  // running this command and reporting it only leads to end-user confusion.
  const {
    organizations
  } = orgsCResult.data;
  const proceed = await prompts.select({
    message: 'Missing org name; do you want to use any of these orgs for this scan?',
    choices: [...Object.values(organizations).map(o => {
      const name = o.name ?? o.slug;
      return {
        name: `Yes [${name}]`,
        value: name,
        description: `Use "${name}" as the organization`
      };
    }), {
      name: 'No',
      value: '',
      description: 'Do not use any of these organizations (will end in a no-op)'
    }]
  });
  if (proceed) {
    return proceed;
  }
  return undefined;
}

async function suggestToPersistOrgSlug(orgSlug) {
  const skipAsk = getConfigValue('skipAskToPersistDefaultOrg');
  if (!skipAsk.ok || skipAsk.data) {
    // Don't ask to store it when disabled before, or when reading config fails.
    return;
  }
  const result = await prompts.select({
    message: `Would you like to use this org (${orgSlug}) as the default org for future calls?`,
    choices: [{
      name: 'Yes',
      value: 'yes',
      description: 'Stores it in your config'
    }, {
      name: 'No',
      value: 'no',
      description: 'Do not persist this org as default org'
    }, {
      name: "No and don't ask again",
      value: 'sush',
      description: 'Do not store as default org and do not ask again to persist it'
    }]
  });
  if (result === 'yes') {
    const updateResult = updateConfigValue('defaultOrg', orgSlug);
    if (updateResult.ok) {
      logger.logger.success('Updated default org config to:', orgSlug);
    } else {
      logger.logger.fail('(Non blocking) Failed to update default org in config:', updateResult.cause);
    }
  } else if (result === 'sush') {
    const updateResult = updateConfigValue('skipAskToPersistDefaultOrg', true);
    if (updateResult.ok) {
      logger.logger.info('Default org not changed. Will not ask to persist again.');
    } else {
      logger.logger.fail(`(Non blocking) Failed to store preference; will ask to persist again next time. Reason: ${updateResult.cause}`);
    }
  }
}

async function determineOrgSlug(orgFlag, interactive, dryRun) {
  const defaultOrgSlug = getConfigValueOrUndef('defaultOrg');
  let orgSlug = String(orgFlag || defaultOrgSlug || '');
  if (!orgSlug) {
    if (!interactive) {
      logger.logger.warn('Note: This command requires an org slug because the Socket API endpoint does.');
      logger.logger.warn('');
      logger.logger.warn('It seems no default org was setup and the `--org` flag was not used.');
      logger.logger.warn("Additionally, `--no-interactive` was set so we can't ask for it.");
      logger.logger.warn('Since v1.0.0 the org _argument_ for all commands was dropped in favor of an');
      logger.logger.warn('implicit default org setting, which will be setup when you run `socket login`.');
      logger.logger.warn('');
      logger.logger.warn('Note: When running in CI, you probably want to set the `--org` flag.');
      logger.logger.warn('');
      logger.logger.warn('For details, see: https://docs.socket.dev/docs/v1-migration-guide');
      logger.logger.warn('');
      logger.logger.warn('This command will exit now because the org slug is required to proceed.');
      return ['', undefined];
    }
    logger.logger.warn('Unable to determine the target org. Trying to auto-discover it now...');
    logger.logger.info('Note: Run `socket login` to set a default org.');
    logger.logger.error('      Use the --org flag to override the default org.');
    logger.logger.error('');
    if (dryRun) {
      logger.logger.fail('Skipping auto-discovery of org in dry-run mode');
    } else {
      orgSlug = (await suggestOrgSlug()) || '';
      if (orgSlug) {
        await suggestToPersistOrgSlug(orgSlug);
      }
    }
  }
  return [orgSlug, defaultOrgSlug];
}

// Use the config defaultOrg when set, otherwise discover from remote.
async function getDefaultOrgSlug() {
  const defaultOrgResult = getConfigValueOrUndef('defaultOrg');
  if (defaultOrgResult) {
    require$$6.debugFn('notice', 'use: org from "defaultOrg" value of socket/settings local app data', defaultOrgResult);
    return {
      ok: true,
      data: defaultOrgResult
    };
  }

  // Lazily access constants.ENV.SOCKET_CLI_ORG_SLUG.
  const envOrgSlug = constants.ENV.SOCKET_CLI_ORG_SLUG;
  if (envOrgSlug) {
    require$$6.debugFn('notice', 'use: org from SOCKET_CLI_ORG_SLUG environment variable', envOrgSlug);
    return {
      ok: true,
      data: envOrgSlug
    };
  }
  const orgsCResult = await fetchOrganization();
  if (!orgsCResult.ok) {
    return orgsCResult;
  }
  const {
    organizations
  } = orgsCResult.data;
  const keys = Object.keys(organizations);
  if (!keys.length) {
    return {
      ok: false,
      message: 'Failed to establish identity',
      data: `No organization associated with the Socket API token. Unable to continue.`
    };
  }
  const slug = organizations[keys[0]]?.name ?? undefined;
  if (!slug) {
    return {
      ok: false,
      message: 'Failed to establish identity',
      data: `Cannot determine the default organization for the API token. Unable to continue.`
    };
  }
  require$$6.debugFn('notice', 'resolve: org from Socket API', slug);
  return {
    ok: true,
    message: 'Retrieved default org from server',
    data: slug
  };
}

async function getBaseBranch(cwd = process.cwd()) {
  // Lazily access constants.ENV properties.
  const {
    GITHUB_BASE_REF,
    GITHUB_REF_NAME,
    GITHUB_REF_TYPE
  } = constants.ENV;
  // 1. In a pull request, this is always the base branch.
  if (GITHUB_BASE_REF) {
    return GITHUB_BASE_REF;
  }
  // 2. If it's a branch (not a tag), GITHUB_REF_TYPE should be 'branch'.
  if (GITHUB_REF_TYPE === 'branch' && GITHUB_REF_NAME) {
    return GITHUB_REF_NAME;
  }
  // 3. Try to resolve the default remote branch using 'git remote show origin'.
  // This handles detached HEADs or workflows triggered by tags/releases.
  try {
    const originDetails = (await spawn.spawn('git', ['remote', 'show', 'origin'], {
      cwd
    })).stdout;
    const match = /(?<=HEAD branch: ).+/.exec(originDetails);
    if (match?.[0]) {
      return match[0].trim();
    }
  } catch {}
  // GitHub and GitLab default to branch name "main"
  // https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-branches#about-the-default-branch
  return 'main';
}
async function getRepoInfo(cwd = process.cwd()) {
  let info = null;
  const quotedCmd = 'git remote get-url origin`';
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    const remoteUrl = (await spawn.spawn('git', ['remote', 'get-url', 'origin'], {
      cwd
    })).stdout;
    info = parseGitRemoteUrl(remoteUrl);
    if (!info) {
      require$$6.debugFn('error', 'git: unmatched git remote URL format');
      require$$6.debugDir('inspect', {
        remoteUrl
      });
    }
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return info;
}
async function getRepoName(cwd = process.cwd()) {
  const repoInfo = await getRepoInfo(cwd);
  return repoInfo?.repo ?? null;
}
async function gitBranch(cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  // Try symbolic-ref first which returns the branch name or fails in a
  // detached HEAD state.
  try {
    return (await spawn.spawn('git', ['symbolic-ref', '--short', 'HEAD'], stdioPipeOptions)).stdout;
  } catch {}
  // Fallback to using rev-parse to get the short commit hash in a
  // detached HEAD state.
  try {
    return (await spawn.spawn('git', ['rev-parse', '--short', 'HEAD'], stdioPipeOptions)).stdout;
  } catch {}
  return null;
}
async function gitCleanFdx(cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = '`git clean -fdx`';
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    await spawn.spawn('git', ['clean', '-fdx'], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return false;
}
async function gitCheckoutBranch(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git checkout ${branch}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    await spawn.spawn('git', ['checkout', branch], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return false;
}
async function gitCreateBranch(branch, cwd = process.cwd()) {
  if (await gitLocalBranchExists(branch)) {
    return true;
  }
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git branch ${branch}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    await spawn.spawn('git', ['branch', branch], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return false;
}
async function gitPushBranch(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git push --force --set-upstream origin ${branch}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    await spawn.spawn('git', ['push', '--force', '--set-upstream', 'origin', branch], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    if (spawn.isSpawnError(e) && e.code === 128) {
      require$$6.debugFn('error', "denied: token requires write permissions for 'contents' and 'pull-requests'");
    }
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return false;
}
async function gitCommit(commitMsg, filepaths, options) {
  if (!filepaths.length) {
    require$$6.debugFn('notice', `miss: no filepaths to add`);
    return false;
  }
  const {
    cwd = process.cwd(),
    // Lazily access constants.ENV.SOCKET_CLI_GIT_USER_EMAIL.
    email = constants.ENV.SOCKET_CLI_GIT_USER_EMAIL,
    // Lazily access constants.ENV.SOCKET_CLI_GIT_USER_NAME.
    user = constants.ENV.SOCKET_CLI_GIT_USER_NAME
  } = {
    __proto__: null,
    ...options
  };
  await gitEnsureIdentity(user, email, cwd);
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedAddCmd = `\`git add ${filepaths.join(' ')}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedAddCmd}`);
  try {
    await spawn.spawn('git', ['add', ...filepaths], stdioIgnoreOptions);
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedAddCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  const quotedCommitCmd = `\`git commit -m ${commitMsg}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCommitCmd}`);
  try {
    await spawn.spawn('git', ['commit', '-m', commitMsg], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCommitCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return false;
}
async function gitDeleteBranch(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git branch -D ${branch}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    // Will throw with exit code 1 if branch does not exist.
    await spawn.spawn('git', ['branch', '-D', branch], stdioIgnoreOptions);
    return true;
  } catch (e) {
    if (require$$6.isDebug('stdio')) {
      require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
      require$$6.debugDir('inspect', {
        error: e
      });
    }
  }
  return false;
}
async function gitEnsureIdentity(name, email, cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  const identEntries = [['user.email', name], ['user.name', email]];
  await Promise.all(identEntries.map(async ({
    0: prop,
    1: value
  }) => {
    let configValue;
    {
      const quotedCmd = `\`git config --get ${prop}\``;
      require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
      try {
        // Will throw with exit code 1 if the config property is not set.
        configValue = (await spawn.spawn('git', ['config', '--get', prop], stdioPipeOptions)).stdout;
      } catch (e) {
        if (require$$6.isDebug('stdio')) {
          require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
          require$$6.debugDir('inspect', {
            error: e
          });
        }
      }
    }
    if (configValue !== value) {
      const stdioIgnoreOptions = {
        cwd,
        stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
      };
      const quotedCmd = `\`git config ${prop} ${value}\``;
      require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
      try {
        await spawn.spawn('git', ['config', prop, value], stdioIgnoreOptions);
      } catch (e) {
        if (require$$6.isDebug('stdio')) {
          require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
          require$$6.debugDir('inspect', {
            error: e
          });
        }
      }
    }
  }));
}
async function gitLocalBranchExists(branch, cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git show-ref --quiet refs/heads/${branch}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    // Will throw with exit code 1 if the branch does not exist.
    await spawn.spawn('git', ['show-ref', '--quiet', `refs/heads/${branch}`], stdioIgnoreOptions);
    return true;
  } catch (e) {
    if (require$$6.isDebug('stdio')) {
      require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
      require$$6.debugDir('inspect', {
        error: e
      });
    }
  }
  return false;
}
async function gitRemoteBranchExists(branch, cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  try {
    return (await spawn.spawn('git', ['ls-remote', '--heads', 'origin', branch], stdioPipeOptions)).stdout.length > 0;
  } catch {}
  return false;
}
async function gitResetAndClean(branch = 'HEAD', cwd = process.cwd()) {
  // Discards tracked changes.
  await gitResetHard(branch, cwd);
  // Deletes all untracked files and directories.
  await gitCleanFdx(cwd);
}
async function gitResetHard(branch = 'HEAD', cwd = process.cwd()) {
  const stdioIgnoreOptions = {
    cwd,
    stdio: require$$6.isDebug('stdio') ? 'inherit' : 'ignore'
  };
  const quotedCmd = `\`git reset --hard ${branch}\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    await spawn.spawn('git', ['reset', '--hard', branch], stdioIgnoreOptions);
    return true;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return false;
}
async function gitUnstagedModifiedFiles(cwd = process.cwd()) {
  const stdioPipeOptions = {
    cwd
  };
  const quotedCmd = `\`git diff --name-only\``;
  try {
    const changedFilesDetails = (await spawn.spawn('git', ['diff', '--name-only'], stdioPipeOptions)).stdout;
    const relPaths = changedFilesDetails.split('\n');
    return {
      ok: true,
      data: relPaths.map(p => path$1.normalizePath(p))
    };
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'Git Error',
      cause: 'Unexpected error while trying to ask git whether repo is dirty'
    };
  }
}
const parsedGitRemoteUrlCache = new Map();
function parseGitRemoteUrl(remoteUrl) {
  let result = parsedGitRemoteUrlCache.get(remoteUrl) ?? null;
  if (result) {
    return {
      ...result
    };
  }
  // Handle SSH-style
  const sshMatch = /^git@[^:]+:([^/]+)\/(.+?)(?:\.git)?$/.exec(remoteUrl);
  // 1. Handle SSH-style, e.g. git@github.com:owner/repo.git
  if (sshMatch) {
    result = {
      owner: sshMatch[1],
      repo: sshMatch[2]
    };
  } else {
    // 2. Handle HTTPS/URL-style, e.g. https://github.com/owner/repo.git
    try {
      const parsed = new URL(remoteUrl);
      // Remove leading slashes from pathname and split by "/" to extract segments.
      const segments = parsed.pathname.replace(/^\/+/, '').split('/');
      // The second-to-last segment is expected to be the owner (e.g., "owner" in /owner/repo.git).
      const owner = segments.at(-2);
      // The last segment is expected to be the repo name, so we remove the ".git" suffix if present.
      const repo = segments.at(-1)?.replace(/\.git$/, '');
      if (owner && repo) {
        result = {
          owner,
          repo
        };
      }
    } catch {}
  }
  parsedGitRemoteUrlCache.set(remoteUrl, result);
  return result ? {
    ...result
  } : result;
}

function getPurlObject(purl) {
  return typeof purl === 'string' ? vendor.packageurlJsExports.PackageURL.fromString(purl) : purl;
}

const {
  SOCKET_WEBSITE_URL
} = constants;
function getPkgFullNameFromPurl(purl) {
  const purlObj = getPurlObject(purl);
  const {
    name,
    namespace
  } = purlObj;
  return namespace ? `${namespace}${purlObj.type === 'maven' ? ':' : '/'}${name}` : name;
}
function getSocketDevPackageOverviewUrlFromPurl(purl) {
  const purlObj = getPurlObject(purl);
  const fullName = getPkgFullNameFromPurl(purlObj);
  return getSocketDevPackageOverviewUrl(purlObj.type, fullName, purlObj.version);
}
function getSocketDevPackageOverviewUrl(ecosystem, fullName, version) {
  const url = `${SOCKET_WEBSITE_URL}/${ecosystem}/package/${fullName}`;
  return ecosystem === 'golang' ? `${url}${version ? `?section=overview&version=${version}` : ''}` : `${url}${version ? `/overview/${version}` : ''}`;
}

/**
 * Convert a Map<string, Map|string> to a nested object of similar shape.
 * The goal is to serialize it with JSON.stringify, which Map can't do.
 */
function mapToObject(map) {
  return Object.fromEntries(Array.from(map.entries()).map(([k, v]) => [k, v instanceof Map ? mapToObject(v) : v]));
}

function* walkNestedMap(map, keys = []) {
  for (const [key, value] of map.entries()) {
    if (value instanceof Map) {
      yield* walkNestedMap(value, keys.concat(key));
    } else {
      yield {
        keys: keys.concat(key),
        value: value
      };
    }
  }
}

function extractTier1ReachabilityScanId(socketFactsFile) {
  const json = fs.readJsonSync(socketFactsFile, {
    throws: false
  });
  const tier1ReachabilityScanId = String(json?.['tier1ReachabilityScanId'] ?? '').trim();
  return tier1ReachabilityScanId.length > 0 ? tier1ReachabilityScanId : undefined;
}
async function spawnCoana(args, orgSlug, options, extra) {
  const {
    env: spawnEnv
  } = {
    __proto__: null,
    ...options
  };
  const mixinsEnv = {
    // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.
    SOCKET_CLI_VERSION: constants.ENV.INLINED_SOCKET_CLI_VERSION
  };
  const defaultApiToken = getDefaultToken();
  if (defaultApiToken) {
    mixinsEnv['SOCKET_CLI_API_TOKEN'] = defaultApiToken;
  }
  if (orgSlug) {
    mixinsEnv['SOCKET_ORG_SLUG'] = orgSlug;
  } else {
    const orgSlugCResult = await getDefaultOrgSlug();
    if (orgSlugCResult.ok) {
      mixinsEnv['SOCKET_ORG_SLUG'] = orgSlugCResult.data;
    }
  }
  try {
    const output = await spawn.spawn(constants.execPath, [
    // Lazily access constants.nodeNoWarningsFlags.
    ...constants.nodeNoWarningsFlags,
    // Lazily access constants.nodeMemoryFlags.
    ...constants.nodeMemoryFlags,
    // Lazily access constants.coanaBinPath.
    constants.coanaBinPath, ...args], {
      ...options,
      env: {
        ...process.env,
        // Lazily access constants.processEnv.
        ...constants.processEnv,
        ...mixinsEnv,
        ...spawnEnv
      }
    }, extra);
    return {
      ok: true,
      data: output.stdout
    };
  } catch (e) {
    const stderr = e?.stderr;
    const message = stderr ? stderr : e?.message;
    return {
      ok: false,
      data: e,
      message
    };
  }
}

const DEFAULT_IGNORE_FOR_GIT_IGNORE = globs.defaultIgnore.filter(p => !p.endsWith('.gitignore'));
const IGNORED_DIRS = [
// Taken from ignore-by-default:
// https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js
'.git',
// Git repository files, see <https://git-scm.com/>
'.log',
// Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
'.nyc_output',
// Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
'.sass-cache',
// Cache folder for node-sass, see <https://github.com/sass/node-sass>
'.yarn',
// Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
'bower_components',
// Where Bower packages are installed, see <http://bower.io/>
'coverage',
// Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
'node_modules',
// Where Node modules are installed, see <https://nodejs.org/>
// Taken from globby:
// https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16
'flow-typed'];
const IGNORED_DIR_PATTERNS = IGNORED_DIRS.map(i => `**/${i}`);
async function getWorkspaceGlobs(agent, cwd = process.cwd()) {
  let workspacePatterns;
  if (agent === 'pnpm') {
    for (const workspacePath of [path.join(cwd, 'pnpm-workspace.yaml'), path.join(cwd, 'pnpm-workspace.yml')]) {
      // eslint-disable-next-line no-await-in-loop
      const yml = await fs.safeReadFile(workspacePath);
      if (yml) {
        try {
          workspacePatterns = vendor.distExports$1.parse(yml)?.packages;
        } catch {}
        if (workspacePatterns) {
          break;
        }
      }
    }
  } else {
    workspacePatterns = (await packages.readPackageJson(cwd, {
      throws: false
    }))?.['workspaces'];
  }
  return Array.isArray(workspacePatterns) ? workspacePatterns.filter(strings.isNonEmptyString).map(workspacePatternToGlobPattern) : [];
}
function ignoreFileLinesToGlobPatterns(lines, filepath, cwd) {
  const base = path.relative(cwd, path.dirname(filepath)).replace(/\\/g, '/');
  const patterns = [];
  for (let i = 0, {
      length
    } = lines; i < length; i += 1) {
    const pattern = lines[i].trim();
    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {
      patterns.push(ignorePatternToMinimatch(pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/ ? `!${path.posix.join(base, pattern.slice(1))}` : path.posix.join(base, pattern)));
    }
  }
  return patterns;
}
function ignoreFileToGlobPatterns(content, filepath, cwd) {
  return ignoreFileLinesToGlobPatterns(content.split(/\r?\n/), filepath, cwd);
}

// Based on `@eslint/compat` convertIgnorePatternToMinimatch.
// Apache v2.0 licensed
// Copyright Nicholas C. Zakas
// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28
function ignorePatternToMinimatch(pattern) {
  const isNegated = pattern.startsWith('!');
  const negatedPrefix = isNegated ? '!' : '';
  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd();
  // Special cases.
  if (patternToTest === '' || patternToTest === '**' || patternToTest === '/**' || patternToTest === '**') {
    return `${negatedPrefix}${patternToTest}`;
  }
  const firstIndexOfSlash = patternToTest.indexOf('/');
  const matchEverywherePrefix = firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1 ? '**/' : '';
  const patternWithoutLeadingSlash = firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest;
  // Escape `{` and `(` because in gitignore patterns they are just
  // literal characters without any specific syntactic meaning,
  // while in minimatch patterns they can form brace expansion or extglob syntax.
  //
  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.
  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.
  // Minimatch pattern `src/\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.
  const escapedPatternWithoutLeadingSlash = patternWithoutLeadingSlash.replaceAll(/(?=((?:\\.|[^{(])*))\1([{(])/guy, '$1\\$2');
  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : '';
  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`;
}
function workspacePatternToGlobPattern(workspace) {
  const {
    length
  } = workspace;
  if (!length) {
    return '';
  }
  // If the workspace ends with "/"
  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {
    return `${workspace}/*/package.json`;
  }
  // If the workspace ends with "/**"
  if (workspace.charCodeAt(length - 1) === 42 /*'*'*/ && workspace.charCodeAt(length - 2) === 42 /*'*'*/ && workspace.charCodeAt(length - 3) === 47 /*'/'*/) {
    return `${workspace}/*/**/package.json`;
  }
  // Things like "packages/a" or "packages/*"
  return `${workspace}/package.json`;
}
function filterBySupportedScanFiles(filepaths, supportedFiles) {
  const patterns = getSupportedFilePatterns(supportedFiles);
  return filepaths.filter(p => vendor.micromatchExports.some(p, patterns));
}
function getSupportedFilePatterns(supportedFiles) {
  const patterns = [];
  for (const key of Object.keys(supportedFiles)) {
    const supported = supportedFiles[key];
    if (supported) {
      patterns.push(...Object.values(supported).map(p => `**/${p.pattern}`));
    }
  }
  return patterns;
}
async function globWithGitIgnore(patterns, options) {
  const {
    cwd = process.cwd(),
    socketConfig,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const ignores = new Set(IGNORED_DIR_PATTERNS);
  const projectIgnorePaths = socketConfig?.projectIgnorePaths;
  if (Array.isArray(projectIgnorePaths)) {
    const ignorePatterns = ignoreFileLinesToGlobPatterns(projectIgnorePaths, path.join(cwd, '.gitignore'), cwd);
    for (const pattern of ignorePatterns) {
      ignores.add(pattern);
    }
  }
  const gitIgnoreStream = vendor.outExports.globStream(['**/.gitignore'], {
    absolute: true,
    cwd,
    ignore: DEFAULT_IGNORE_FOR_GIT_IGNORE
  });
  for await (const ignorePatterns of streams.transform(gitIgnoreStream, async filepath => ignoreFileToGlobPatterns((await fs.safeReadFile(filepath)) ?? '', filepath, cwd), {
    concurrency: 8
  })) {
    for (const p of ignorePatterns) {
      ignores.add(p);
    }
  }
  let hasNegatedPattern = false;
  for (const p of ignores) {
    if (p.charCodeAt(0) === 33 /*'!'*/) {
      hasNegatedPattern = true;
      break;
    }
  }
  const globOptions = {
    __proto__: null,
    absolute: true,
    cwd,
    dot: true,
    ignore: hasNegatedPattern ? globs.defaultIgnore : [...ignores],
    ...additionalOptions
  };
  if (!hasNegatedPattern) {
    return await vendor.outExports.glob(patterns, globOptions);
  }

  // Add support for negated "ignore" patterns which many globbing libraries,
  // including 'fast-glob', 'globby', and 'tinyglobby', lack support for.
  const filtered = [];
  const ig = vendor.ignoreExports().add([...ignores]);
  const stream = vendor.outExports.globStream(patterns, globOptions);
  for await (const p of stream) {
    // Note: the input files must be INSIDE the cwd. If you get strange looking
    // relative path errors here, most likely your path is outside the given cwd.
    const relPath = globOptions.absolute ? path.relative(cwd, p) : p;
    if (!ig.ignores(relPath)) {
      filtered.push(p);
    }
  }
  return filtered;
}
async function globStreamNodeModules(cwd = process.cwd()) {
  return vendor.outExports.globStream('**/node_modules', {
    absolute: true,
    cwd,
    onlyDirectories: true
  });
}
async function globWorkspace(agent, cwd = process.cwd()) {
  const workspaceGlobs = await getWorkspaceGlobs(agent, cwd);
  return workspaceGlobs.length ? await vendor.outExports.glob(workspaceGlobs, {
    absolute: true,
    cwd,
    ignore: globs.defaultIgnore
  }) : [];
}
function isReportSupportedFile(filepath, supportedFiles) {
  const patterns = getSupportedFilePatterns(supportedFiles);
  return vendor.micromatchExports.some(filepath, patterns);
}
function pathsToGlobPatterns(paths) {
  // TODO: Does not support `~/` paths.
  return paths.map(p => p === '.' || p === './' ? '**/*' : p);
}

function findBinPathDetailsSync(binName) {
  const binPaths = vendor.libExports$1.sync(binName, {
    all: true,
    nothrow: true
  }) ?? [];
  // Lazily access constants.shadowBinPath.
  const {
    shadowBinPath
  } = constants;
  let shadowIndex = -1;
  let theBinPath;
  for (let i = 0, {
      length
    } = binPaths; i < length; i += 1) {
    const binPath = binPaths[i];
    // Skip our bin directory if it's in the front.
    if (path.dirname(binPath) === shadowBinPath) {
      shadowIndex = i;
    } else {
      theBinPath = npm.resolveBinPathSync(binPath);
      break;
    }
  }
  return {
    name: binName,
    path: theBinPath,
    shadowed: shadowIndex !== -1
  };
}
function findNpmDirPathSync(npmBinPath) {
  // Lazily access constants.WIN32.
  const {
    WIN32
  } = constants;
  let thePath = npmBinPath;
  while (true) {
    const libNmNpmPath = path.join(thePath, 'lib/node_modules/npm');
    // mise, which uses opaque binaries, puts its npm bin in a path like:
    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/bin/npm.
    // HOWEVER, the location of the npm install is:
    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/lib/node_modules/npm.
    if (
    // Use existsSync here because statsSync, even with { throwIfNoEntry: false },
    // will throw an ENOTDIR error for paths like ./a-file-that-exists/a-directory-that-does-not.
    // See https://github.com/nodejs/node/issues/56993.
    fs.isDirSync(libNmNpmPath)) {
      thePath = libNmNpmPath;
    }
    const hasNmInCurrPath = fs.isDirSync(path.join(thePath, 'node_modules'));
    const hasNmInParentPath = !hasNmInCurrPath && fs.isDirSync(path.join(thePath, '../node_modules'));
    if (
    // npm bin paths may look like:
    //   /usr/local/share/npm/bin/npm
    //   /Users/SomeUsername/.nvm/versions/node/vX.X.X/bin/npm
    //   C:\Users\SomeUsername\AppData\Roaming\npm\bin\npm.cmd
    // OR
    //   C:\Program Files\nodejs\npm.cmd
    //
    // In practically all cases the npm path contains a node_modules folder:
    //   /usr/local/share/npm/bin/npm/node_modules
    //   C:\Program Files\nodejs\node_modules
    (hasNmInCurrPath ||
    // In some bespoke cases the node_modules folder is in the parent directory.
    hasNmInParentPath) && (
    // Optimistically look for the default location.
    path.basename(thePath) === 'npm' ||
    // Chocolatey installs npm bins in the same directory as node bins.
    WIN32 && fs$1.existsSync(path.join(thePath, 'npm.cmd')))) {
      return hasNmInParentPath ? path.dirname(thePath) : thePath;
    }
    const parent = path.dirname(thePath);
    if (parent === thePath) {
      return undefined;
    }
    thePath = parent;
  }
}
async function getPackageFilesForScan(inputPaths, supportedFiles, options) {
  const {
    config: socketConfig,
    cwd = process.cwd()
  } = {
    __proto__: null,
    ...options
  };
  const filepaths = await globWithGitIgnore(pathsToGlobPatterns(inputPaths), {
    cwd,
    socketConfig
  });
  return filterBySupportedScanFiles(filepaths, supportedFiles);
}

function readOrDefaultSocketJson(cwd) {
  const jsonCResult = readSocketJsonSync(cwd, true);
  return jsonCResult.ok ? jsonCResult.data :
  // This should be unreachable but it makes TS happy.
  getDefaultSocketJson();
}
function getDefaultSocketJson() {
  return {
    ' _____         _       _     ': 'Local config file for Socket CLI tool ( https://npmjs.org/socket ), to work with https://socket.dev',
    '|   __|___ ___| |_ ___| |_   ': '     The config in this file is used to set as defaults for flags or command args when using the CLI',
    "|__   | . |  _| '_| -_|  _|  ": '     in this dir, often a repo root. You can choose commit or .ignore this file, both works.',
    '|_____|___|___|_,_|___|_|.dev': 'Warning: This file may be overwritten without warning by `socket manifest setup` or other commands',
    version: 1
  };
}
function readSocketJsonSync(cwd, defaultOnError = false) {
  const sockJsonPath = path.join(cwd, 'socket.json');
  if (!fs$1.existsSync(sockJsonPath)) {
    require$$6.debugFn('notice', `miss: socket.json not found at ${cwd}`);
    return {
      ok: true,
      data: getDefaultSocketJson()
    };
  }
  let json = null;
  try {
    json = fs$1.readFileSync(sockJsonPath, 'utf8');
  } catch (e) {
    if (defaultOnError) {
      logger.logger.warn('Failed to read socket.json, using default');
      require$$6.debugDir('inspect', {
        error: e
      });
      return {
        ok: true,
        data: getDefaultSocketJson()
      };
    }
    const msg = e?.message;
    require$$6.debugDir('inspect', {
      error: e
    });
    return {
      ok: false,
      message: 'Failed to read socket.json',
      cause: `An error occurred while trying to read socket.json${msg ? `: ${msg}` : ''}`
    };
  }
  let obj;
  try {
    obj = JSON.parse(json);
  } catch (e) {
    require$$6.debugFn('error', 'caught: JSON.parse error');
    require$$6.debugDir('inspect', {
      error: e,
      json
    });
    if (defaultOnError) {
      logger.logger.warn('Failed to parse socket.json, using default');
      return {
        ok: true,
        data: getDefaultSocketJson()
      };
    }
    return {
      ok: false,
      message: 'Failed to parse socket.json',
      cause: 'socket.json does not contain valid JSON, please verify'
    };
  }
  if (!obj) {
    logger.logger.warn('Warning: file contents was empty, using default');
    return {
      ok: true,
      data: getDefaultSocketJson()
    };
  }

  // Do we really care to validate? All properties are optional so code will have
  // to check every step of the way regardless. Who cares about validation here...?
  return {
    ok: true,
    data: obj
  };
}
async function writeSocketJson(cwd, sockJson) {
  let json = '';
  try {
    json = JSON.stringify(sockJson, null, 2);
  } catch (e) {
    require$$6.debugFn('error', 'caught: JSON.stringify error');
    require$$6.debugDir('inspect', {
      error: e,
      sockJson
    });
    return {
      ok: false,
      message: 'Failed to serialize to JSON',
      cause: 'There was an unexpected problem converting the socket json object to a JSON string. Unable to store it.'
    };
  }
  const filepath = path.join(cwd, 'socket.json');
  await fs$1.promises.writeFile(filepath, json + '\n', 'utf8');
  return {
    ok: true,
    data: undefined
  };
}

const {
  NODE_MODULES,
  NPM: NPM$3,
  NPX,
  SOCKET_CLI_ISSUES_URL
} = constants;
function exitWithBinPathError(binName) {
  logger.logger.fail(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable`);
  // The exit code 127 indicates that the command or binary being executed
  // could not be found.
  // eslint-disable-next-line n/no-process-exit
  process.exit(127);
}
let _npmBinPath;
function getNpmBinPath() {
  if (_npmBinPath === undefined) {
    _npmBinPath = getNpmBinPathDetails().path;
    if (!_npmBinPath) {
      exitWithBinPathError(NPM$3);
    }
  }
  return _npmBinPath;
}
let _npmBinPathDetails;
function getNpmBinPathDetails() {
  if (_npmBinPathDetails === undefined) {
    _npmBinPathDetails = findBinPathDetailsSync(NPM$3);
  }
  return _npmBinPathDetails;
}
let _npmDirPath;
function getNpmDirPath() {
  if (_npmDirPath === undefined) {
    const npmBinPath = getNpmBinPath();
    _npmDirPath = npmBinPath ? findNpmDirPathSync(npmBinPath) : undefined;
    if (!_npmDirPath) {
      // Lazily access constants.ENV.SOCKET_CLI_NPM_PATH.
      _npmDirPath = constants.ENV.SOCKET_CLI_NPM_PATH || undefined;
    }
    if (!_npmDirPath) {
      let message = 'Unable to find npm CLI install directory.';
      if (npmBinPath) {
        message += `\nSearched parent directories of ${path.dirname(npmBinPath)}.`;
      }
      message += `\n\nThis is may be a bug with socket-npm related to changes to the npm CLI.\nPlease report to ${SOCKET_CLI_ISSUES_URL}.`;
      logger.logger.fail(message);
      // The exit code 127 indicates that the command or binary being executed
      // could not be found.
      // eslint-disable-next-line n/no-process-exit
      process.exit(127);
    }
  }
  return _npmDirPath;
}
let _npmRequire;
function getNpmRequire() {
  if (_npmRequire === undefined) {
    const npmDirPath = getNpmDirPath();
    const npmNmPath = path.join(npmDirPath, NODE_MODULES, NPM$3);
    _npmRequire = require$$5.createRequire(path.join(fs$1.existsSync(npmNmPath) ? npmNmPath : npmDirPath, '<dummy-basename>'));
  }
  return _npmRequire;
}
let _npxBinPath;
function getNpxBinPath() {
  if (_npxBinPath === undefined) {
    _npxBinPath = getNpxBinPathDetails().path;
    if (!_npxBinPath) {
      exitWithBinPathError(NPX);
    }
  }
  return _npxBinPath;
}
let _npxBinPathDetails;
function getNpxBinPathDetails() {
  if (_npxBinPathDetails === undefined) {
    _npxBinPathDetails = findBinPathDetailsSync(NPX);
  }
  return _npxBinPathDetails;
}
function isNpmBinPathShadowed() {
  return getNpmBinPathDetails().shadowed;
}
function isNpxBinPathShadowed() {
  return getNpxBinPathDetails().shadowed;
}

const {
  ALERT_TYPE_CRITICAL_CVE,
  ALERT_TYPE_CVE,
  ALERT_TYPE_MEDIUM_CVE,
  ALERT_TYPE_MILD_CVE
} = constants;
function isArtifactAlertCve(alert) {
  const {
    type
  } = alert;
  return type === ALERT_TYPE_CVE || type === ALERT_TYPE_MEDIUM_CVE || type === ALERT_TYPE_MILD_CVE || type === ALERT_TYPE_CRITICAL_CVE;
}

function createEnum(obj) {
  return Object.freeze({
    __proto__: null,
    ...obj
  });
}

const ALERT_FIX_TYPE = createEnum({
  cve: 'cve',
  remove: 'remove',
  upgrade: 'upgrade'
});

const ALERT_SEVERITY = createEnum({
  critical: 'critical',
  high: 'high',
  middle: 'middle',
  low: 'low'
});

class ColorOrMarkdown {
  constructor(useMarkdown) {
    this.useMarkdown = !!useMarkdown;
  }
  bold(text) {
    return this.useMarkdown ? `**${text}**` : vendor.yoctocolorsCjsExports.bold(`${text}`);
  }
  header(text, level = 1) {
    return this.useMarkdown ? `\n${''.padStart(level, '#')} ${text}\n` : vendor.yoctocolorsCjsExports.underline(`\n${level === 1 ? vendor.yoctocolorsCjsExports.bold(text) : text}\n`);
  }
  hyperlink(text, url, {
    fallback = true,
    fallbackToUrl
  } = {}) {
    if (url) {
      return this.useMarkdown ? `[${text}](${url})` : vendor.terminalLinkExports(text, url, {
        fallback: fallbackToUrl ? (_text, url) => url : fallback
      });
    }
    return text;
  }
  indent(...args) {
    return vendor.indentStringExports(...args);
  }
  italic(text) {
    return this.useMarkdown ? `_${text}_` : vendor.yoctocolorsCjsExports.italic(`${text}`);
  }
  json(value) {
    return this.useMarkdown ? '```json\n' + JSON.stringify(value) + '\n```' : JSON.stringify(value);
  }
  list(items) {
    const indentedContent = items.map(item => this.indent(item).trimStart());
    return this.useMarkdown ? `* ${indentedContent.join('\n* ')}\n` : `${indentedContent.join('\n')}\n`;
  }
}

const RangeStyles = ['caret', 'gt', 'gte', 'lt', 'lte', 'pin', 'preserve', 'tilde'];
function applyRange(refRange, version, style = 'preserve') {
  switch (style) {
    case 'caret':
      return `^${version}`;
    case 'gt':
      return `>${version}`;
    case 'gte':
      return `>=${version}`;
    case 'lt':
      return `<${version}`;
    case 'lte':
      return `<=${version}`;
    case 'preserve':
      {
        const range = new vendor.semverExports.Range(refRange);
        const {
          raw
        } = range;
        const comparators = range.set.flat();
        const {
          length
        } = comparators;
        if (length === 1) {
          const char = /^[<>]=?/.exec(raw)?.[0];
          if (char) {
            return `${char}${version}`;
          }
        } else if (length === 2) {
          const char = /^[~^]/.exec(raw)?.[0];
          if (char) {
            return `${char}${version}`;
          }
        }
        return version;
      }
    case 'tilde':
      return `~${version}`;
    case 'pin':
    default:
      return version;
  }
}
function getMajor(version) {
  try {
    const coerced = vendor.semverExports.coerce(version);
    return coerced ? vendor.semverExports.major(coerced) : null;
  } catch {}
  return null;
}
function getMinVersion(range) {
  try {
    return vendor.semverExports.minVersion(range);
  } catch {}
  return null;
}

const require$1 = require$$5.createRequire(require('node:url').pathToFileURL(__filename).href);
let _translations;
function getTranslations() {
  if (_translations === undefined) {
    _translations = /*@__PURE__*/require$1(
    // Lazily access constants.rootPath.
    path.join(constants.rootPath, 'translations.json'));
  }
  return _translations;
}

const ALERT_SEVERITY_COLOR = createEnum({
  critical: 'magenta',
  high: 'red',
  middle: 'yellow',
  low: 'white'
});
const ALERT_SEVERITY_ORDER = createEnum({
  critical: 0,
  high: 1,
  middle: 2,
  low: 3,
  none: 4
});
const MIN_ABOVE_THE_FOLD_COUNT = 3;
const MIN_ABOVE_THE_FOLD_ALERT_COUNT = 1;
const format = new ColorOrMarkdown(false);
function getHiddenRiskCounts(hiddenAlerts) {
  const riskCounts = {
    critical: 0,
    high: 0,
    middle: 0,
    low: 0
  };
  for (const alert of hiddenAlerts) {
    switch (getAlertSeverityOrder(alert)) {
      case ALERT_SEVERITY_ORDER.critical:
        riskCounts.critical += 1;
        break;
      case ALERT_SEVERITY_ORDER.high:
        riskCounts.high += 1;
        break;
      case ALERT_SEVERITY_ORDER.middle:
        riskCounts.middle += 1;
        break;
      case ALERT_SEVERITY_ORDER.low:
        riskCounts.low += 1;
        break;
    }
  }
  return riskCounts;
}
function getHiddenRisksDescription(riskCounts) {
  const descriptions = [];
  if (riskCounts.critical) {
    descriptions.push(`${riskCounts.critical} ${getSeverityLabel('critical')}`);
  }
  if (riskCounts.high) {
    descriptions.push(`${riskCounts.high} ${getSeverityLabel('high')}`);
  }
  if (riskCounts.middle) {
    descriptions.push(`${riskCounts.middle} ${getSeverityLabel('middle')}`);
  }
  if (riskCounts.low) {
    descriptions.push(`${riskCounts.low} ${getSeverityLabel('low')}`);
  }
  return `(${descriptions.join('; ')})`;
}
async function addArtifactToAlertsMap(artifact, alertsByPurl, options) {
  // Make TypeScript happy.
  if (!artifact.name || !artifact.version || !artifact.alerts?.length) {
    return alertsByPurl;
  }
  const {
    consolidate = false,
    include: _include,
    overrides
  } = {
    __proto__: null,
    ...options
  };
  const socketYml = findSocketYmlSync();
  const localRules = socketYml?.parsed.issueRules;
  const include = {
    __proto__: null,
    blocked: true,
    critical: true,
    cve: true,
    unfixable: true,
    upgradable: false,
    ..._include
  };
  const name = packages.resolvePackageName(artifact);
  const {
    type: ecosystem,
    version
  } = artifact;
  const enabledState = {
    __proto__: null,
    ...localRules
  };
  let sockPkgAlerts = [];
  for (const alert of artifact.alerts) {
    const action = alert.action ?? '';
    const enabledFlag = enabledState[alert.type];
    if (action === 'ignore' && enabledFlag !== true || enabledFlag === false) {
      continue;
    }
    const blocked = action === 'error';
    const critical = alert.severity === ALERT_SEVERITY.critical;
    const cve = isArtifactAlertCve(alert);
    const fixType = alert.fix?.type ?? '';
    const fixableCve = fixType === ALERT_FIX_TYPE.cve;
    const fixableUpgrade = fixType === ALERT_FIX_TYPE.upgrade;
    const fixable = fixableCve || fixableUpgrade;
    const upgradable = fixableUpgrade && !require$$7.hasOwn(overrides, name);
    if (include.blocked && blocked || include.critical && critical || include.cve && cve || include.unfixable && !fixable || include.upgradable && upgradable) {
      sockPkgAlerts.push({
        name,
        version,
        key: alert.key,
        type: alert.type,
        blocked,
        critical,
        ecosystem,
        fixable,
        raw: alert,
        upgradable
      });
    }
  }
  if (!sockPkgAlerts.length) {
    return alertsByPurl;
  }
  const purl = `pkg:${ecosystem}/${name}@${version}`;
  const major = getMajor(version);
  if (consolidate) {
    const highestForCve = new Map();
    const highestForUpgrade = new Map();
    const unfixableAlerts = [];
    for (const sockPkgAlert of sockPkgAlerts) {
      const alert = sockPkgAlert.raw;
      const fixType = alert.fix?.type ?? '';
      if (fixType === ALERT_FIX_TYPE.cve) {
        // An alert with alert.fix.type of 'cve' should have a
        // alert.props.firstPatchedVersionIdentifier property value.
        // We're just being cautious.
        const firstPatchedVersionIdentifier = alert.props?.firstPatchedVersionIdentifier;
        const patchedMajor = firstPatchedVersionIdentifier ? getMajor(firstPatchedVersionIdentifier) : null;
        if (typeof patchedMajor === 'number') {
          // Consolidate to the highest "first patched version" by each major
          // version number.
          const highest = highestForCve.get(patchedMajor)?.version ?? '0.0.0';
          if (vendor.semverExports.gt(firstPatchedVersionIdentifier, highest)) {
            highestForCve.set(patchedMajor, {
              alert: sockPkgAlert,
              version: firstPatchedVersionIdentifier
            });
          }
        } else {
          unfixableAlerts.push(sockPkgAlert);
        }
      } else if (fixType === ALERT_FIX_TYPE.upgrade) {
        // For Socket Optimize upgrades we assume the highest version available
        // is compatible. This may change in the future.
        const highest = highestForUpgrade.get(major)?.version ?? '0.0.0';
        if (vendor.semverExports.gt(version, highest)) {
          highestForUpgrade.set(major, {
            alert: sockPkgAlert,
            version
          });
        }
      } else {
        unfixableAlerts.push(sockPkgAlert);
      }
    }
    sockPkgAlerts = [
    // Sort CVE alerts by severity: critical, high, middle, then low.
    ...Array.from(highestForCve.values()).map(d => d.alert).sort(alertSeverityComparator), ...Array.from(highestForUpgrade.values()).map(d => d.alert), ...unfixableAlerts];
  } else {
    sockPkgAlerts.sort((a, b) => sorts.naturalCompare(a.type, b.type));
  }
  if (sockPkgAlerts.length) {
    alertsByPurl.set(purl, sockPkgAlerts);
  }
  return alertsByPurl;
}
function alertsHaveBlocked(alerts) {
  return alerts.find(a => a.blocked) !== undefined;
}
function alertsHaveSeverity(alerts, severity) {
  return alerts.find(a => a.raw.severity === severity) !== undefined;
}
function alertSeverityComparator(a, b) {
  // Put the most severe first.
  return getAlertSeverityOrder(a) - getAlertSeverityOrder(b);
}
function getAlertSeverityOrder(alert) {
  // The more severe, the lower the sort number.
  const {
    severity
  } = alert.raw;
  return severity === ALERT_SEVERITY.critical ? 0 : severity === ALERT_SEVERITY.high ? 1 : severity === ALERT_SEVERITY.middle ? 2 : severity === ALERT_SEVERITY.low ? 3 : 4;
}
function getAlertsSeverityOrder(alerts) {
  return alertsHaveBlocked(alerts) || alertsHaveSeverity(alerts, ALERT_SEVERITY.critical) ? 0 : alertsHaveSeverity(alerts, ALERT_SEVERITY.high) ? 1 : alertsHaveSeverity(alerts, ALERT_SEVERITY.middle) ? 2 : alertsHaveSeverity(alerts, ALERT_SEVERITY.low) ? 3 : 4;
}
function getCveInfoFromAlertsMap(alertsMap, options) {
  const {
    exclude: exclude_
  } = {
    __proto__: null,
    ...options
  };
  const exclude = {
    __proto__: null,
    ...exclude_
  };
  let infoByPartialPurl = null;
  // eslint-disable-next-line no-unused-labels
  for (const {
    0: purl,
    1: sockPkgAlerts
  } of alertsMap) {
    const purlObj = getPurlObject(purl);
    const partialPurl = new vendor.packageurlJsExports.PackageURL(purlObj.type, purlObj.namespace, purlObj.name).toString();
    const name = packages.resolvePackageName(purlObj);
    sockPkgAlertsLoop: for (const sockPkgAlert of sockPkgAlerts) {
      const alert = sockPkgAlert.raw;
      if (alert.fix?.type !== ALERT_FIX_TYPE.cve || exclude.upgradable && registry.getManifestData(sockPkgAlert.ecosystem, name)) {
        continue sockPkgAlertsLoop;
      }
      if (!infoByPartialPurl) {
        infoByPartialPurl = new Map();
      }
      let infos = infoByPartialPurl.get(partialPurl);
      if (!infos) {
        infos = new Map();
        infoByPartialPurl.set(partialPurl, infos);
      }
      const {
        key
      } = alert;
      if (!infos.has(key)) {
        // An alert with alert.fix.type of 'cve' should have a
        // alert.props.firstPatchedVersionIdentifier property value.
        // We're just being cautious.
        const firstPatchedVersionIdentifier = alert.props?.firstPatchedVersionIdentifier;
        const vulnerableVersionRange = alert.props?.vulnerableVersionRange;
        let error;
        if (firstPatchedVersionIdentifier && vulnerableVersionRange) {
          try {
            infos.set(key, {
              firstPatchedVersionIdentifier,
              vulnerableVersionRange: new vendor.semverExports.Range(
              // Replace ', ' in a range like '>= 1.0.0, < 1.8.2' with ' ' so that
              // semver.Range will parse it without erroring.
              vulnerableVersionRange.replace(/, +/g, ' ').replace(/; +/g, ' || ')).format()
            });
            continue sockPkgAlertsLoop;
          } catch (e) {
            error = e;
          }
        }
        require$$6.debugFn('error', 'fail: invalid SocketPackageAlert');
        require$$6.debugDir('inspect', {
          alert,
          error
        });
      }
    }
  }
  return infoByPartialPurl;
}
function getSeverityLabel(severity) {
  return severity === 'middle' ? 'moderate' : severity;
}
function logAlertsMap(alertsMap, options) {
  const {
    hideAt = 'middle',
    output = process.stderr
  } = {
    __proto__: null,
    ...options
  };
  const translations = getTranslations();
  const sortedEntries = Array.from(alertsMap.entries()).sort((a, b) => getAlertsSeverityOrder(a[1]) - getAlertsSeverityOrder(b[1]));
  const aboveTheFoldPurls = new Set();
  const viewableAlertsByPurl = new Map();
  const hiddenAlertsByPurl = new Map();
  for (let i = 0, {
      length
    } = sortedEntries; i < length; i += 1) {
    const {
      0: purl,
      1: alerts
    } = sortedEntries[i];
    const hiddenAlerts = [];
    const viewableAlerts = alerts.filter(a => {
      const keep = a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER[hideAt];
      if (!keep) {
        hiddenAlerts.push(a);
      }
      return keep;
    });
    if (hiddenAlerts.length) {
      hiddenAlertsByPurl.set(purl, hiddenAlerts.sort(alertSeverityComparator));
    }
    if (!viewableAlerts.length) {
      continue;
    }
    viewableAlerts.sort(alertSeverityComparator);
    viewableAlertsByPurl.set(purl, viewableAlerts);
    if (viewableAlerts.find(a => a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER.middle)) {
      aboveTheFoldPurls.add(purl);
    }
  }

  // If MIN_ABOVE_THE_FOLD_COUNT is NOT met add more from viewable pkg ids.
  for (const {
    0: purl
  } of viewableAlertsByPurl.entries()) {
    if (aboveTheFoldPurls.size >= MIN_ABOVE_THE_FOLD_COUNT) {
      break;
    }
    aboveTheFoldPurls.add(purl);
  }
  // If MIN_ABOVE_THE_FOLD_COUNT is STILL NOT met add more from hidden pkg ids.
  for (const {
    0: purl,
    1: hiddenAlerts
  } of hiddenAlertsByPurl.entries()) {
    if (aboveTheFoldPurls.size >= MIN_ABOVE_THE_FOLD_COUNT) {
      break;
    }
    aboveTheFoldPurls.add(purl);
    const viewableAlerts = viewableAlertsByPurl.get(purl) ?? [];
    if (viewableAlerts.length < MIN_ABOVE_THE_FOLD_ALERT_COUNT) {
      const neededCount = MIN_ABOVE_THE_FOLD_ALERT_COUNT - viewableAlerts.length;
      let removedHiddenAlerts;
      if (hiddenAlerts.length - neededCount > 0) {
        removedHiddenAlerts = hiddenAlerts.splice(0, MIN_ABOVE_THE_FOLD_ALERT_COUNT);
      } else {
        removedHiddenAlerts = hiddenAlerts;
        hiddenAlertsByPurl.delete(purl);
      }
      viewableAlertsByPurl.set(purl, [...viewableAlerts, ...removedHiddenAlerts]);
    }
  }
  const mentionedPurlsWithHiddenAlerts = new Set();
  for (let i = 0, prevAboveTheFold = true, entries = Array.from(viewableAlertsByPurl.entries()), {
      length
    } = entries; i < length; i += 1) {
    const {
      0: purl,
      1: alerts
    } = entries[i];
    const lines = new Set();
    for (const alert of alerts) {
      const {
        type
      } = alert;
      const severity = alert.raw.severity ?? '';
      const attributes = [...(severity ? [vendor.yoctocolorsCjsExports[ALERT_SEVERITY_COLOR[severity]](getSeverityLabel(severity))] : []), ...(alert.blocked ? [vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.red('blocked'))] : []), ...(alert.fixable ? ['fixable'] : [])];
      const maybeAttributes = attributes.length ? ` ${vendor.yoctocolorsCjsExports.italic(`(${attributes.join('; ')})`)}` : '';
      // Based data from { pageProps: { alertTypes } } of:
      // https://socket.dev/_next/data/9a6db8224b68b6da0eb9f7dbb17aff7e51568ac2/en-US.json
      const info = translations.alerts[type];
      const title = info?.title ?? type;
      const maybeDesc = info?.description ? ` - ${info.description}` : '';
      const content = `${title}${maybeAttributes}${maybeDesc}`;
      // TODO: An added emoji seems to mis-align terminals sometimes.
      lines.add(`  ${content}`);
    }
    const purlObj = getPurlObject(purl);
    const pkgName = packages.resolvePackageName(purlObj);
    const hyperlink = format.hyperlink(pkgName, getSocketDevPackageOverviewUrl(purlObj.type, pkgName, purlObj.version));
    const isAboveTheFold = aboveTheFoldPurls.has(purl);
    if (isAboveTheFold) {
      aboveTheFoldPurls.add(purl);
      output.write(`${i ? '\n' : ''}${hyperlink}:\n`);
    } else {
      output.write(`${prevAboveTheFold ? '\n' : ''}${hyperlink}:\n`);
    }
    for (const line of lines) {
      output.write(`${line}\n`);
    }
    const hiddenAlerts = hiddenAlertsByPurl.get(purl) ?? [];
    const {
      length: hiddenAlertsCount
    } = hiddenAlerts;
    if (hiddenAlertsCount) {
      mentionedPurlsWithHiddenAlerts.add(purl);
      if (hiddenAlertsCount === 1) {
        output.write(`  ${vendor.yoctocolorsCjsExports.dim(`+1 Hidden ${getSeverityLabel(hiddenAlerts[0].raw.severity ?? 'low')} risk alert`)}\n`);
      } else {
        output.write(`  ${vendor.yoctocolorsCjsExports.dim(`+${hiddenAlertsCount} Hidden alerts ${vendor.yoctocolorsCjsExports.italic(getHiddenRisksDescription(getHiddenRiskCounts(hiddenAlerts)))}`)}\n`);
      }
    }
    prevAboveTheFold = isAboveTheFold;
  }
  const additionalHiddenCount = hiddenAlertsByPurl.size - mentionedPurlsWithHiddenAlerts.size;
  if (additionalHiddenCount) {
    const totalRiskCounts = {
      critical: 0,
      high: 0,
      middle: 0,
      low: 0
    };
    for (const {
      0: purl,
      1: alerts
    } of hiddenAlertsByPurl.entries()) {
      if (mentionedPurlsWithHiddenAlerts.has(purl)) {
        continue;
      }
      const riskCounts = getHiddenRiskCounts(alerts);
      totalRiskCounts.critical += riskCounts.critical;
      totalRiskCounts.high += riskCounts.high;
      totalRiskCounts.middle += riskCounts.middle;
      totalRiskCounts.low += riskCounts.low;
    }
    output.write(`${aboveTheFoldPurls.size ? '\n' : ''}${vendor.yoctocolorsCjsExports.dim(`${aboveTheFoldPurls.size ? '+' : ''}${additionalHiddenCount} Packages with hidden alerts ${vendor.yoctocolorsCjsExports.italic(getHiddenRisksDescription(totalRiskCounts))}`)}\n`);
  }
  output.write('\n');
}

function idToNpmPurl(id) {
  return `pkg:npm/${id}`;
}
function idToPurl(id, type) {
  return `pkg:${type}/${id}`;
}

function extractOverridesFromPnpmLockSrc(lockfileContent) {
  let match;
  if (typeof lockfileContent === 'string') {
    match = /^overrides:(?:\r?\n {2}.+)+(?:\r?\n)*/m.exec(lockfileContent)?.[0];
  }
  return match ?? '';
}
async function extractPurlsFromPnpmLockfile(lockfile) {
  const packages = lockfile?.packages ?? {};
  const seen = new Set();
  const visit = pkgPath => {
    if (seen.has(pkgPath)) {
      return;
    }
    const pkg = packages[pkgPath];
    if (!pkg) {
      return;
    }
    seen.add(pkgPath);
    const deps = {
      __proto__: null,
      ...pkg.dependencies,
      ...pkg.optionalDependencies,
      ...pkg.devDependencies
    };
    for (const depName in deps) {
      const ref = deps[depName];
      const subKey = isPnpmDepPath(ref) ? ref : `/${depName}@${ref}`;
      visit(subKey);
    }
  };
  for (const pkgPath of Object.keys(packages)) {
    visit(pkgPath);
  }
  return Array.from(seen).map(p => idToNpmPurl(stripPnpmPeerSuffix(stripLeadingPnpmDepPathSlash(p))));
}
function isPnpmDepPath(maybeDepPath) {
  return maybeDepPath.length > 0 && maybeDepPath.charCodeAt(0) === 47; /*'/'*/
}
function parsePnpmLockfile(lockfileContent) {
  let result;
  if (typeof lockfileContent === 'string') {
    try {
      result = vendor.jsYaml.load(strings.stripBom(lockfileContent));
    } catch {}
  }
  return require$$7.isObjectObject(result) ? result : null;
}
function parsePnpmLockfileVersion(version) {
  try {
    return vendor.semverExports.coerce(version);
  } catch {}
  return null;
}
function stripLeadingPnpmDepPathSlash(depPath) {
  return isPnpmDepPath(depPath) ? depPath.slice(1) : depPath;
}
function stripPnpmPeerSuffix(depPath) {
  const parenIndex = depPath.indexOf('(');
  const index = parenIndex === -1 ? depPath.indexOf('_') : parenIndex;
  return index === -1 ? depPath : depPath.slice(0, index);
}

async function getAlertsMapFromPnpmLockfile(lockfile, options) {
  const purls = await extractPurlsFromPnpmLockfile(lockfile);
  return await getAlertsMapFromPurls(purls, {
    overrides: lockfile.overrides,
    ...options
  });
}
async function getAlertsMapFromPurls(purls, options) {
  const opts = {
    __proto__: null,
    consolidate: false,
    include: undefined,
    nothrow: false,
    ...options
  };
  opts.include = {
    __proto__: null,
    // Leave 'actions' unassigned so it can be given a default value in
    // subsequent functions where `options` is passed.
    // actions: undefined,
    blocked: true,
    critical: true,
    cve: true,
    existing: false,
    unfixable: true,
    upgradable: false,
    ...opts.include
  };
  const uniqPurls = arrays.arrayUnique(purls);
  require$$6.debugDir('silly', {
    purls: uniqPurls
  });
  let {
    length: remaining
  } = uniqPurls;
  const alertsByPurl = new Map();
  if (!remaining) {
    return alertsByPurl;
  }
  const {
    spinner
  } = opts;
  const getText = () => `Looking up data for ${remaining} packages`;
  spinner?.start(getText());
  const sockSdkCResult = await setupSdk({
    apiToken: getPublicToken()
  });
  if (!sockSdkCResult.ok) {
    spinner?.stop();
    throw new Error('Auth error: Try to run `socket login` first');
  }
  const sockSdk = sockSdkCResult.data;
  const alertsMapOptions = {
    overrides: opts.overrides,
    consolidate: opts.consolidate,
    include: opts.include,
    spinner
  };
  for await (const batchResult of sockSdk.batchPackageStream({
    components: uniqPurls.map(purl => ({
      purl
    }))
  }, {
    queryParams: {
      alerts: 'true',
      compact: 'true',
      ...(opts.include.actions ? {
        actions: opts.include.actions.join(',')
      } : {}),
      ...(opts.include.unfixable ? {} : {
        fixable: 'true'
      })
    }
  })) {
    if (batchResult.success) {
      await addArtifactToAlertsMap(batchResult.data, alertsByPurl, alertsMapOptions);
    } else if (!opts.nothrow) {
      const statusCode = batchResult.status ?? 'unknown';
      const statusMessage = batchResult.error ?? 'No status message';
      throw new Error(`Socket API server error (${statusCode}): ${statusMessage}`);
    } else {
      spinner?.stop();
      logger.logger.fail(`Received a ${batchResult.status} response from Socket API which we consider a permanent failure:`, batchResult.error, batchResult.cause ? `( ${batchResult.cause} )` : '');
      require$$6.debugDir('inspect', {
        batchResult
      });
      break;
    }
    remaining -= 1;
    if (remaining > 0) {
      spinner?.start(getText());
    }
  }
  spinner?.stop();
  return alertsByPurl;
}

function npa(...args) {
  try {
    return Reflect.apply(vendor.npaExports, undefined, args);
  } catch {}
  return null;
}

async function removeNodeModules(cwd = process.cwd()) {
  const stream = await globStreamNodeModules(cwd);
  await streams.parallelEach(stream, p => fs.remove(p, {
    force: true,
    recursive: true
  }), {
    concurrency: 8
  });
}
async function findUp(name, {
  cwd = process.cwd(),
  // Lazily access constants.abortSignal.
  signal = constants.abortSignal
}) {
  let dir = path.resolve(cwd);
  const {
    root
  } = path.parse(dir);
  const names = [name].flat();
  while (dir && dir !== root) {
    for (const name of names) {
      if (signal?.aborted) {
        return undefined;
      }
      const filePath = path.join(dir, name);
      try {
        // eslint-disable-next-line no-await-in-loop
        const stats = await fs$1.promises.stat(filePath);
        if (stats.isFile()) {
          return filePath;
        }
      } catch {}
    }
    dir = path.dirname(dir);
  }
  return undefined;
}

const helpFlags = new Set(['--help', '-h']);
function cmdFlagsToString(args) {
  const result = [];
  for (let i = 0, {
      length
    } = args; i < length; i += 1) {
    if (args[i].startsWith('--')) {
      // Check if the next item exists and is NOT another flag.
      if (i + 1 < length && !args[i + 1].startsWith('--')) {
        result.push(`${args[i]}=${args[i + 1]}`);
        i += 1;
      } else {
        result.push(args[i]);
      }
    }
  }
  return result.join(' ');
}
function cmdFlagValueToArray(flagValue) {
  if (typeof flagValue === 'string') {
    return flagValue.trim().split(/, */);
  }
  if (Array.isArray(flagValue)) {
    return flagValue.flatMap(v => v.split(/, */));
  }
  return [];
}
function cmdPrefixMessage(cmdName, text) {
  const cmdPrefix = cmdName ? `${cmdName}: ` : '';
  return `${cmdPrefix}${text}`;
}
function isHelpFlag(cmdArg) {
  return helpFlags.has(cmdArg);
}

const {
  NPM: NPM$2,
  SOCKET_CLI_SAFE_BIN,
  SOCKET_CLI_SAFE_PROGRESS,
  SOCKET_IPC_HANDSHAKE
} = constants;
function safeNpmInstall(options) {
  const {
    agentExecPath = getNpmBinPath(),
    args = [],
    ipc,
    spinner,
    ...spawnOptions
  } = {
    __proto__: null,
    ...options
  };
  let stdio = spawnOptions.stdio;
  const useIpc = require$$7.isObject(ipc);
  // Include 'ipc' in the spawnOptions.stdio when an options.ipc object is provided.
  // See https://github.com/nodejs/node/blob/v23.6.0/lib/child_process.js#L161-L166
  // and https://github.com/nodejs/node/blob/v23.6.0/lib/internal/child_process.js#L238.
  if (typeof stdio === 'string') {
    stdio = useIpc ? [stdio, stdio, stdio, 'ipc'] : [stdio, stdio, stdio];
  } else if (useIpc && Array.isArray(stdio) && !stdio.includes('ipc')) {
    stdio = stdio.concat('ipc');
  }
  const useDebug = require$$6.isDebug('stdio');
  const terminatorPos = args.indexOf('--');
  const rawBinArgs = terminatorPos === -1 ? args : args.slice(0, terminatorPos);
  const progressArg = rawBinArgs.findLast(npm.isNpmProgressFlag) !== '--no-progress';
  const binArgs = rawBinArgs.filter(a => !npm.isNpmAuditFlag(a) && !npm.isNpmFundFlag(a) && !npm.isNpmProgressFlag(a));
  const otherArgs = terminatorPos === -1 ? [] : args.slice(terminatorPos);
  const isSilent = !useDebug && !binArgs.some(npm.isNpmLoglevelFlag);
  const logLevelArgs = isSilent ? ['--loglevel', 'silent'] : [];
  const spawnPromise = spawn.spawn(
  // Lazily access constants.execPath.
  constants.execPath, [
  // Lazily access constants.nodeNoWarningsFlags.
  ...constants.nodeNoWarningsFlags,
  // Lazily access constants.nodeHardenFlags.
  ...constants.nodeHardenFlags,
  // Lazily access constants.nodeMemoryFlags.
  ...constants.nodeMemoryFlags,
  // Lazily access constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD.
  ...(constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD ? ['--require',
  // Lazily access constants.instrumentWithSentryPath.
  constants.instrumentWithSentryPath] : []), '--require',
  // Lazily access constants.shadowNpmInjectPath.
  constants.shadowNpmInjectPath, npm.resolveBinPathSync(agentExecPath), 'install',
  // Avoid code paths for 'audit' and 'fund'.
  '--no-audit', '--no-fund',
  // Add '--no-progress' to fix input being swallowed by the npm spinner.
  '--no-progress',
  // Add '--loglevel=silent' if a loglevel flag is not provided and the
  // SOCKET_CLI_DEBUG environment variable is not truthy.
  ...logLevelArgs, ...binArgs, ...otherArgs], {
    spinner,
    ...spawnOptions,
    stdio,
    env: {
      ...process.env,
      // Lazily access constants.processEnv.
      ...constants.processEnv,
      ...spawnOptions.env
    }
  });
  if (useIpc) {
    spawnPromise.process.send({
      [SOCKET_IPC_HANDSHAKE]: {
        [SOCKET_CLI_SAFE_BIN]: NPM$2,
        [SOCKET_CLI_SAFE_PROGRESS]: progressArg,
        ...ipc
      }
    });
  }
  return spawnPromise;
}

const {
  NPM: NPM$1,
  PNPM: PNPM$1
} = constants;
function runAgentInstall(pkgEnvDetails, options) {
  const {
    agent,
    agentExecPath
  } = pkgEnvDetails;
  // All package managers support the "install" command.
  if (agent === NPM$1) {
    return safeNpmInstall({
      agentExecPath,
      ...options
    });
  }
  const {
    args = [],
    spinner,
    ...spawnOptions
  } = {
    __proto__: null,
    ...options
  };
  const skipNodeHardenFlags = agent === PNPM$1 && pkgEnvDetails.agentVersion.major < 11;
  return spawn.spawn(agentExecPath, ['install', ...args], {
    // Lazily access constants.WIN32.
    shell: constants.WIN32,
    spinner,
    stdio: 'inherit',
    ...spawnOptions,
    env: {
      ...process.env,
      // Lazily access constants.processEnv.
      ...constants.processEnv,
      NODE_OPTIONS: cmdFlagsToString([...(skipNodeHardenFlags ? [] :
      // Lazily access constants.nodeHardenFlags.
      constants.nodeHardenFlags),
      // Lazily access constants.nodeNoWarningsFlags.
      ...constants.nodeNoWarningsFlags]),
      ...spawnOptions.env
    }
  });
}

async function getNpmConfig(options) {
  const {
    cwd = process.cwd(),
    env = process.env,
    execPath = process.execPath,
    nodeVersion = process.version,
    npmCommand = 'install',
    npmPath = getNpmDirPath(),
    npmVersion,
    platform = process.platform
  } = {
    __proto__: null,
    ...options
  };
  const config = new vendor.libExports$2({
    argv: [],
    cwd,
    definitions: vendor.definitionsExports.definitions,
    execPath,
    env: {
      ...env
    },
    flatten: vendor.definitionsExports.flatten,
    npmPath,
    platform,
    shorthands: vendor.definitionsExports.shorthands
  });
  await config.load();
  const flatConfig = {
    __proto__: null,
    ...config.flat
  };
  if (nodeVersion) {
    flatConfig.nodeVersion = nodeVersion;
  }
  if (npmCommand) {
    flatConfig.npmCommand = npmCommand;
  }
  if (npmVersion) {
    flatConfig.npmVersion = npmVersion.toString();
  }
  return flatConfig;
}

async function readLockfile(lockfilePath) {
  return fs$1.existsSync(lockfilePath) ? await fs.readFileUtf8(lockfilePath) : null;
}

const {
  BINARY_LOCK_EXT,
  BUN,
  HIDDEN_PACKAGE_LOCK_JSON,
  LOCK_EXT,
  NPM,
  NPM_BUGGY_OVERRIDES_PATCHED_VERSION,
  PACKAGE_JSON,
  PNPM,
  VLT,
  YARN,
  YARN_BERRY,
  YARN_CLASSIC
} = constants;
const AGENTS = [BUN, NPM, PNPM, YARN_BERRY, YARN_CLASSIC, VLT];
const binByAgent = new Map([[BUN, BUN], [NPM, NPM], [PNPM, PNPM], [YARN_BERRY, YARN], [YARN_CLASSIC, YARN], [VLT, VLT]]);
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (...args) => {
      try {
        return await reader(...args);
      } catch {}
      return undefined;
    };
  }
  const binaryReader = wrapReader(fs.readFileBinary);
  const defaultReader = wrapReader(async lockPath => await fs.readFileUtf8(lockPath));
  return new Map([[BUN, wrapReader(async (lockPath, agentExecPath, cwd = process.cwd()) => {
    const ext = path.extname(lockPath);
    if (ext === LOCK_EXT) {
      return await defaultReader(lockPath);
    }
    if (ext === BINARY_LOCK_EXT) {
      const lockBuffer = await binaryReader(lockPath);
      if (lockBuffer) {
        try {
          return vendor.hyrious__bun_lockbExports.parse(lockBuffer);
        } catch {}
      }
      // To print a Yarn lockfile to your console without writing it to disk
      // use `bun bun.lockb`.
      // https://bun.sh/guides/install/yarnlock
      return (await spawn.spawn(agentExecPath, [lockPath], {
        cwd,
        // Lazily access constants.WIN32.
        shell: constants.WIN32
      })).stdout;
    }
    return undefined;
  })], [NPM, defaultReader], [PNPM, defaultReader], [VLT, defaultReader], [YARN_BERRY, defaultReader], [YARN_CLASSIC, defaultReader]]);
})();

// The order of LOCKS properties IS significant as it affects iteration order.
const LOCKS = {
  [`bun${LOCK_EXT}`]: BUN,
  [`bun${BINARY_LOCK_EXT}`]: BUN,
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  'npm-shrinkwrap.json': NPM,
  'package-lock.json': NPM,
  'pnpm-lock.yaml': PNPM,
  'pnpm-lock.yml': PNPM,
  [`yarn${LOCK_EXT}`]: YARN_CLASSIC,
  'vlt-lock.json': VLT,
  // Lastly, look for a hidden lock file which is present if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  'node_modules/.package-lock.json': NPM
};
async function getAgentExecPath(agent) {
  const binName = binByAgent.get(agent);
  if (binName === NPM) {
    // Lazily access constants.npmExecPath.
    return constants.npmExecPath;
  }
  return (await vendor.libExports$1(binName, {
    nothrow: true
  })) ?? binName;
}
async function getAgentVersion(agent, agentExecPath, cwd) {
  let result;
  const quotedCmd = `\`${agent} --version\``;
  require$$6.debugFn('stdio', `spawn: ${quotedCmd}`);
  try {
    result =
    // Coerce version output into a valid semver version by passing it through
    // semver.coerce which strips leading v's, carets (^), comparators (<,<=,>,>=,=),
    // and tildes (~).
    vendor.semverExports.coerce(
    // All package managers support the "--version" flag.
    (await spawn.spawn(agentExecPath, ['--version'], {
      cwd,
      // Lazily access constants.WIN32.
      shell: constants.WIN32
    })).stdout) ?? undefined;
  } catch (e) {
    require$$6.debugFn('error', `caught: ${quotedCmd} failed`);
    require$$6.debugDir('inspect', {
      error: e
    });
  }
  return result;
}
async function detectPackageEnvironment({
  cwd = process.cwd(),
  onUnknown
} = {}) {
  let lockPath = await findUp(Object.keys(LOCKS), {
    cwd
  });
  let lockName = lockPath ? path.basename(lockPath) : undefined;
  const isHiddenLockFile = lockName === HIDDEN_PACKAGE_LOCK_JSON;
  const pkgJsonPath = lockPath ? path.resolve(lockPath, `${isHiddenLockFile ? '../' : ''}../${PACKAGE_JSON}`) : await findUp(PACKAGE_JSON, {
    cwd
  });
  const pkgPath = pkgJsonPath && fs$1.existsSync(pkgJsonPath) ? path.dirname(pkgJsonPath) : undefined;
  const editablePkgJson = pkgPath ? await packages.readPackageJson(pkgPath, {
    editable: true
  }) : undefined;
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = strings.isNonEmptyString(editablePkgJson?.content?.packageManager) ? editablePkgJson.content.packageManager : undefined;
  let agent;
  if (pkgManager) {
    // A valid "packageManager" field value is "<package manager name>@<version>".
    // https://nodejs.org/api/packages.html#packagemanager
    const atSignIndex = pkgManager.lastIndexOf('@');
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex);
      const version = pkgManager.slice(atSignIndex + 1);
      if (version && AGENTS.includes(name)) {
        agent = name;
      }
    }
  }
  if (agent === undefined && !isHiddenLockFile && typeof pkgJsonPath === 'string' && typeof lockName === 'string') {
    agent = LOCKS[lockName];
  }
  if (agent === undefined) {
    agent = NPM;
    onUnknown?.(pkgManager);
  }
  const agentExecPath = await getAgentExecPath(agent);
  const agentVersion = await getAgentVersion(agent, agentExecPath, cwd);
  if (agent === YARN_CLASSIC && (agentVersion?.major ?? 0) > 1) {
    agent = YARN_BERRY;
  }
  // Lazily access constants.maintainedNodeVersions.
  const {
    maintainedNodeVersions
  } = constants;
  // Lazily access constants.minimumVersionByAgent.
  const minSupportedAgentVersion = constants.minimumVersionByAgent.get(agent);
  const minSupportedNodeMajor = vendor.semverExports.major(maintainedNodeVersions.last);
  const minSupportedNodeVersion = `${minSupportedNodeMajor}.0.0`;
  const minSupportedNodeRange = `>=${minSupportedNodeMajor}`;
  const nodeVersion = vendor.semverExports.coerce(process.version);
  let lockSrc;
  let pkgAgentRange;
  let pkgNodeRange;
  let pkgMinAgentVersion = minSupportedAgentVersion;
  let pkgMinNodeVersion = minSupportedNodeVersion;
  if (editablePkgJson?.content) {
    const {
      engines
    } = editablePkgJson.content;
    const engineAgentRange = engines?.[agent];
    const engineNodeRange = engines?.['node'];
    if (strings.isNonEmptyString(engineAgentRange)) {
      pkgAgentRange = engineAgentRange;
      // Roughly check agent range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgAgentRange);
      if (coerced && vendor.semverExports.lt(coerced, pkgMinAgentVersion)) {
        pkgMinAgentVersion = coerced.version;
      }
    }
    if (strings.isNonEmptyString(engineNodeRange)) {
      pkgNodeRange = engineNodeRange;
      // Roughly check Node range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgNodeRange);
      if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
        pkgMinNodeVersion = coerced.version;
      }
    }
    const browserslistQuery = editablePkgJson.content['browserslist'];
    if (Array.isArray(browserslistQuery)) {
      // List Node targets in ascending version order.
      const browserslistNodeTargets = vendor.browserslistExports(browserslistQuery).filter(v => /^node /i.test(v)).map(v => v.slice(5 /*'node '.length*/)).sort(sorts.naturalCompare);
      if (browserslistNodeTargets.length) {
        // browserslistNodeTargets[0] is the lowest Node target version.
        const coerced = vendor.semverExports.coerce(browserslistNodeTargets[0]);
        if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
          pkgMinNodeVersion = coerced.version;
        }
      }
    }
    lockSrc = typeof lockPath === 'string' ? await readLockFileByAgent.get(agent)(lockPath, agentExecPath, cwd) : undefined;
  } else {
    lockName = undefined;
    lockPath = undefined;
  }

  // Does the system agent version meet our minimum supported agent version?
  const agentSupported = !!agentVersion && vendor.semverExports.satisfies(agentVersion, `>=${minSupportedAgentVersion}`);
  // Does the system Node version meet our minimum supported Node version?
  const nodeSupported = vendor.semverExports.satisfies(nodeVersion, minSupportedNodeRange);
  const npmExecPath = agent === NPM ? agentExecPath : await getAgentExecPath(NPM);
  const npmBuggyOverrides = agent === NPM && !!agentVersion && vendor.semverExports.lt(agentVersion, NPM_BUGGY_OVERRIDES_PATCHED_VERSION);
  const pkgMinAgentRange = `>=${pkgMinAgentVersion}`;
  const pkgMinNodeRange = `>=${vendor.semverExports.major(pkgMinNodeVersion)}`;
  return {
    agent,
    agentExecPath,
    agentSupported,
    agentVersion,
    editablePkgJson,
    features: {
      npmBuggyOverrides
    },
    lockName,
    lockPath,
    lockSrc,
    nodeSupported,
    nodeVersion,
    npmExecPath,
    pkgPath,
    pkgRequirements: {
      agent: pkgAgentRange ?? pkgMinAgentRange,
      node: pkgNodeRange ?? pkgMinNodeRange
    },
    pkgSupports: {
      // Does our minimum supported agent version meet the package's requirements?
      agent: vendor.semverExports.satisfies(minSupportedAgentVersion, pkgMinAgentRange),
      // Does our supported Node versions meet the package's requirements?
      node: maintainedNodeVersions.some(v => vendor.semverExports.satisfies(v, pkgMinNodeRange))
    }
  };
}
async function detectAndValidatePackageEnvironment(cwd, options) {
  const {
    cmdName = '',
    logger,
    prod
  } = {
    __proto__: null,
    ...options
  };
  const details = await detectPackageEnvironment({
    cwd,
    onUnknown(pkgManager) {
      logger?.warn(cmdPrefixMessage(cmdName, `Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`));
    }
  });
  const {
    agent,
    nodeVersion,
    pkgRequirements
  } = details;
  const agentVersion = details.agentVersion ?? 'unknown';
  if (!details.agentSupported) {
    const minVersion = constants.minimumVersionByAgent.get(agent);
    return {
      ok: false,
      message: 'Version mismatch',
      cause: cmdPrefixMessage(cmdName, `Requires ${agent} >=${minVersion}. Current version: ${agentVersion}.`)
    };
  }
  if (!details.nodeSupported) {
    const minVersion = constants.maintainedNodeVersions.last;
    return {
      ok: false,
      message: 'Version mismatch',
      cause: cmdPrefixMessage(cmdName, `Requires Node >=${minVersion}. Current version: ${nodeVersion}.`)
    };
  }
  if (!details.pkgSupports.agent) {
    return {
      ok: false,
      message: 'Engine mismatch',
      cause: cmdPrefixMessage(cmdName, `Package engine "${agent}" requires ${pkgRequirements.agent}. Current version: ${agentVersion}`)
    };
  }
  if (!details.pkgSupports.node) {
    return {
      ok: false,
      message: 'Version mismatch',
      cause: cmdPrefixMessage(cmdName, `Package engine "node" requires ${pkgRequirements.node}. Current version: ${nodeVersion}`)
    };
  }
  const lockName = details.lockName ?? 'lock file';
  if (details.lockName === undefined || details.lockSrc === undefined) {
    return {
      ok: false,
      message: 'Missing lockfile',
      cause: cmdPrefixMessage(cmdName, `No ${lockName} found`)
    };
  }
  if (details.lockSrc.trim() === '') {
    return {
      ok: false,
      message: 'Empty lockfile',
      cause: cmdPrefixMessage(cmdName, `${lockName} is empty`)
    };
  }
  if (details.pkgPath === undefined) {
    return {
      ok: false,
      message: 'Missing package.json',
      cause: cmdPrefixMessage(cmdName, `No ${PACKAGE_JSON} found`)
    };
  }
  if (prod && (agent === BUN || agent === YARN_BERRY)) {
    return {
      ok: false,
      message: 'Bad input',
      cause: cmdPrefixMessage(cmdName, `--prod not supported for ${agent}${agentVersion ? `@${agentVersion}` : ''}`)
    };
  }
  if (details.lockPath && path.relative(cwd, details.lockPath).startsWith('.')) {
    // Note: In tests we return <redacted> because otherwise snapshots will fail.
    const {
      REDACTED
    } = constants;
    // Lazily access constants.ENV.VITEST.
    const redacting = constants.ENV.VITEST;
    logger?.warn(cmdPrefixMessage(cmdName, `Package ${lockName} found at ${redacting ? REDACTED : details.lockPath}`));
  }
  return {
    ok: true,
    data: details
  };
}

const COMPLETION_CMD_PREFIX = 'complete -F _socket_completion';
function getCompletionSourcingCommand() {
  // Note: this is exported to distPath in .config/rollup.dist.config.mjs
  const completionScriptExportPath = path.join(
  // Lazily access constants.distPath.
  constants.distPath, 'socket-completion.bash');
  if (!fs$1.existsSync(completionScriptExportPath)) {
    return {
      ok: false,
      message: 'Tab Completion script not found',
      cause: `Expected to find completion script at \`${completionScriptExportPath}\` but it was not there`
    };
  }
  return {
    ok: true,
    data: `source ${completionScriptExportPath}`
  };
}
function getBashrcDetails(targetCommandName) {
  const sourcingCommand = getCompletionSourcingCommand();
  if (!sourcingCommand.ok) {
    return sourcingCommand;
  }

  // Lazily access constants.socketAppDataPath.
  const {
    socketAppDataPath
  } = constants;
  if (!socketAppDataPath) {
    return {
      ok: false,
      message: 'Could not determine config directory',
      cause: 'Failed to get config path'
    };
  }

  // _socket_completion is the function defined in our completion bash script
  const completionCommand = `${COMPLETION_CMD_PREFIX} ${targetCommandName}`;

  // Location of completion script in config after installing
  const completionScriptPath = path.join(path.dirname(socketAppDataPath), 'completion', 'socket-completion.bash');
  const bashrcContent = `# Socket CLI completion for "${targetCommandName}"
if [ -f "${completionScriptPath}" ]; then
    # Load the tab completion script
    source "${completionScriptPath}"
    # Tell bash to use this function for tab completion of this function
    ${completionCommand}
fi
`;
  return {
    ok: true,
    data: {
      sourcingCommand: sourcingCommand.data,
      completionCommand,
      toAddToBashrc: bashrcContent,
      targetName: targetCommandName,
      targetPath: completionScriptPath
    }
  };
}

const {
  kInternalsSymbol,
  [kInternalsSymbol]: {
    getSentry
  }
} = constants;
class AuthError extends Error {}
class InputError extends Error {
  constructor(message, body) {
    super(message);
    this.body = body;
  }
}
async function captureException(exception, hint) {
  const result = captureExceptionSync(exception, hint);
  // "Sleep" for a second, just in case, hopefully enough time to initiate fetch.
  await promises.setTimeout(1000);
  return result;
}
function captureExceptionSync(exception, hint) {
  const Sentry = getSentry();
  if (!Sentry) {
    return '';
  }
  require$$6.debugFn('notice', 'send: exception to Sentry');
  return Sentry.captureException(exception, hint);
}

const ALL_ECOSYSTEMS = ['apk', 'bitbucket', 'cargo', 'chrome', 'cocoapods', 'composer', 'conan', 'conda', 'cran', 'deb', 'docker', 'gem', 'generic', 'github', 'golang', 'hackage', 'hex', 'huggingface', 'maven', 'mlflow', 'npm', 'nuget', 'oci', 'pub', 'pypi', 'qpkg', 'rpm', 'swift', 'swid', 'unknown'];
new Set(ALL_ECOSYSTEMS);
function getEcosystemChoicesForMeow() {
  return [...ALL_ECOSYSTEMS];
}

exports.AuthError = AuthError;
exports.COMPLETION_CMD_PREFIX = COMPLETION_CMD_PREFIX;
exports.InputError = InputError;
exports.RangeStyles = RangeStyles;
exports.applyRange = applyRange;
exports.captureException = captureException;
exports.checkCommandInput = checkCommandInput;
exports.cmdFlagValueToArray = cmdFlagValueToArray;
exports.cmdFlagsToString = cmdFlagsToString;
exports.cmdPrefixMessage = cmdPrefixMessage;
exports.createEnum = createEnum;
exports.detectAndValidatePackageEnvironment = detectAndValidatePackageEnvironment;
exports.determineOrgSlug = determineOrgSlug;
exports.extractOverridesFromPnpmLockSrc = extractOverridesFromPnpmLockSrc;
exports.extractTier1ReachabilityScanId = extractTier1ReachabilityScanId;
exports.failMsgWithBadge = failMsgWithBadge;
exports.fetchOrganization = fetchOrganization;
exports.getAlertsMapFromPnpmLockfile = getAlertsMapFromPnpmLockfile;
exports.getAlertsMapFromPurls = getAlertsMapFromPurls;
exports.getBaseBranch = getBaseBranch;
exports.getBashrcDetails = getBashrcDetails;
exports.getConfigValue = getConfigValue;
exports.getConfigValueOrUndef = getConfigValueOrUndef;
exports.getCveInfoFromAlertsMap = getCveInfoFromAlertsMap;
exports.getDefaultOrgSlug = getDefaultOrgSlug;
exports.getEcosystemChoicesForMeow = getEcosystemChoicesForMeow;
exports.getFlagListOutput = getFlagListOutput;
exports.getMajor = getMajor;
exports.getMinVersion = getMinVersion;
exports.getNpmBinPath = getNpmBinPath;
exports.getNpmConfig = getNpmConfig;
exports.getNpmRequire = getNpmRequire;
exports.getNpxBinPath = getNpxBinPath;
exports.getOutputKind = getOutputKind;
exports.getPackageFilesForScan = getPackageFilesForScan;
exports.getPkgFullNameFromPurl = getPkgFullNameFromPurl;
exports.getPurlObject = getPurlObject;
exports.getRepoInfo = getRepoInfo;
exports.getRepoName = getRepoName;
exports.getSocketDevPackageOverviewUrlFromPurl = getSocketDevPackageOverviewUrlFromPurl;
exports.getSupportedConfigEntries = getSupportedConfigEntries;
exports.getSupportedConfigKeys = getSupportedConfigKeys;
exports.getVisibleTokenPrefix = getVisibleTokenPrefix;
exports.gitBranch = gitBranch;
exports.gitCheckoutBranch = gitCheckoutBranch;
exports.gitCommit = gitCommit;
exports.gitCreateBranch = gitCreateBranch;
exports.gitDeleteBranch = gitDeleteBranch;
exports.gitPushBranch = gitPushBranch;
exports.gitRemoteBranchExists = gitRemoteBranchExists;
exports.gitResetAndClean = gitResetAndClean;
exports.gitUnstagedModifiedFiles = gitUnstagedModifiedFiles;
exports.globWorkspace = globWorkspace;
exports.handleApiCall = handleApiCall;
exports.handleApiCallNoSpinner = handleApiCallNoSpinner;
exports.hasDefaultToken = hasDefaultToken;
exports.idToNpmPurl = idToNpmPurl;
exports.idToPurl = idToPurl;
exports.isHelpFlag = isHelpFlag;
exports.isNpmBinPathShadowed = isNpmBinPathShadowed;
exports.isNpxBinPathShadowed = isNpxBinPathShadowed;
exports.isReadOnlyConfig = isReadOnlyConfig;
exports.isReportSupportedFile = isReportSupportedFile;
exports.isSensitiveConfigKey = isSensitiveConfigKey;
exports.isSupportedConfigKey = isSupportedConfigKey;
exports.logAlertsMap = logAlertsMap;
exports.mapToObject = mapToObject;
exports.mdTable = mdTable;
exports.mdTableOfPairs = mdTableOfPairs;
exports.mdTableStringNumber = mdTableStringNumber;
exports.meowOrExit = meowOrExit;
exports.meowWithSubcommands = meowWithSubcommands;
exports.msAtHome = msAtHome;
exports.npa = npa;
exports.parsePnpmLockfile = parsePnpmLockfile;
exports.parsePnpmLockfileVersion = parsePnpmLockfileVersion;
exports.queryApiSafeJson = queryApiSafeJson;
exports.queryApiSafeText = queryApiSafeText;
exports.readLockfile = readLockfile;
exports.readOrDefaultSocketJson = readOrDefaultSocketJson;
exports.readSocketJsonSync = readSocketJsonSync;
exports.removeNodeModules = removeNodeModules;
exports.runAgentInstall = runAgentInstall;
exports.sendApiRequest = sendApiRequest;
exports.serializeResultJson = serializeResultJson;
exports.setupSdk = setupSdk;
exports.spawnCoana = spawnCoana;
exports.suggestOrgSlug = suggestOrgSlug;
exports.tildify = tildify;
exports.updateConfigValue = updateConfigValue;
exports.walkNestedMap = walkNestedMap;
exports.writeSocketJson = writeSocketJson;
//# debugId=445cbd8a-143c-48cc-a31a-b95bf960f88e
//# sourceMappingURL=utils.js.map
